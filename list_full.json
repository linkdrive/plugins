[{"hash":"f601429933f043f872fb14f7d6049e60","name":"AliyunDrive","namespace":"sharelist.plugin.aliyundrive","version":"1.0.0","license":"MIT","description":"Aliyun Drive","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/aliyundrive/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTIyLjAzNTUgMTMuODA2MUMyMS43NjQ2IDEzLjczMzggMjEuNTkxIDEzLjQ2MjEgMjEuNjUxNSAxMy4xODlDMjIuODc4MSA3LjU1NjU1IDE5LjQ1MDkgMS44Nzk1MSAxMy44MDU1IDAuMzcxOTc5QzcuOTk5NTEgLTEuMTc4NDQgMi4wMDgzNyAyLjI2MDA0IDAuNDM5MTc3IDguMDM5MDhDMC40Mzg1MzUgOC4wNDE0NyAwLjQzNzg5MiA4LjA0Mzg2IDAuNDM2NjA4IDguMDQ4NjNDMC40MzUzMjMgOC4wNTM0MSAwLjQzMzM5NyA4LjA2MDU4IDAuNDMyMTEyIDguMDY1MzZDLTAuNTIzMzgxIDExLjY0NzggMC4xMTY1MSAxNS40MDI5IDIuMjQ0NjcgMTguNTA1N0MzLjcyNzEzIDIwLjY2NTUgNS44NjcwNCAyMi4zMTk5IDguMzMwOTEgMjMuMjE4NUMxNS4yMTgyIDI1LjcyNTkgMjIuNjMzNiAyMS45Njg4IDI0LjgyNTUgMTUuMjVDMjQuOTM5NyAxNC45MDE2IDI0LjczNDcgMTQuNTI2OSAyNC4zNzc1IDE0LjQzMTVMMjIuMDM1NSAxMy44MDYxWk0xMC41OTQyIDE5LjI2MzNDOC40Nzk4NyAxOC42OTg3IDYuNzEyODggMTcuMzQ4NyA1LjYyMDE4IDE1LjQ1OTRDNC41MjY4MyAxMy41NzI1IDQuMjM1NzEgMTEuMzc3NSA0Ljc5OTExIDkuMjcyNDdDNS43MzQ3NyA1LjgzMDYyIDkuMzAxNzUgMy43ODI2NiAxMi43NjA5IDQuNzA2MzhDMTYuMDQ1IDUuNTgzMzcgMTguMDY4NSA4LjgyNzIxIDE3LjQ4MDYgMTIuMTAzM0MxNy40MjYgMTIuNDExNCAxNy42MSAxMi43MTE0IDE3LjkxNDQgMTIuNzkyN0wyMC4xMTk4IDEzLjM4MTZDMjAuNDAwMyAxMy40NTY1IDIwLjU1NzMgMTMuNzUxOSAyMC40NjM2IDE0LjAyMzhDMTkuMDgzNSAxOC4wNDg1IDE0Ljc3NDkgMjAuMzc5NyAxMC41OTQyIDE5LjI2MzNaIiBmaWxsPSJyZ2IoMTAzLDEyNSwyMzgpIj48L3BhdGg+PC9zdmc+","script":"//===Sharelist===\n// @name         AliyunDrive\n// @namespace    sharelist.plugin.aliyundrive\n// @version      1.0.0\n// @license      MIT\n// @description  Aliyun Drive\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/aliyundrive/index.js\n// @icon         data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTIyLjAzNTUgMTMuODA2MUMyMS43NjQ2IDEzLjczMzggMjEuNTkxIDEzLjQ2MjEgMjEuNjUxNSAxMy4xODlDMjIuODc4MSA3LjU1NjU1IDE5LjQ1MDkgMS44Nzk1MSAxMy44MDU1IDAuMzcxOTc5QzcuOTk5NTEgLTEuMTc4NDQgMi4wMDgzNyAyLjI2MDA0IDAuNDM5MTc3IDguMDM5MDhDMC40Mzg1MzUgOC4wNDE0NyAwLjQzNzg5MiA4LjA0Mzg2IDAuNDM2NjA4IDguMDQ4NjNDMC40MzUzMjMgOC4wNTM0MSAwLjQzMzM5NyA4LjA2MDU4IDAuNDMyMTEyIDguMDY1MzZDLTAuNTIzMzgxIDExLjY0NzggMC4xMTY1MSAxNS40MDI5IDIuMjQ0NjcgMTguNTA1N0MzLjcyNzEzIDIwLjY2NTUgNS44NjcwNCAyMi4zMTk5IDguMzMwOTEgMjMuMjE4NUMxNS4yMTgyIDI1LjcyNTkgMjIuNjMzNiAyMS45Njg4IDI0LjgyNTUgMTUuMjVDMjQuOTM5NyAxNC45MDE2IDI0LjczNDcgMTQuNTI2OSAyNC4zNzc1IDE0LjQzMTVMMjIuMDM1NSAxMy44MDYxWk0xMC41OTQyIDE5LjI2MzNDOC40Nzk4NyAxOC42OTg3IDYuNzEyODggMTcuMzQ4NyA1LjYyMDE4IDE1LjQ1OTRDNC41MjY4MyAxMy41NzI1IDQuMjM1NzEgMTEuMzc3NSA0Ljc5OTExIDkuMjcyNDdDNS43MzQ3NyA1LjgzMDYyIDkuMzAxNzUgMy43ODI2NiAxMi43NjA5IDQuNzA2MzhDMTYuMDQ1IDUuNTgzMzcgMTguMDY4NSA4LjgyNzIxIDE3LjQ4MDYgMTIuMTAzM0MxNy40MjYgMTIuNDExNCAxNy42MSAxMi43MTE0IDE3LjkxNDQgMTIuNzkyN0wyMC4xMTk4IDEzLjM4MTZDMjAuNDAwMyAxMy40NTY1IDIwLjU1NzMgMTMuNzUxOSAyMC40NjM2IDE0LjAyMzhDMTkuMDgzNSAxOC4wNDg1IDE0Ljc3NDkgMjAuMzc5NyAxMC41OTQyIDE5LjI2MzNaIiBmaWxsPSJyZ2IoMTAzLDEyNSwyMzgpIj48L3BhdGg+PC9zdmc+\n//===/Sharelist==\n\n\nconst UPLOAD_PART_SIZE = 10 * 1024 * 1024\n\nconst API_ENDPOINT = 'https://api.aliyundrive.com'\n\nconst DEFAULT_UA = `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36`\n\nconst REFERER = `https://www.aliyundrive.com/`\n\nconst atob = v => Buffer.from(v, 'base64').toString()\n\nconst isMobileToken = (access_token) => {\n  try {\n    return !JSON.parse(JSON.parse(atob(access_token.split('.')[1])).customJson).ref\n  } catch (e) {\n\n  }\n  return false\n}\n\nconst replaceCDNUrl = (url) => {\n  return url.replace(/https:\\/\\/([\\w\\W]+?)\\./, (_, srv) => `https://${srv}-enet.`)\n}\n\n/**\n * auth manager class\n */\nclass Manager {\n  static getInstance(app, config) {\n    if (!this.instance) {\n      this.instance = new Manager(app)\n    }\n\n    // this.instance.add(config)\n    const getter = this.instance.createGetter(config)\n\n    // lazy load config\n    // getter()\n\n    return getter\n  }\n\n  constructor(app) {\n    this.app = app\n  }\n\n  createGetter(config) {\n    let DRIVE_KEY = this.app.DRIVE_KEY\n\n    if (!config[DRIVE_KEY] && config.user_id) {\n      config[DRIVE_KEY] = config.user_id\n    }\n\n    return async () => {\n      if (\n        !config.user_id ||\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\n      ) {\n        await this.refreshAccessToken(config)\n      }\n      if (!config[DRIVE_KEY]) {\n        config[DRIVE_KEY] = config.user_id\n      }\n\n      return {\n        ...config\n      }\n    }\n  }\n\n\n  /**\n   * refreshAccessToken\n   *\n   * @param {object} options\n   * @param {string} options.refresh_token\n   * @return {object} [credentials]\n   * @api private\n   */\n  async refreshAccessToken(config) {\n    let { refresh_token: lastRefeshToken } = config\n    //TODO: Web client API CAN NOT support mobile token\n    // https://auth.aliyundrive.com/v2/account/token\n    // mobile: ${API_ENDPOINT}/v2/account/token\n    // web: ${API_ENDPOINT}/token/refresh\n    let { data, headers } = await this.app.request.post(`${API_ENDPOINT}/v2/account/token`, {\n      data: {\n        refresh_token: lastRefeshToken,\n        grant_type: \"refresh_token\"\n      },\n      headers: {\n        'User-Agent': 'None',\n      },\n      contentType: 'json',\n    })\n    if (data && !data.access_token) {\n      throw new Error({ message: data.message || 'An error occurred during refresh access token' })\n    }\n    let { user_id, access_token, default_drive_id: drive_id, expires_in, refresh_token, device_id } = data\n\n    // expires_in 7200s\n    let expires_at = Date.now() + expires_in * 1000\n\n    config.user_id = user_id\n    config.refresh_token = refresh_token\n    config.access_token = access_token\n    config.expires_at = expires_at\n    config.drive_id = drive_id\n    config.token_type = isMobileToken(access_token) ? 'mobile' : 'web'\n    config.device_id = device_id\n\n    // key 内部属性, 区分不同挂载盘\n    if (!config.key) {\n      config.key = user_id\n    }\n  }\n}\n\nclass Driver {\n  static options = {\n    protocol: \"aliyun\",\n\n    //支持全局搜索\n    globalSearch: true,\n    localSearch: false,\n\n    hash: 'sha1',\n    uploadHash: 'sha1',\n    // key: 'user_id',\n    defaultRoot: 'root',\n\n    guide: [\n      { key: 'refresh_token', label: 'Refresh Token', type: 'string', required: true },\n      {\n        key: 'root_id',\n        label: '初始文件夹ID / Root ID',\n        help: 'https://www.aliyundrive.com/drive/folder/xxxxxxxxxxx 地址中 xxxx 的部分',\n        type: 'string',\n      },\n    ]\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.getConfig = Manager.getInstance(app, config)\n\n  }\n  /**\n   * list files\n   *\n   * @param {string} [id] folder id\n   * @param {object} [options] list options\n   * @param {object} [options.sort] sort methods\n   * @param {object} [options.search] search\n   * @return {object}\n   *\n   * @api public\n   */\n  async list(id, { search, orderBy, perPage, nextPage }) {\n\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n\n    let { drive_id, access_token, device_id } = await this.getConfig()\n\n    let isSearch = !!search\n\n    let usePagination = !!perPage\n\n    let url = `${API_ENDPOINT}/adrive/v3/file/${isSearch ? 'search' : 'list'}`\n    let params = isSearch ? {\n      drive_id,\n      limit: 100, // max 100\n      query: `name match \\\"${search}\\\"`,\n      order_by: \"updated_at DESC\"\n    } : {\n      drive_id,\n      parent_file_id: id,\n      limit: 200,\n      fields: \"*\",\n      url_expire_sec: 1600\n    }\n\n    if (orderBy) {\n      let [sortKey, isASC] = orderBy\n      if (isSearch) {\n        params.order_by = `${sortKey || 'name'} ${isASC ? 'ASC' : 'DESC'}`\n      } else {\n        params.order_by = sortKey || 'name'\n        params.order_direction = isASC ? 'ASC' : 'DESC'\n      }\n    }\n\n    let marker = nextPage, files = []\n\n    do {\n      let { data } = await request.post(url, {\n        data: { ...params, ...(marker ? { marker } : {}) },\n\n        headers: {\n          Authorization: access_token,\n          'user-agent': DEFAULT_UA,\n          'x-canary': 'client=web,app=adrive,version=v3.6.1',\n          'x-device-id': device_id,\n          'referer': REFERER\n        },\n        contentType: 'json',\n      })\n\n      // if (!data.items) return { error: { message: 'An error occurred when list folder' } }\n      if (data.error) return data\n\n      if (!data.items) return this.app.error({ message: data.message })\n\n      for (let i of data.items) {\n        files.push({\n          id: i.file_id,\n          name: i.name,\n          type: i.type == 'folder' ? 'folder' : 'file',\n          size: i.size,\n          ctime: timestamp(i.created_at),\n          mtime: timestamp(i.updated_at),\n          download_url: i.url,\n          extra: {\n            fid: i.file_id,\n            parent_id: i.parent_file_id,\n            sha1: i.content_hash\n          },\n        })\n      }\n\n      marker = data.next_marker\n    } while (!usePagination && marker)\n\n\n    let result = {\n      id, files\n    }\n\n    if (usePagination && marker) {\n      result.nextPage = marker\n    }\n\n    return result\n  }\n\n  /**\n   * get file\n   *\n   * @param {string} [file_id] folder/file id\n   * @return {object}\n   *\n   * @api public\n   */\n  async get(file_id) {\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n\n    let { drive_id, access_token } = await this.getConfig()\n\n    let { data } = await request.post(`${API_ENDPOINT}/v2/file/get`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        drive_id,\n        file_id,\n      },\n      contentType: 'json',\n    })\n\n    if (data.error) return data.error\n    let result = {\n      id: data.file_id,\n      name: data.name,\n      type: data.type,\n      size: data.size,\n      ctime: timestamp(data.created_at),\n      mtime: timestamp(data.updated_at),\n      download_url: data.download_url,\n      extra: {\n        fid: data.file_id,\n        parent_id: data.parent_file_id,\n      },\n    }\n\n\n\n\n    if (result.type == 'file') {\n      // if (data.category == 'video') {\n      //   let sources = await this.video_preview(access_token, id, drive_id)\n      //   result.extra.category = 'video'\n      //   if (sources.length) {\n      //     result.extra.sources = sources\n      //   }\n      // }\n\n      if (!result.download_url) {\n        let res = await this.get_download_url(file_id)\n        result.download_url = res.url\n      } else {\n        // result.download_url = replaceCDNUrl(result.download_url)\n      }\n\n      //The referer needs to be verified when using web refresh_token\n      if (result.download_url?.includes('x-oss-additional-headers=referer')) {\n        result.extra.proxy = {\n          headers: {\n            referer: REFERER,\n            //'user-agent': 'SmartDrive/24732503 CFNetwork/1331.0.7 Darwin/21.4.0'\n          },\n        }\n      }\n      let expired_at = +(result.download_url.match(/x\\-oss\\-expires=(\\d+)/)?.[1] || 0) * 1000\n\n      // The download link will expire after 15 minutes.\n      result.max_age = expired_at - Date.now()\n    } else {\n      result.max_age = 1 * 3600 * 1000\n    }\n\n    return result\n  }\n\n  async get_path(file_id) {\n    let { drive_id, access_token } = await this.getConfig()\n    const { request } = this.app\n\n    try {\n      let { data } = await request.post(`${API_ENDPOINT}/adrive/v1/file/get_path`, {\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: {\n          drive_id,\n          file_id,\n        },\n        contentType: 'json',\n      })\n\n      return data?.items || []\n    } catch (e) {\n    }\n  }\n\n  /**\n   * get download url\n   *\n   * @param {string} [file_id] file id\n   * @return {object}\n   *\n   * @api public\n   */\n  async get_download_url(file_id) {\n    let { drive_id, access_token } = await this.getConfig()\n    const { request } = this.app\n\n    try {\n      let { data } = await request.post(`${API_ENDPOINT}/v2/file/get_download_url`, {\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: {\n          drive_id,\n          file_id,\n        },\n        contentType: 'json',\n      })\n\n      const ret = { url: data?.cdn_url || data?.url, size: data.size, max_age: new Date(data.expiration).getTime() - Date.now() }\n      if (ret.url?.includes('x-oss-additional-headers=referer')) {\n        ret.proxy = {\n          headers: {\n            referer: REFERER,\n          },\n        }\n      }\n      return ret\n    } catch (e) {\n      return {}\n    }\n  }\n\n  /**\n   * create folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] folder name\n   * @param {object} [options] options\n   * @param {object} [options.check_name_mode] \n   * @return {object}\n   *\n   * @api public\n   */\n  async mkdir(parent_file_id, name, { check_name_mode = 'refuse' }) {\n    let { drive_id, access_token } = await this.getConfig()\n\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/adrive/v2/file/createWithFolders`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        drive_id,\n        parent_file_id,\n        name,\n        type: 'folder',\n        check_name_mode,\n      },\n      contentType: 'json',\n    })\n\n    if (data.error) return data.error\n\n    return {\n      id: data.file_id,\n      name,\n      parent_id: parent_file_id\n    }\n  }\n\n  /**\n   * rename file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] new name\n   * @return {object}\n   *\n   * @api public\n   */\n  async rename(file_id, name, { check_name_mode = 'refuse' } = {}) {\n    let { drive_id, access_token } = await this.getConfig()\n\n    let { data, status } = await this.app.request.post(`${API_ENDPOINT}/v3/file/update`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        drive_id,\n        file_id,\n        name,\n        check_name_mode,\n      },\n      contentType: 'json',\n    })\n\n    if (data.code) {\n      if (data.code === 'AlreadyExist.File') {\n        return this.app.error({ code: 409 })\n      } else {\n        return this.app.error(data)\n      }\n    }\n\n    return {\n      id: data.file_id,\n      name: data.name,\n      parent_id: data.parent_file_id\n    }\n  }\n\n  /**\n   * remove file/folder\n   *\n   * @param {string} [id] folder id\n   * @return {string}\n   *\n   * @api public\n   */\n  async rm(file_id) {\n    let { drive_id, access_token } = await this.getConfig()\n\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/v2/batch`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        \"requests\":\n          [{ \"body\": { drive_id, file_id }, \"headers\": { \"Content-Type\": \"application/json\" }, \"id\": file_id, \"method\": \"POST\", \"url\": \"/recyclebin/trash\" }],\n        \"resource\": \"file\"\n      }\n      ,\n      contentType: 'json',\n    })\n\n    if (data.code) {\n      return this.app.error(data)\n    }\n\n    return { id: file_id }\n  }\n\n\n  /**\n   * mv file/folder\n   *\n   * @param {string} [file_id] folder id\n   * @param {string} [target_id] folder id\n   * @return {string | error}\n   *\n   * @api public\n   */\n  async mv(file_id, target_id, options = {}) {\n    if (options.copy) {\n      throw { code: 501, message: \"Not implemented\" }\n    }\n\n    let { drive_id, access_token } = await this.getConfig()\n\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/v3/batch`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        \"requests\":\n          [\n            {\n              \"body\": { drive_id, file_id, to_drive_id: drive_id, to_parent_file_id: target_id },\n              \"headers\": { \"Content-Type\": \"application/json\" },\n              \"id\": file_id,\n              \"method\": \"POST\",\n              \"url\": \"/file/move\"\n            }],\n        \"resource\": \"file\"\n      }\n      ,\n      contentType: 'json',\n    })\n\n    if (data.code) {\n      return this.app.error(data)\n    }\n\n    if (options.name) {\n      await this.rename(file_id, options.name)\n    }\n\n    return { id: file_id }\n  }\n\n  /**\n   * upload file\n   *\n   * @param {string} [id] folder id\n   * @param {object} [options] upload file meta\n   * @param {ReadableStream} [options.stream] upload file stream\n   * @param {number} [options.size] upload file size\n   * @param {string} [options.name] upload file name\n   * @param {string} [options.sha1] file sha1 hash\n   * @param {string} [options.taskId] task id\n   * @return {object}\n   *\n   * @api public\n   */\n  async upload(id, stream, { size, name, uploadId, conflictBehavior, ...rest }) {\n    const { app } = this\n\n    let res = await this.beforeUpload(uploadId, { id, name, size, ...rest })\n\n    let { file_id, upload_id, file_name, rapid_upload, start = 0 } = res\n\n    uploadId = upload_id + '-' + file_id + '-1'\n\n    if (rapid_upload) {\n      return {\n        id: file_id,\n        name: file_name,\n        parent_id: id,\n        completed: true,\n      }\n    }\n\n    if (!stream) {\n      return { uploadId, start }\n    }\n\n\n    let readStream = (typeof stream == 'function') ? await stream(start, { uploadId }) : stream\n\n    let uploadParts = res.part_info_list\n    let passStream = app.streamReader(readStream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\n    for (let part of uploadParts) {\n      let uploadUrl = part.upload_url\n      rest.setState?.({ uploadId: upload_id + '-' + file_id + '-' + part.part_number })\n\n      let chunk = await passStream.read(UPLOAD_PART_SIZE)\n      let headers = {\n        'Referer': REFERER,\n        'Origin': 'https://www.aliyundrive.com',\n        'User-Agent': DEFAULT_UA,\n        'Content-Type': ''\n      }\n\n      headers['Content-Length'] = chunk.length\n\n      let res = await app.request(uploadUrl, {\n        method: 'put',\n        data: chunk,\n        contentType: 'buffer',\n        responseType: 'text',\n        headers\n      })\n      if (res.status != 200) {\n        let message = res.data.match(/<Code>([\\w\\W]+?)<\\/Code>/)?.[1] || 'unknown'\n        return this.app.error({ message: 'An error occurred during upload: ' + message })\n      }\n    }\n\n    await this.afterUpload(file_id, upload_id)\n\n    return { id: file_id, name: file_name, parent_id: id }\n\n  }\n\n  async haveSameFile(parent_id, name, size) {\n    try {\n      let files = this.list(parent_id, {})\n      return files.find(i => i.name === name && i.size === size)\n    } catch (e) {\n\n    }\n    return false\n  }\n\n  async beforeUpload(uploadId, { id, name, size, conflictBehavior, hash, ...rest } = { conflictBehavior: 1 }) {\n    let { drive_id, access_token } = await this.getConfig()\n    //resume upload progress\n    let partCount = Math.ceil(size / UPLOAD_PART_SIZE)\n\n    if (uploadId) {\n      let [taskId, fileId, partNumber] = uploadId.split('-')\n      partNumber = partNumber ? +partNumber : 1\n\n      const partList = new Array(partCount - partNumber + 1).fill(0).map((i, idx) => ({ part_number: idx + partNumber }))\n\n      let { data } = await this.app.request.post(`${API_ENDPOINT}/v2/file/get_upload_url`, {\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: {\n          drive_id,\n          upload_id: taskId,\n          file_id: fileId,\n          part_info_list: partList\n        },\n        signal: rest.signal,\n        contentType: 'json',\n      })\n\n      if (data) {\n        data.start = (partNumber - 1) * UPLOAD_PART_SIZE\n        return data\n      }\n    }\n\n    const partList = new Array(Math.ceil(size / UPLOAD_PART_SIZE)).fill(0).map((i, idx) => ({ part_number: idx + 1 }))\n\n    const checkNameMap = {\n      0: 'fail',\n      1: 'auto_rename',\n      2: 'overwrite'\n    }\n    let params = {\n      parent_file_id: id,\n      drive_id,\n      name,\n      size,\n      type: \"file\",\n      check_name_mode: checkNameMap[conflictBehavior],\n      part_info_list: partList,\n    }\n\n    if (hash?.sha1) {\n      params.pre_hash = hash.sha1.toUpperCase()\n    }\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/adrive/v2/file/createWithFolders`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: params,\n      contentType: 'json',\n    })\n    if (data.code) {\n      return this.app.error(data)\n    }\n\n    return data\n  }\n\n  async afterUpload(file_id, upload_id) {\n    let { drive_id, access_token } = await this.getConfig()\n\n    const {\n      request,\n    } = this.app\n    let { data } = await request.post(`${API_ENDPOINT}/v2/file/complete`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        drive_id,\n        upload_id,\n        file_id\n      },\n      contentType: 'json',\n    })\n\n    if (data.code) {\n      return this.app.error(data)\n    }\n\n    return data\n  }\n\n  async video_preview(id) {\n    let { drive_id, access_token } = await this.getConfig()\n\n    const {\n      request,\n      utils: { videoQuality },\n    } = this.app\n\n    let data = []\n    try {\n      let res = await request.post(`${API_ENDPOINT}/v2/file/get_video_preview_play_info`, {\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: {\n          category: 'live_transcoding',\n          drive_id,\n          file_id: id,\n          template_id: '',\n        },\n        contentType: 'json',\n      })\n\n      data = res.data\n    } catch (e) {\n    }\n\n    return data.video_preview_play_info.live_transcoding_task_list\n      .filter((i) => !!i.url)\n      .map((i) => ({ size: videoQuality(i.template_id), type: 'video/mp4', quality: i.template_id, src: i.url }))\n  }\n\n}\n\nmodule.exports = { driver: Driver }"},{"hash":"f9ab86ca86fc7efabd4ad450244211cb","name":"BaiduNetDisk","namespace":"sharelist.plugin.baidu","version":"1.0.0","license":"MIT","description":"Baidu Net Disk","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/baidu/index.js","icon":"https://nd-static.bdstatic.com/m-static/wp-brand/favicon.ico","script":"//===Sharelist===\n// @name         BaiduNetDisk\n// @namespace    sharelist.plugin.baidu\n// @version      1.0.0\n// @license      MIT\n// @description  Baidu Net Disk\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/baidu/index.js\n// @icon         https://nd-static.bdstatic.com/m-static/wp-brand/favicon.ico\n//===/Sharelist==\n\n// doc: https://pan.baidu.com/union/document/basic#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8\n\nconst crypto = require('crypto')\n\nconst md5 = (v) => crypto.createHash('md5').update(v).digest('hex')\n\nconst API = 'https://pan.baidu.com/rest/2.0/xpan'\n\nconst UPLOAD_API = 'https://d.pcs.baidu.com/rest/2.0/pcs/superfile2?method=upload'\n\nconst ERR_CODE = {\n  0: '请求成功',\n  2: '参数错误',\n  '-6': '身份验证失败, access_token 是否有效? 部分接口需要申请对应的网盘权限',\n  '-7': '文件或目录名错误或无权访问',\n  '-8': '件或目录已存在',\n  '-9': '文件或目录不存在',\n  '-10': '云端容量已满',\n  '10': '创建文件的superfile失败',\n  '31024': '没有申请上传权限',\n  '31299': '第一个分片的大小小于4MB',\n  '31364': '超出分片大小限制',\n  31034: '命中接口频控',\n  42000: '访问过于频繁',\n  42211: '图片详细信息查询失败',\n  42212: '共享目录文件上传者信息查询失败',\n  42213: '共享目录鉴权失败',\n  42214: '文件基础信息查询失败',\n}\n\n/*\n  0 为不重命名，返回冲突\n  1 为只要path冲突即重命名\n  2 为path冲突且block_list不同才重命名\n  3 为覆盖 \n*/\nconst RTYPE = {\n  0: 0,\n  1: 1,\n  2: 3\n}\n\n\nconst DEFAULT_ROOT_ID = 'root'\n\nconst fakeMD5 = () => md5(`${Date.now()}.${Math.random()}`)\nconst encodePath = v => Buffer.from(encodeURIComponent(v)).toString('base64')\n\nconst decodePath = v => decodeURIComponent(Buffer.from(v, 'base64').toString('utf-8'))\n\nconst prestream = (readStream, size) => new Promise((resolve, reject) => {\n  let buffer = [], count = 0\n\n  const onEnd = () => {\n    let head = Buffer.concat(buffer, count)\n    let hash = md5(head.subarray(0, size))\n    readStream.destroy()\n    resolve(hash)\n  }\n\n  readStream.on('data', (chunk) => {\n    buffer.push(chunk)\n    count += chunk.length\n    if (count >= size) {\n      readStream.pause()\n      onEnd()\n    }\n  })\n})\n/**\n * auth manager class\n */\nclass Manager {\n  static getInstance(app, config) {\n    if (!this.instance) {\n      this.instance = new Manager(app)\n    }\n\n    return this.instance.createGetter(config)\n  }\n\n  constructor(app) {\n    this.app = app\n    this.keyMaps = {}\n  }\n\n  createGetter(config) {\n    //May be public client_id\n    let [basePart] = config.client_id.split('.')\n    if (this.keyMaps[config.client_id]) {\n      config.client_id = basePart + '.' + ('' + Math.random()).substring(2)\n    }\n    this.keyMaps[basePart] = 1\n    return async () => {\n      if (\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\n      ) {\n        await this.refreshAccessToken(config)\n      }\n      return {\n        ...config,\n        client_id: basePart\n      }\n    }\n  }\n\n  /**\n   * 刷新令牌 / refresh token\n   *\n   * @param {object} credentials\n   * @param {object} { credentials: object } | { error:true, message:string }\n   * @api private\n   */\n  async refreshAccessToken(credentials) {\n    let { client_id, client_secret, redirect_uri, refresh_token, ...rest } = credentials\n\n    if (!(client_id && client_secret && refresh_token)) {\n      return this.app.error({ message: 'Invalid parameters: An error occurred during refresh access token' })\n    }\n\n    let formdata = {\n      client_id: client_id.split('.')[0],\n      client_secret,\n      // redirect_uri,\n      refresh_token,\n      grant_type: 'refresh_token',\n    }\n\n    let { data } = await this.app.request.get(`https://openapi.baidu.com/oauth/2.0/token`, { data: formdata })\n\n    if (data.error) return this.app.error({ message: data.error_description || data.error })\n\n    // expires_in 30 days\n    let expires_at = data.expires_in * 1000 + Date.now()\n\n    credentials.access_token = data.access_token\n    credentials.refresh_token = data.refresh_token\n    credentials.expires_at = expires_at\n\n    // update meta\n    let { data: res } = await this.app.request.get(`${API}/nas?method=uinfo?access_token=${credentials.refresh_token}`)\n\n    if (!res.errno) {\n      credentials.vipType = data.vip_type\n    }\n\n  }\n\n}\n\n// const getRealId = v => [v.split('/').pop().replace('@f', ''), v.endsWith('@f'), v.split('/').slice(0, -1).join('/')]\n\nconst getRealId = v => [v.split('/').pop().replace('~', ''), v.includes('~'), v.split('/').slice(0, -1).join('/')]\n\nconst fullpath = (basepath, subpath) => {\n  return (basepath == '/' ? '' : basepath) + '/' + subpath\n}\n\nclass Driver {\n  static options = {\n    protocol: \"baidu\",\n\n    //支持全局搜索\n    globalSearch: true,\n    localSearch: false,\n\n    key: 'client_id',\n    defaultRoot: DEFAULT_ROOT_ID,\n\n    hash: 'md5',\n    uploadHash: 'md5_256k',\n\n    guide: [\n      { key: 'client_id', label: '应用ID / AppKey', type: 'string', required: true },\n      { key: 'client_secret', label: '应用机密 / SecretKey', type: 'string', required: true },\n      { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\n      { key: 'refresh_token', label: '刷新令牌 / Refresh Token', type: 'string', required: true },\n      { key: 'root_id', label: '初始文件夹ID', help: '', type: 'string', required: false },\n      { key: 'access_token', label: '令牌', help: '', type: 'hidden', required: false },\n      { key: 'expires_at', label: '有效期', help: '', type: 'hidden', required: false },\n    ]\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.getConfig = Manager.getInstance(app, config)\n  }\n  /*\n  async getOptions() {\n    let { vipType } = await this.getConfig()\n    // 会员类型，0普通用户、1普通会员、2超级会员\n    let chunkSize = (['4', '16', '32'])[vipType || 0]\n    return {\n      'uploadHash': `md5_256k_${chunkSize}m`\n    }\n  }\n*/\n  /**\n   * Lists or search files\n   *\n   * @param {string} [id] folder id  e.g. baidu://{key}/{id}?query\n   * @param {object} [options] list options\n   * @param {object} [options.sort] sort methods\n   * @param {object} [options.search] search key\n   * @return {object | error}\n   *\n   * @api public\n   */\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\n\n    let [fid, isFile] = getRealId(id)\n\n    if (isFile) {\n      return []\n    }\n\n    let usePagination = !!perPage\n\n    const { request } = this.app\n\n    let { access_token } = await this.getConfig()\n\n    let data = await this.meta(fid)\n    let dir = data.extra.path || '/'\n    if (data.type != 'folder') return []\n\n    // perPage 1000 ~ 10000\n    let start = nextPage || 0, limit = perPage || 1000, files = []\n\n    do {\n      let { data } = await request(`${API}/file`, {\n        data: {\n          method: 'list',\n          access_token,\n          dir,\n          web: 'web',\n          start,\n          limit\n        },\n        contentType: 'json',\n      })\n      if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n      data.list.forEach((i) => {\n        let item = {\n          id: id + '/' + (i.isdir ? '' : '~') + i.fs_id,\n          name: i.server_filename,\n          type: i.isdir ? 'folder' : 'file',\n          size: parseInt(i.size),\n          ctime: i.server_ctime * 1000,\n          mtime: i.server_mtime * 1000,\n          thumb: i.thumbs ? i.thumbs.url2 : '',\n          extra: {\n            fid: id + '/' + (i.isdir ? '' : '~') + i.fs_id,\n            parent_id: id,\n            path: i.path,\n            md5: i.md5,\n          },\n        }\n\n        files.push(item)\n      })\n\n      if (limit <= data.list.length) {\n        start += limit\n      } else {\n        start = null\n        break\n      }\n    } while (!usePagination && start)\n\n    let result = {\n      id, files\n    }\n\n    if (usePagination && start) {\n      result.nextPage = start\n    }\n\n    return result\n  }\n\n  /**\n  * get file\n  *\n  * @param {string} [id] id\n  * @param {string} [key] key\n  * @return {object}\n  *\n  * @api public\n  */\n  async get(id) {\n    let [fid, isFile, parentId] = getRealId(id)\n\n    let result = await this.meta(fid)\n\n    if (result.type == 'file') {\n      let { access_token } = await this.getConfig()\n      // file.dlink 8 小时有效\n      let { headers } = await this.app.request(`${result.extra.dlink}&access_token=${access_token}`, {\n        followRedirect: false,\n        headers: {\n          'user-agent': 'pan.baidu.com',\n        },\n      })\n\n      //http://xxxx.baidupcs.com/file  expires: 8h\n      if (headers.location) {\n        result.download_url = headers.location\n        result.max_age = 8 * 3600 * 1000 - 60 * 1000\n      }\n    }\n\n    if (result.download_url) {\n      // 50M 以上，直接下载包 sign error, 使用中转\n      if (result.size >= 50 * 1024 * 1024) {\n        result.extra.proxy = {\n          headers: {\n            'user-agent': 'pan.baidu.com',\n            'referer': 'https://pan.baidu.com'\n          },\n        }\n      }\n    }\n\n    result.extra.parent_id = parentId\n\n    return result\n  }\n\n  /**\n   * \n   */\n  async meta(id) {\n    if (!id || id === DEFAULT_ROOT_ID) {\n      return {\n        id,\n        type: 'folder',\n        extra: {\n          path: '/'\n        }\n      }\n    }\n\n    const { request } = this.app\n\n    let { access_token } = await this.getConfig()\n\n    let { data } = await request(`${API}/multimedia`, {\n      data: {\n        method: 'filemetas',\n        access_token,\n        fsids: `[${id}]`,\n        dlink: 1,\n      },\n    })\n\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    let file = data.list[0]\n    let result = {\n      id,\n      name: file.filename,\n      type: file.isdir ? 'folder' : 'file',\n      size: parseInt(file.size),\n      ctime: file.server_ctime * 1000,\n      mtime: file.server_mtime * 1000,\n      thumb: file.thumbs ? file.thumbs.url2 : '',\n      extra: {\n        fid: file.fs_id,\n        path: file.path,\n        md5: file.md5,\n        dlink: file.dlink\n      },\n    }\n\n    return result\n  }\n  /**\n   * create folder\n   *\n   * @param {string} [parent_id] folder id\n   * @param {string} [name] folder name\n   * @param {object} [options] options\n   * @param {object} [options.check_name_mode] \n   * @return {object}\n   *\n   * @api public\n   */\n  async mkdir(parent_id, name, { check_name_mode = 'refuse' }) {\n    let [id, isFile] = getRealId(parent_id)\n\n    let filedata = await this.meta(id)\n\n    let { access_token } = await this.getConfig()\n    let { data } = await this.app.request.post(`${API}/file?method=create&access_token=${access_token}`, {\n      data: {\n        isdir: 1,\n        size: 0,\n        path: fullpath(filedata.extra.path, name)\n      },\n      contentType: 'form',\n    })\n\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    return {\n      id: (parent_id ? `${parent_id}/` : '') + data.fs_id,\n      name: data.server_filename,\n      parent_id\n    }\n  }\n\n\n  /**\n   * rename file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] new name\n   * @return {object}\n   *\n   * @api public\n   */\n  async rename(id, name, { check_name_mode = 'refuse' } = {}) {\n\n    let [fid, isFile, parent_id] = getRealId(id)\n\n    let filedata = await this.meta(fid)\n\n    let { access_token } = await this.getConfig()\n    let { data } = await this.app.request.post(`${API}/file?method=filemanager&access_token=${access_token}&opera=rename`, {\n      data: {\n        async: 0,\n        filelist: [{ path: filedata.extra.path, newname: name }],\n        ondup: 'fail'\n      },\n      contentType: 'form',\n    })\n\n    // console.log(data, {\n    //   async: 0,\n    //   filelist: JSON.stringify([{ path: filedata.extra.path, newname: name }]),\n    // })\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    return {\n      id: id,\n      name: name,\n      parent_id\n    }\n  }\n\n  /**\n   * rm file/folder\n   *\n   * @param {string} [id] folder id\n   * @return {object}\n   *\n   * @api public\n   */\n  async rm(id) {\n    let [fid, isFile, parent_id] = getRealId(id)\n\n    let filedata = await this.meta(fid)\n\n    let { access_token } = await this.getConfig()\n    let { data } = await this.app.request.post(`${API}/file?method=filemanager&access_token=${access_token}&opera=delete`, {\n      data: {\n        filelist: [filedata.extra.path],\n      },\n      contentType: 'form',\n    })\n\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    return { id, name: filedata.name, parent_id }\n  }\n\n  /**\n   * mv file/folder\n   *\n   * @param {string} [id] file/folder id\n   * @param {string} [target_id] folder id\n   * @return {string | error}\n   *\n   * @api public\n   */\n  async mv(id, target_id) {\n    let [fid, isFile, parent_id] = getRealId(id)\n\n    let [target_fid] = getRealId(target_id)\n\n    let { access_token } = await this.getConfig()\n\n    let filedata = await this.meta(fid)\n\n    let targetData = await this.meta(target_fid)\n\n    let { data } = await this.app.request.post(`${API}/file?method=filemanager&access_token=${access_token}&opera=move`, {\n      data: {\n        filelist: [{ path: filedata.extra.path, dest: targetData.extra.path }],\n      },\n      contentType: 'form',\n    })\n\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    let newId = target_id + '/' + id.split('/').pop()\n\n    return { id: newId, parent_id }\n  }\n\n  async beforeUpload(taskId, { id, name, size, rtype, hash, filepath, UPLOAD_PART_SIZE }) {\n    let { access_token } = await this.getConfig()\n    let { app } = this\n\n    // baidu pan 没有进度查询接口,直接计算未上传部分\n    if (taskId) {\n      let [uploadId, path, partStart, partSize] = taskId.split('|')\n      partSize = parseInt(partSize)\n      let len = Math.ceil(size / partSize)\n      let partsList = new Array(len - partStart).fill(0).map((i, idx) => idx + parseInt(partStart))\n      console.log(uploadId, partsList, partSize)\n      return { uploadId, partsList, path: decodePath(path), partSize }\n    }\n\n    let { md5, head, parts } = hash\n\n    //实测不会 合并分片时 不会校验切片MD5\n    if (!parts?.length) {\n      parts = new Array(Math.ceil(size / UPLOAD_PART_SIZE)).fill(md5 || fakeMD5())\n    }\n\n    const params = {\n      path: filepath,\n      size,\n      isdir: 0,\n      autoinit: 1,\n      rtype,\n\n      block_list: parts,\n    }\n    if (head) {\n      params['slice-md5'] = head\n    }\n    if (md5) {\n      params['content-md5'] = md5\n    }\n    console.log('params', params)\n    let { data } = await app.request.post(`${API}/file?method=precreate&access_token=${access_token}`, {\n      data: params,\n      contentType: 'form',\n    })\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    if (!data.path) data.path = filepath\n\n    return { ...data, uploadId: data.uploadid, partsList: data.block_list }\n\n  }\n\n  async afterUpload({ uploadId, path, rtype, size, hash, partsMD5 }) {\n    let { access_token } = await this.getConfig()\n\n    let { data } = await this.app.request.post(`${API}/file?method=create&access_token=${access_token}`, {\n      data: {\n        path,\n        size,\n        rtype,\n        isdir: 0,\n        uploadid: uploadId,\n        block_list: partsMD5\n      },\n      contentType: 'form',\n    })\n\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\n\n    return data\n  }\n\n  async upload(id, stream, { size, name, manual, conflictBehavior, hash, hash_type, state, ...rest }) {\n    const app = this.app\n\n    let [fid, isFile, parent_id] = getRealId(id)\n\n    let filedata = await this.meta(fid)\n\n    let filepath = fullpath(filedata.extra.path, name)\n\n    let { access_token, vipType } = await this.getConfig()\n\n    let UPLOAD_PART_SIZE = (vipType == 0 ? 4 : vipType == 1 ? 16 : vipType == 2 ? 32 : 4) * 1024 * 1024\n\n    let rtype = RTYPE[conflictBehavior] || 1\n\n    // 仅当存在md5 时，获取 slice-content hash 用于快速校验\n    if (!hash.head && hash.md5) {\n      hash.head = await prestream((typeof stream == 'function') ? await stream(0) : stream, 256 * 1024)\n    }\n\n    let { uploadId, partsList, path, info, return_type, partSize } = await this.beforeUpload(state?.uploadId, { id, name, size, hash, hash_type, rtype, filepath, UPLOAD_PART_SIZE })\n    //上传期间用户会员等级发生变化，当从高级降到普通时，分片大小将无法兼容\n    if (partSize) {\n      if (partSize <= UPLOAD_PART_SIZE) {\n        UPLOAD_PART_SIZE = partSize\n      } else {\n        return this.app.error({ message: ERR_CODE['31364'] })\n      }\n    }\n\n    let pathId = encodePath(path)\n\n    // file exists\n    if (return_type == 2) {\n      return {\n        id: (parent_id ? `${parent_id}/` : '') + info.fs_id,\n        name: name,\n        parent_id,\n        completed: true,\n      }\n    }\n\n    let start = partsList[0] * UPLOAD_PART_SIZE\n\n    if (!stream) {\n      return { uploadId: [uploadId, pathId, partsList[0], UPLOAD_PART_SIZE].join('|'), start }\n    }\n\n    let readStream = (typeof stream == 'function') ? await stream(start) : stream\n\n    let passStream = app.streamReader(readStream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\n\n    let partsMD5 = (state?.partsMD5 || [])\n\n    for (let part of partsList) {\n      rest.setState?.({ uploadId: [uploadId, pathId, part, UPLOAD_PART_SIZE].join('|'), partsMD5 })\n\n      let partUploadUrl = UPLOAD_API + `&access_token=${access_token}&type=tmpfile&path=${encodeURIComponent(path)}&uploadid=${uploadId}&partseq=${part}`\n\n      let chunk = await passStream.read(UPLOAD_PART_SIZE)\n\n      let res\n\n      let retryTimes = 3\n\n      while (retryTimes-- > 0) {\n        res = await app.request(partUploadUrl, {\n          // TODO 文档要求使用POST，会触发 { error_code: 31208, error_msg: 'content_type error' } \n          // 实测应为 PUT !\n          method: 'put',\n          data: chunk,\n          contentType: 'buffer',\n          signal: rest.signal,\n        })\n        if (res.data.errno) {\n          await sleep(app.utils.retryTime(3 - retryTimes))\n          continue\n        } else {\n          partsMD5.push(res.data.md5)\n          break\n        }\n      }\n      // console.log(res.data)\n      if (res.data.errno) return this.app.error({ message: ERR_CODE[res.data.errno] })\n    }\n\n    let res = await this.afterUpload({ uploadId, path, rtype, size, partsMD5, uploadId, hash })\n\n    return {\n      id: (parent_id ? `${parent_id}/` : '') + res.fs_id,\n      name: res.server_filename || name,\n      parent_id\n    }\n  }\n\n}\n\nmodule.exports = { driver: Driver }\n"},{"hash":"241400b5875bfa5722af6a20ba4cf8ec","name":"CMCCCloud","namespace":"sharelist.plugin.cmcc","version":"1.0.0","license":"MIT","description":"移动云盘","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/cmcc/index.js","script":"//===Sharelist===\n// @name         CMCCCloud\n// @namespace    sharelist.plugin.cmcc\n// @version      1.0.0\n// @license      MIT\n// @description  移动云盘\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/cmcc/index.js\n//===/Sharelist==\n\n\n/**\n * 1. taskType: 1 copy,2 remove,3 move\n */\nconst crypto = require('crypto')\n\nconst DEFAULT_ROOT_ID = '00019700101000000001'\n\nconst UPLOAD_PART_SIZE = 10 * 1024 * 1024\n\nconst sleep = (time) => new Promise((resolve) => setTimeout(resolve, time))\n\nconst md5 = (v) => {\n  return crypto.createHash('md5').update(v).digest('hex')\n}\n\nconst getRandomSring = (e) => {\n  let n = ''\n  for (let t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', a = 0; a < e; a++) {\n    let o = Math.floor(Math.random() * t.length)\n    n += t.substring(o, o + 1)\n  }\n  return n\n}\n\n\n//base64 encode\nconst btoa = (v) => Buffer.from(v).toString('base64')\n\nconst utob = (str) => {\n  const u = String.fromCharCode\n  return str.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g, (t) => {\n    if (t.length < 2) {\n      var e = t.charCodeAt(0);\n      return e < 128 ? t : e < 2048 ? u(192 | e >>> 6) + u(128 | 63 & e) : u(224 | e >>> 12 & 15) + u(128 | e >>> 6 & 63) + u(128 | 63 & e)\n    }\n    e = 65536 + 1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320);\n    return u(240 | e >>> 18 & 7) + u(128 | e >>> 12 & 63) + u(128 | e >>> 6 & 63) + u(128 | 63 & e)\n  })\n}\n\nconst unicode = (s) => s.split('').map((c) => ('\\\\u' + ('0000' + c.charCodeAt(0).toString(16).toUpperCase()).slice(-4))).join('')\n\nconst getNewSign = (e, t, a, n) => {\n  let i = \"\";\n  if (t) {\n    let s = Object.assign({}, t);\n    i = JSON.stringify(s),\n      i = i.replace(/\\s*/g, \"\"),\n      i = encodeURIComponent(i);\n    let c = i.split(\"\"),\n      u = c.sort();\n    i = u.join(\"\")\n  }\n  let A = md5(btoa(utob(i))),\n    l = md5(a + \":\" + n);\n  return md5(A + l).toUpperCase()\n}\n\nconst datetimeFormat = (d) =>\n  d ? d.replace(/(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/, '$1-$2-$3 $4:$5:$6+08:00') : ''\n\nconst moment = (a, expr = 'yyyy-MM-dd hh:mm:ss') => {\n  let y = a.getFullYear(),\n    M = a.getMonth() + 1,\n    d = a.getDate(),\n    D = a.getDay(),\n    h = a.getHours(),\n    m = a.getMinutes(),\n    s = a.getSeconds(),\n    w = a.getDay()\n\n  const zeroize = v => `${v > 9 ? '' : '0'}${v}`\n\n  return expr.replace(/(?:s{1,2}|w{1,2}|m{1,2}|h{1,2}|d{1,2}|M{1,4}|y{1,4})/g, function (str) {\n\n    switch (str) {\n      case 's':\n        return s;\n      case 'ss':\n        return zeroize(s);\n      case 'm':\n        return m;\n      case 'mm':\n        return zeroize(m);\n      case 'h':\n        return h;\n      case 'hh':\n        return zeroize(h);\n      case 'd':\n        return d;\n      case 'w':\n        return w;\n      case 'ww':\n        return w == 0 ? 7 : w;\n      case 'dd':\n        return zeroize(d);\n      case 'M':\n        return M;\n      case 'MM':\n        return zeroize(M);\n      case 'MMMM':\n        return ['十二', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一'][m] + '月';\n      case 'yy':\n        return String(y).substr(2);\n      case 'yyyy':\n        return y;\n      default:\n        return str.substr(1, str.length - 2);\n    }\n  })\n}\n\nconst createHeaders = (body) => {\n  // let timestamp = Date.now()\n  // let key = getRandomSring(16)\n\n  let timestamp = moment(new Date())\n  let key = getRandomSring(16)\n  let sign = getNewSign(undefined, body, timestamp, key)\n\n  let headers = {\n    'x-huawei-channelSrc': '10000034',\n    'x-inner-ntwk': '2',\n    'mcloud-channel': '1000101',\n    'mcloud-client': '10701',\n    'mcloud-sign': timestamp + \",\" + key + \",\" + sign,\n    // 'mcloud-skey': null,\n\n    'content-type': \"application/json;charset=UTF-8\",\n    'caller': 'web',\n    'CMS-DEVICE': 'default',\n    'x-DeviceInfo': '||9|85.0.4183.83|chrome|85.0.4183.83|||windows 10||zh-CN|||',\n    'x-SvcType': '1',\n    'referer': 'https://yun.139.com/w/',\n\n  }\n\n  // let headers = {\n  //   caller: 'web',\n  //   'CMS-CLIENT': '0010101',\n  //   'CMS-DEVICE': 'default',\n  //   'CMS-SIGN': timestamp + ',' + key + ',' + getSign(undefined, body, timestamp),\n  //   'x-DeviceInfo': '||9|92.0.4515.107|chrome|92.0.4515.107|||windows 10||zh-CN|||',\n  //   Referer: 'https://yun.139.com/w/',\n  // }\n\n  return headers\n}\n\n/**\n * auth manager class\n */\n/**\n * auth manager class\n */\nclass Manager {\n  static getInstance(app, config) {\n    if (!this.instance) {\n      this.instance = new Manager(app)\n    }\n\n    // this.instance.add(config)\n    return this.instance.createGetter(config)\n  }\n\n  constructor(app) {\n    this.app = app\n  }\n\n  createGetter(config) {\n    return () => {\n      if (\n        config.mobile && config.token && config.account\n      ) {\n        return {\n          ...config,\n          cookie: `ORCHES-C-TOKEN=${config.token}; ORCHES-C-ACCOUNT=${config.account}; ORCHES-I-ACCOUNT-ENCRYPT=${btoa(config.mobile)}; `\n        }\n      }\n\n      throw { message: 'unmounted', code: 500 }\n    }\n  }\n}\n\nconst getRealId = v => [v.split('/').pop().replace('~', ''), v.includes('~'), v.split('/').slice(0, -1).join('/')]\n\nclass Driver {\n  static options = {\n    protocol: \"caiyun\",\n    //支持全局搜索\n    globalSearch: true,\n    localSearch: true,\n\n    uploadHash: 'md5',\n    hash: 'md5',\n    key: 'mobile',\n    defaultRoot: DEFAULT_ROOT_ID,\n\n    guide: [\n      { key: 'account', label: 'ORCHES-C-ACCOUNT', type: 'string', help: '登录官网从cookies中获取ORCHES系列参数', required: true },\n      { key: 'token', label: 'ORCHES-C-TOKEN', type: 'string', required: true },\n      { key: 'mobile', label: '手机号', type: 'string', required: true },\n      { key: 'root', label: '初始目录ID', type: 'string', required: false },\n    ]\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.getConfig = Manager.getInstance(app, config)\n  }\n\n  /**\n  * Lists or search files\n  *\n  * @param {string} [id] folder id\n  * @param {object} [options] list options\n  * @param {object} [options.sort] sort\n  * @param {object} [options.search] search\n  * @param {string} [key] key\n  * @return {array}\n  *\n  * @api public\n  */\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\n    let { cookie, mobile } = await this.getConfig()\n    let [fid, isFile] = getRealId(id)\n\n    if (isFile) {\n      return []\n    }\n\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n\n    let usePagination = !!perPage\n\n    let offset = nextPage || 0, size = perPage || 200, files = []\n\n    do {\n      let params = {\n        catalogID: fid,\n        sortDirection: 1,\n        filterType: 0,\n        catalogSortType: 0,\n        contentSortType: 0,\n        startNumber: offset + 1,\n        endNumber: offset + size,\n        commonAccountInfo: { account: mobile, accountType: 1 }\n      }\n\n      if (orderBy) {\n        let [sortKey, isAsc] = orderBy\n        params.catalogSortType = params.contentSortType = sortKey == 'name' ? '0' : sortKey == 'ctime' ? '1' : '0'\n        params.sortDirection = isAsc ? 1 : 0\n      }\n\n      let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/catalog/v1.0/getDisk', {\n        data: params,\n        headers: {\n          ...createHeaders(params),\n          cookie,\n        },\n        contentType: 'json',\n      })\n\n\n      if (!data.success) {\n        return this.app.error({ message: data.message })\n      }\n\n      if (data.data.result.resultCode != '0') this.app.error({ message: data.data.result.resultDesc })\n\n      data = data.data.getDiskResult\n\n      if (data?.catalogList) {\n        for (let i of data.catalogList) {\n          files.push({\n            id: id + '/' + i.catalogID,\n            name: i.catalogName,\n            type: 'folder',\n            size: i.size,\n            ctime: timestamp(datetimeFormat(i.createTime)),\n            mtime: timestamp(datetimeFormat(i.updateTime)),\n            extra: {\n              fid: id + '/' + i.catalogID,\n              parent_id: id,\n            },\n          })\n        }\n      }\n\n      if (data?.contentList) {\n        for (let i of data.contentList) {\n          files.push({\n            id: id + '/~' + i.contentID,\n            name: i.contentName,\n            type: 'file',\n            size: i.contentSize,\n            ctime: timestamp(datetimeFormat(i.uploadTime)),\n            mtime: timestamp(datetimeFormat(i.updateTime)),\n            thumb: i.thumbnailURL,\n            extra: {\n              fid: id + '/~' + i.contentID,\n              parent_id: id,\n              md5: i.digest,\n              // path: i.path,\n              preview_url: i.presentURL\n            },\n          })\n        }\n      }\n\n      if (offset + size < parseInt(data.nodeCount)) {\n        offset += size\n      } else {\n        offset = null\n        break\n      }\n    } while (!usePagination && offset)\n\n    let result = {\n      id, files\n    }\n\n    if (usePagination && offset) {\n      result.nextPage = offset\n    }\n\n    return result\n  }\n\n  // caiyun 没有获取文件详情的单独接口\n  // 缺少name !!\n  async get(id) {\n    let paths = id.split('/')\n    let [fid, isFile] = getRealId(id)\n\n    const data = {\n      id,\n      type: isFile ? 'file' : 'folder',\n      extra: {\n        fid: id,\n        parent_id: paths.slice(0, -1).join('/')\n      },\n    }\n\n    if (data.type == 'file') {\n      let { url, max_age } = await this.get_download_url(id)\n      data.download_url = url\n      data.max_age = max_age\n    }\n    return data\n  }\n\n  async get_download_url(id) {\n    let { cookie, mobile } = await this.getConfig()\n    let [fid, isFile] = getRealId(id)\n\n    const { request } = this.app\n\n    let params = {\n      appName: '',\n      contentID: fid,\n      commonAccountInfo: { account: mobile, accountType: 1 }\n    }\n\n    let headers = createHeaders(params)\n\n    try {\n\n      let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/uploadAndDownload/v1.0/downloadRequest', {\n        data: params,\n        headers: {\n          ...headers,\n          'User-Agent':\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n          cookie,\n\n        },\n        contentType: 'json',\n      })\n      if (data?.data?.downloadURL) return { url: data.data.downloadURL, max_age: 1 * 60000 }\n    } catch (e) {\n      return {}\n    }\n\n  }\n\n  async mkdir(parentId, name, { check_name_mode = 'refuse' }) {\n    const { request } = this.app\n    let { cookie, mobile } = await this.getConfig()\n    let [fid] = getRealId(parentId)\n\n    let params = {\n      createCatalogExtReq: {\n        parentCatalogID: fid,\n        newCatalogName: name,\n        commonAccountInfo: { account: mobile, accountType: 1 }\n      }\n    }\n\n    let headers = createHeaders(params)\n\n    let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/catalog/v1.0/createCatalogExt', {\n      data: params,\n      headers: {\n        ...headers,\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n        cookie,\n      },\n      contentType: 'json',\n    })\n\n    if (!data.success) return this.app.error({ message: data.message })\n\n    if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\n\n    let file_id = data.data.catalogInfo.catalogID\n\n    /*\n    parentCatalogId: \"0511YJIR62Bj00019700101000000043\"\n    path: \"00019700101000000001/0511YJIR62Bj00019700101000000043/0511YJIR62Bj06720210909171001rec\"\n    */\n    return {\n      id: parentId + '/' + file_id,\n      name,\n      parent_id: parentId\n    }\n  }\n\n  async rename(id, name, { check_name_mode = 'refuse' } = {}) {\n    const { request } = this.app\n\n    let { cookie, mobile } = await this.getConfig()\n\n    let [fid, isFile, parent_id] = getRealId(id)\n\n    let params = {\n      [isFile ? 'contentID' : 'catalogID']: fid,\n      [isFile ? 'contentName' : 'catalogName']: name,\n      commonAccountInfo: { \"account\": mobile, \"accountType\": 1 }\n    }\n\n    let headers = createHeaders(params)\n\n    let { data } = await request.post(`https://yun.139.com/orchestration/personalCloud/${isFile ? 'content' : 'catalog'}/v1.0/${isFile ? 'updateContentInfo' : 'updateCatalogInfo'}`, {\n      data: params,\n      headers: {\n        ...headers,\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n        cookie,\n      },\n      contentType: 'json',\n    })\n\n    if (!data.success) {\n      if (data.code == '1010010005') {\n        return this.app.error({ code: 404 })\n      }\n      return this.app.error({ message: data.message })\n    }\n\n    if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\n\n    return {\n      id,\n      name: data.data.updateContentInfoRes?.contentName || data.data.updateCatalogRes.catalogName,\n      parent_id\n    }\n\n  }\n\n  async rm(id) {\n    const { request } = this.app\n    const { cookie, mobile } = await this.getConfig()\n    let [fid, isFile, parent_id] = getRealId(id)\n    let params = {\n      \"createBatchOprTaskReq\": {\n        \"taskType\": 2,\n        \"actionType\": 201,\n        \"taskInfo\": {\n          \"newCatalogID\": \"\",\n          [isFile ? 'contentInfoList' : 'catalogInfoList']: [fid]\n        },\n        \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\n      }\n    }\n\n    let headers = createHeaders(params)\n\n    let { data, error } = await request.post('https://yun.139.com/orchestration/personalCloud/batchOprTask/v1.0/createBatchOprTask', {\n      data: params,\n      headers: {\n        ...headers,\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n        cookie,\n      },\n      contentType: 'json',\n    })\n    if (!data.success) return this.app.error({ message: data.message })\n    if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\n\n    let taskId = data.data.createBatchOprTaskRes.taskID\n\n    await this.monitor(taskId)\n\n    return { id, parent_id }\n  }\n\n  /**\n   * mv file/folder\n   *\n   * @param {string} [id] folder id\n   * @return {string | error}\n   *\n   * @api public\n   */\n  async mv(id, target_id, { name, copy }) {\n    const { request } = this.app\n    const { cookie, mobile } = await this.getConfig()\n    let [fid, isFile, origin_parent_id] = getRealId(id)\n    let [destFid] = getRealId(target_id)\n    let params = {\n      \"createBatchOprTaskReq\": {\n        \"taskType\": copy ? 1 : 3,\n        \"actionType\": copy ? '309' : '304',\n        \"taskInfo\": {\n          \"contentInfoList\": [],\n          \"catalogInfoList\": [],\n          \"newCatalogID\": destFid,\n          [isFile ? 'contentInfoList' : 'catalogInfoList']: [fid]\n        },\n        \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\n      }\n    }\n\n    let headers = createHeaders(params)\n\n    let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/batchOprTask/v1.0/createBatchOprTask', {\n      data: params,\n      headers: {\n        ...headers,\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n        cookie,\n      },\n      contentType: 'json',\n    })\n\n    if (!data.success) return this.app.error({ message: data.message })\n\n    if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\n\n    let taskId = data.data.createBatchOprTaskRes.taskID\n\n    let newData = await this.monitor(taskId)\n\n    if (newData) {\n      let newId = target_id + '/' + (isFile ? '~' : '') + newData.id\n      if (name) {\n        await this.rename(newId, name)\n      }\n      return { id: newId, origin_parent_id }\n    }\n\n    //不支持目的地存在相同文件，也不支持复制/移动时重命名。 \n    return this.app.error({ message: '', code: 501 })\n  }\n\n  async hashFile(fileId, { name, hash }) {\n    let res = await this.beforeUpload(fileId, {\n      name, size: 1, md5: hash\n    })\n\n    let fastSave = !res.redirectionUrl\n    if (fastSave) {\n      return {\n        id: fileId + '/~' + res.newContentIDList[0].contentID\n      }\n    } else {\n      return {}\n    }\n  }\n\n  async monitor(taskId, timeout = 5 * 1000) {\n    const { request } = this.app\n    const { cookie, mobile } = await this.getConfig()\n    let startTime = Date.now()\n\n    let params = {\n      \"queryBatchOprTaskDetailReq\": {\n        \"taskID\": taskId,\n        \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\n      }\n    }\n\n    while (Date.now() - startTime < timeout) {\n      let headers = createHeaders(params)\n\n      let { data, error } = await request.post('https://yun.139.com/orchestration/personalCloud/batchOprTask/v1.0/queryBatchOprTaskDetail', {\n        data: params,\n        headers: {\n          ...headers,\n          'User-Agent':\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n          cookie,\n        },\n        contentType: 'json',\n      })\n\n      if (data?.data?.queryBatchOprTaskDetailRes?.batchOprTask?.progress == 100) {\n        let taskType = data.data.queryBatchOprTaskDetailRes.batchOprTask.taskType\n        let destId, base = data.data.queryBatchOprTaskDetailRes\n\n        // copy get destId\n        if (taskType == 1) {\n          destId = base.contentList?.[0]?.rstId || base.catalogList?.[0]?.rstId\n        } else {\n          destId = base.contentList?.[0]?.srcId || base.catalogList?.[0]?.srcId\n        }\n        return { id: destId }\n      }\n\n      await sleep(500)\n    }\n\n  }\n\n  async resumeUpload({ uploadId, path, contentId }, retries = 2) {\n    const { cookie, mobile } = await this.getConfig()\n\n    let [taskId, path, contentId] = uploadId.split('-')\n    console.log('resumeUpload', taskId, path, contentId)\n    let params = {\n      \"account\": '',\n      \"taskList\": [{\n        \"contentID\": contentId,\n        \"path\": path,\n        \"taskID\": taskId\n      }],\n      \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\n    }\n\n    let { data } = await this.app.request.post('https://yun.139.com/orchestration/personalCloud/uploadAndDownload/v1.0/syncUploadTaskInfo', {\n      data: params,\n      headers: {\n        ...createHeaders(params),\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n        cookie,\n      },\n      contentType: 'json',\n    })\n\n    //签名校验失败\n    if (data.code == '1010010014' && retries > 0) {\n      return await resumeUpload(uploadId, retries--)\n    }\n    if (!data.success) {\n      return {\n        error: { message: '[' + data.data?.result.resultCode || 'unknow' + ']' + data.message }\n      }\n    }\n    //this.app.error({ message: '[' + data.data.result.resultCode + ']' + data.message })\n\n    // console.log('resume from', data.data.array[0].fileUploadInfos[0])\n    return {\n      start: +data.data.array[0].fileUploadInfos[0].pgs,\n      taskId,\n      contentId,\n      uploadUrl: data.data.array[0].uploadURL\n    }\n  }\n\n  async beforeUpload(id, { name, size, hash }) {\n    const { cookie, mobile } = await this.getConfig()\n    const [fid] = getRealId(id)\n\n    const params = {\n      \"manualRename\": 2,\n      \"operation\": 0,\n      \"fileCount\": 1,\n      \"totalSize\": size,\n      \"uploadContentList\": [{\n        \"contentName\": name,\n        \"contentSize\": size,\n        // \"digest\": \"\"\n      }],\n      \"parentCatalogID\": fid,\n      \"newCatalogName\": \"\",\n      \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\n    }\n\n    if (hash.md5) {\n      params.uploadContentList[0].digest = hash.md5\n    }\n    //console.log(params)\n\n    let headers = createHeaders(params)\n\n    let { data } = await this.app.request.post('https://yun.139.com/orchestration/personalCloud/uploadAndDownload/v1.0/pcUploadFileRequest', {\n      data: params,\n      headers: {\n        ...headers,\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\n        cookie,\n      },\n      contentType: 'json',\n    })\n\n    if (!data.success) return this.app.error({ message: data.message })\n\n    if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\n\n    let res = data.data.uploadResult\n\n    let completed = res.newContentIDList[0].isNeedUpload\n    return {\n      completed,\n      uploadUrl: res.redirectionUrl,\n      taskId: res.uploadTaskID,\n      contentId: res.newContentIDList[0].contentID\n    }\n  }\n\n  async upload(parent_id, stream, { size, name, manual, state, setState, ...rest }) {\n    const { app } = this\n    const [fid] = getRealId(parent_id)\n\n    let res = state.uploadId ?\n      await this.resumeUpload(state) :\n      await this.beforeUpload(parent_id, { name, size, ...rest })\n\n\n    //恢复状态发生错误，尝试重新创建\n    if (rest.uploadId && res.error) {\n      console.log('create new upload session', res.error)\n      res = await this.beforeUpload(parent_id, { name, size, ...rest })\n    }\n\n    let { uploadUrl, completed, taskId, contentId, start = 0 } = res\n\n    if (completed) {\n      return { id: parent_id + '/~' + contentId, name, parent_id, completed }\n    }\n\n    setState({ uploadId, path: fid, contentId })\n\n    let { status, data } = await app.request.post(uploadUrl, {\n      data: customStream || stream,\n      contentType: 'stream',\n      responseType: 'text',\n      signal: rest.signal,\n      highWaterMark: 1024 * 1024,\n      headers: {\n        'Accept': '*/*',\n        'Content-Type': `text/plain;name=${unicode(name)}`,\n        'contentSize': size,\n\n        'range': `bytes=${start}-${size - 1}`,\n        'content-length': size - start,\n\n        'uploadtaskID': taskId,\n        'rangeType': 0,\n        'Referer': 'https://yun.139.com/',\n        'x-SvcType': 1,\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'\n      }\n    })\n\n\n    if (status != 200) return this.app.error({ code: status })\n\n    return { id: parent_id + '/~' + contentId, name, parent_id }\n\n  }\n\n\n  // let passStream = app.streamReader(stream, { highWaterMark: 1.5 * UPLOAD_PART_SIZE })\n  // let part = Math.ceil(size / UPLOAD_PART_SIZE)\n  // let point = 0\n  // for (let i = 0; i < part; i++) {\n  //   let buffer = await passStream.read(UPLOAD_PART_SIZE)\n  //   let ret = await app.request.post(upload_url, {\n  //     data: buffer,\n  //     contentType: 'buffer',\n  //     responseType: 'text',\n  //     headers: {\n  //       'Accept': '*/*',\n  //       'Content-Type': `text/plain;name=${unicode(name)}`,\n  //       'contentSize': size,\n\n  //       'range': `bytes=${point}-${point + buffer.length - 1}`,\n  //       'content-length': buffer.length,\n\n  //       'uploadtaskID': taskId,\n  //       'rangeType': 0,\n  //       'Referer': 'https://yun.139.com/',\n  //       'x-SvcType': 1,\n  //       'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'\n  //     }\n  //   })\n  //   console.log(ret, '<<')\n  //   point += buffer.length\n  // }\n\n}\n\nmodule.exports = { driver: Driver }"},{"hash":"de7a0c66c596719f8693cd3a03dec968","name":"CTCCloud","namespace":"sharelist.plugin.ctc","version":"1.0.0","license":"MIT","description":"天翼云盘","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/ctc/index.js","icon":"https://cloud.189.cn/web/logo.ico","script":"//===Sharelist===\n// @name         CTCCloud\n// @namespace    sharelist.plugin.ctc\n// @version      1.0.0\n// @license      MIT\n// @description  天翼云盘\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/ctc/index.js\n// @icon         https://cloud.189.cn/web/logo.ico\n//===/Sharelist==\n\nconst API_ENDPOINT = 'https://cloud.189.cn'\n\nconst UPLOAD_PART_SIZE = 10 * 1024 * 1024\n\nconst DEFAULT_ROOT = '-11'\n\nconst crypto = require('crypto')\n\nconst NodeRSA = require('node-rsa')\n\nconst safeJSONParse = (data) =>\n  JSON.parse(\n    data.replace(/(?<=:\\s*)(\\d+)/g, ($0, $1) => {\n      if (!Number.isSafeInteger(+$1)) {\n        return `\"${$1}\"`\n      } else {\n        return $1\n      }\n    }),\n  )\n\nconst sleep = (time) => new Promise((resolve) => setTimeout(resolve, time))\n\nconst hmac = (v, key) => {\n  return crypto.createHmac('sha1', key).update(v).digest('hex')\n}\n\nconst md5 = (v) => crypto.createHash('md5').update(v).digest('hex')\n\nconst aesEncrypt = (data, key, iv = \"\") => {\n  let cipher = crypto.createCipheriv('aes-128-ecb', key, iv);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted\n}\n\nconst rsaEncrypt = (data, publicKey, charset = 'base64') => {\n  publicKey = '-----BEGIN PUBLIC KEY-----\\n' + publicKey + '\\n-----END PUBLIC KEY-----'\n\n  let key = new NodeRSA(publicKey, { encryptionScheme: 'pkcs1' })\n  return key.encrypt(data, charset)\n}\n\nconst uuid = (v) => {\n  return v.replace(/[xy]/g, (e) => {\n    var t = 16 * Math.random() | 0\n      , i = \"x\" === e ? t : 3 & t | 8;\n    return i.toString(16)\n  })\n}\n\nconst qs = d => Object.keys(d).map(i => `${i}=${encodeURI(d[i])}`).join('&')\n\nconst parseHeaders = v => {\n  let ret = {}\n  for (let pair of decodeURIComponent(v).split('&').map(i => i.split('='))) {\n    ret[pair[0].toLowerCase()] = pair.slice(1).join('=')\n  }\n  return ret\n}\n/**\n * auth manager class\n */\nclass Manager {\n  static getInstance(app, config) {\n    if (!this.instance) {\n      this.instance = new Manager(app)\n    }\n\n    // this.instance.add(config)\n    return this.instance.createGetter(config, app)\n  }\n\n  constructor(app) {\n    this.app = app\n  }\n\n  createGetter(config, app) {\n    let safeRequest = async (url, options, retry = 3) => {\n      let { data, status, headers } = await app.request(url, options)\n      if (JSON.stringify(data).includes('InvalidSessionKey')) {\n        if (retry > 0) {\n          await this.refreshCookie(config)\n          options.headers.cookie = config.cookie\n          return await safeRequest(url, options, --retry)\n        } else {\n          app.error({ message: 'Invalid Session Key' })\n        }\n      }\n\n      return { data, status, headers }\n    }\n    return async () => {\n      if (\n        !config.account ||\n        !config.cookie\n      ) {\n        await this.refreshCookie(config)\n      }\n      return {\n        ...config,\n        safeRequest\n      }\n    }\n  }\n\n  async needCaptcha(data, cookie) {\n    let resp = await this.app.request.post('https://open.e.189.cn/api/logbox/oauth2/needcaptcha.do', {\n      data,\n      headers: {\n        cookie: cookie,\n        referer: 'https://open.e.189.cn/api/logbox/oauth2/loginSubmit.do',\n      },\n      contentType: 'form',\n      responseType: 'text'\n    })\n\n    if (resp?.data == '1') {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  async getCaptcha(captchaToken, reqId, cookie) {\n    let resp = await this.app.request(\n      `https://open.e.189.cn/api/logbox/oauth2/picCaptcha.do?token=${captchaToken}&REQID=${reqId}&rnd=${Date.now()}`,\n      {\n        headers: {\n          cookie,\n          Referer: 'https://open.e.189.cn/api/logbox/oauth2/loginSubmit.do',\n        },\n        responseType: 'buffer',\n      },\n    )\n\n    if (resp.error) return { error: resp.error }\n\n    let imgBase64 =\n      'data:' + resp.headers['content-type'] + ';base64,' + Buffer.from(resp.data).toString('base64')\n\n    return await this.app.ocr(imgBase64)\n  }\n\n  async getSessionKey(cookie) {\n    let { data: baseData } = await this.app.request(`${API_ENDPOINT}/v2/getUserBriefInfo.action?noCache=${Math.random()}`, {\n      headers: {\n        cookie,\n        // accept: 'application/json;charset=UTF-8'\n      },\n      responseType: 'json'\n    })\n    return baseData.sessionKey\n  }\n\n  /**\n   * refreshCookie\n   *\n   * @param {object} {account , password}\n   * @param {boolean} force\n   * @return {object} { credentials | error }\n   * @api private\n   */\n  async refreshCookie(config) {\n    let { account, password, cookie_login_user } = config\n\n    const { request } = this.app\n\n    if (cookie_login_user) {\n      const cookie = `COOKIE_LOGIN_USER=${cookie_login_user};`\n      const sessionKey = await this.getSessionKey(cookie)\n\n      config.sessionKey = sessionKey\n      config.cookie = cookie\n\n      config.key = account\n      return\n    }\n\n    //0 准备工作： 获取必要数据\n    let defaultHeaders = {\n      'User-Agent':\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',\n    }\n    let { data, headers } = await request.get(\n      `${API_ENDPOINT}/api/portal/loginUrl.action?redirectURL=https://cloud.189.cn/web/redirect.html`,\n      {\n        headers: { ...defaultHeaders },\n        responseType: 'text',\n      },\n    )\n\n    let { data: data2 } = await request.post(`https://open.e.189.cn/api/logbox/config/encryptConf.do`, {\n      data: {\n        appId: 'cloud'\n      }\n    })\n    let { pubKey, pre, upSmsOn } = data2.data\n\n    let captchaToken = (data.match(/name='captchaToken' value='(.*?)'>/) || ['', ''])[1],\n      returnUrl = (data.match(/returnUrl = '(.*?)'\\,/) || ['', ''])[1],\n      paramId = (data.match(/var paramId = \"(.*?)\";/) || ['', ''])[1],\n      lt = (data.match(/var lt = \"(.*?)\";/) || ['', ''])[1],\n      reqId = (data.match(/reqId = \"(.*?)\";/) || ['', ''])[1]\n\n    // console.log(headers, pubKey)\n    let cookie = headers['set-cookie']\n\n    let formdata = {\n      appKey: 'cloud',\n      accountType: '01',\n      userName: `${pre}${rsaEncrypt(account, pubKey)}`,\n      password: `${pre}${rsaEncrypt(password, pubKey)}`,\n      userName: account,\n      password: password,\n      validateCode: '',\n      captchaToken: captchaToken,\n      returnUrl: returnUrl,\n      mailSuffix: '@189.cn',\n      dynamicCheck: 'FALSE',\n      clientType: '1',\n      cb_SaveName: '1',\n      isOauth2: 'false',\n      state: '',\n      paramId: paramId,\n    }\n    // console.log(pubKey, pre, formdata)\n    // return this.app.error({ message: 'haha' })\n    let retry = 3\n    let needcaptcha = await this.needCaptcha(\n      {\n        accountType: '01',\n        userName: account,\n        appKey: 'cloud',\n      },\n      cookie,\n    )\n\n    while (retry--) {\n      // 验证码\n      if (needcaptcha) {\n        let { error, code } = await this.getCaptcha(captchaToken, reqId, cookie)\n\n        if (error) return { error }\n\n        code = code.replace(/\\n/g, '')\n        if (code.length == 4) {\n          formdata.validateCode = code\n        } else {\n          continue\n        }\n\n      }\n\n      // 登陆\n      let { data } = await request.post('https://open.e.189.cn/api/logbox/oauth2/loginSubmit.do', {\n        headers: {\n          Referer: 'https://open.e.189.cn/api/logbox/oauth2/unifyAccountLogin.do',\n          reqid: reqId,\n          lt: lt,\n        },\n        data: formdata,\n        contentType: 'form',\n        responseType: 'json'\n      })\n\n      //验证码错误\n      if (data.result == -2) {\n        console.log('validateCode:[' + formdata.validateCode + '] error')\n        continue\n      }\n      if (!data.toUrl) return this.app.error({ message: data.msg })\n\n      let { headers } = await request.get(data.toUrl, {\n        followRedirect: false,\n        headers: {\n          ...defaultHeaders,\n          referer: 'https://open.e.189.cn/'\n        },\n        responseType: 'text',\n      })\n      //COOKIE_LOGIN_USER=xxxxx;\n      let loginUser = headers?.['set-cookie'].match(/COOKIE_LOGIN_USER=(?<token>[a-z\\d]+)/i)?.groups.token\n\n      if (!loginUser) return this.app.error({ message: 'login failed. Can not get cookies!' })\n\n      const loginCookie = `COOKIE_LOGIN_USER=${loginUser};`\n      const sessionKey = await this.getSessionKey(loginCookie)\n\n      config.cookie = loginCookie\n      config.sessionKey = sessionKey\n      config.updated_at = Date.now()\n\n      config.key = account\n\n      return\n    }\n\n    return this.app.error({ message: `Login failed` })\n  }\n}\n\nclass Driver {\n  static options = {\n    protocol: \"ctc\",\n\n    //支持全局搜索\n    globalSearch: true,\n    localSearch: true,\n\n    hash: 'md5',\n    uploadHash: 'md5_chunk',\n    key: 'client_id',\n    defaultRoot: DEFAULT_ROOT,\n\n    guide: [\n      {\n        key: 'type',\n        label: '类型 / Type',\n        type: 'string',\n        required: true,\n        options: [\n          { value: '1', label: '个人版' },\n          // { value: '2', label: '家庭版' },\n          // { value: '3', label: '企业版' }\n        ],\n      },\n      { key: 'account', label: '手机号 / Account', type: 'string', required: true },\n      { key: 'password', label: '密码 / Password', type: 'string', required: true },\n      { key: 'cookie_login_user', label: 'COOKIE_LOGIN_USER', type: 'string', required: false, help: 'Cookies 中的COOKIE_LOGIN_USER字段，若提供此项则优先使用Cookies登录。' },\n      {\n        key: 'root',\n        label: '初始文件夹ID / Root Id',\n        help: 'https://cloud.189.cn/web/main/file/folder/xxxx 地址中 xxxx 的部分',\n        type: 'string',\n      },\n    ]\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.getConfig = Manager.getInstance(app, config)\n  }\n\n  /**\n   * 列出目录\n   *\n   * @param {string} [id] 文件(目录)id 唯一值\n   * \n   * @param {object} [options] 参数\n   * @param {object} [options.order_by] 排序\n   * @param {object} [options.page] 页码\n   * @param {object} [options.per_page] 每页条目数\n   * @param {object} [options.search] 搜索内容\n   * \n   * @return {object}\n   *\n   * @api public {Array<file>}\n   *\n   */\n  async list(id, { search, local_search, orderBy, perPage, nextPage } = {}) {\n    const {\n      utils: { timestamp },\n    } = this.app\n\n    let { cookie, safeRequest } = await this.getConfig()\n\n    let usePagination = !!perPage\n\n    const files = []\n\n    let isSearch = !!search\n\n    nextPage = nextPage || 1\n\n    let url = `${API_ENDPOINT}/api/open/file/${isSearch ? 'searchFiles' : 'listFiles'}.action`\n\n    let params = {\n      folderId: id,\n      inGroupSpace: false,\n      mediaType: 0,\n      iconOption: 5,\n      descending: true,\n      orderBy: 'filename',\n      pageSize: usePagination ? perPage : 1000,\n      noCache: Math.random(),\n    }\n\n\n    if (orderBy) {\n      let [sortKey, isAsc] = orderBy\n      params.orderBy = sortKey == 'name' ? 'filename' : sortKey == 'mtime' ? 'lastOpTime' : sortKey == 'size' ? 'filesize' : 'filename'\n      params.descending = isAsc ? false : true\n    }\n\n    if (isSearch) {\n      params.filename = search\n      params.recursive = !!local_search ? 0 : 1\n    }\n\n    do {\n\n      let { data } = await safeRequest(url, {\n        data: {\n          ...params,\n          pageNum: nextPage\n        },\n        headers: {\n          cookie,\n          // default format is xml\n          accept: 'application/json;charset=UTF-8',\n          // 'sign-type': 1,\n        },\n        responseType: 'text',\n      })\n\n      data = safeJSONParse(data)\n\n      if (data?.errorCode) return this.app.error({ message: data.errorMsg })\n\n      const vo = isSearch ? data : data.fileListAO\n\n      if (vo?.folderList) {\n        for (let i of vo.folderList) {\n          files.push({\n            id: i.id,\n            name: i.name,\n            type: 'folder',\n            size: i.size,\n            ctime: timestamp(i.createDate),\n            mtime: timestamp(i.lastOpTime),\n            extra: {\n              fid: i.id,\n              parent_id: i.parentId,\n              count: i.fileCount,\n            },\n          })\n        }\n      }\n\n      if (vo?.fileList) {\n        for (let i of vo.fileList) {\n          files.push({\n            id: i.id,\n            name: i.name,\n            type: 'file',\n            size: i.size,\n            ctime: timestamp(i.createDate),\n            mtime: timestamp(i.lastOpTime),\n            thumb: i.icon?.smallUrl,\n            extra: {\n              fid: i.id,\n              parent_id: id,\n              md5: i.md5.toLowerCase(),\n            },\n          })\n        }\n      }\n\n      if (nextPage * params.pageSize < parseInt(data.recordCount)) {\n        nextPage++\n      } else {\n        break\n      }\n    } while (!usePagination && nextPage)\n\n\n    let result = {\n      id, files\n    }\n\n    if (usePagination && nextPage) {\n      result.nextPage = nextPage\n    }\n\n    return result\n  }\n\n  /**\n   * get file\n   *\n   * @param {string} [id] path id\n   * @return {object}\n   *\n   * @api public\n   */\n  async get(id, more = false) {\n\n    let { cookie, safeRequest } = await this.getConfig()\n\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/portal/getFileInfo.action`, {\n      headers: {\n        cookie,\n        // default format is xml\n        accept: 'application/json;charset=UTF-8',\n      },\n      data: {\n        noCache: Math.random(),\n        fileId: id,\n      },\n    })\n\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\n    let result = {\n      id: data.fileId,\n      name: data.fileName,\n      type: data.isFolder ? 'folder' : 'file',\n      size: data.fileSize,\n      ctime: data.createTime,\n      mtime: data.lastOpTime,\n      // download_url: data.isFolder ? '' : `https:${data.downloadUrl}`,\n      extra: {\n        fid: data.fileId,\n        parent_id: data.parentId,\n        downloadUrl: data.downloadUrl\n      },\n    }\n\n    if (data.imageInfo?.icon) {\n      result.thumb = data.imageInfo.icon.smallUrl\n    }\n    else if (data.audioInfo?.icon) {\n      result.thumb = data.audioInfo.icon.smallUrl\n    }\n    else if (data.videoInfo?.icon) {\n      result.thumb = data.videoInfo.icon.smallUrl\n    }\n\n    // get hash\n    if (more && data.parentId) {\n      let parentData = await this.list(data.parentId)\n      if (parentData?.files) {\n        let hit = parentData.files.find(i => i.id == id)\n        if (hit.md5) {\n          result.extra.md5 = hit.md5\n        }\n      }\n    }\n\n    if (!more && !result.download_url && result.type != 'folder') {\n      let { url, max_age } = await this.get_download_url(id, 'https:' + data.downloadUrl)\n      if (url) {\n        result.download_url = url\n        result.max_age = max_age\n      }\n    }\n    return result\n  }\n\n  async get_download_url(id, download_url) {\n    if (!download_url) {\n      let res = await this.get(id, true)\n      download_url = res.extra.downloadUrl\n    }\n    let { cookie } = await this.getConfig()\n\n    if (download_url) {\n      let { headers } = await this.app.request.get(download_url, {\n        followRedirect: false,\n        responseType: 'text',\n        headers: {\n          cookie,\n          'User-Agent':\n            'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',\n        },\n      })\n\n      download_url = headers?.location\n\n      // get oss link\n      if (download_url) {\n        let { headers } = await this.app.request.get(download_url, {\n          followRedirect: false,\n          responseType: 'text',\n          headers: {\n            'User-Agent':\n              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',\n          },\n        })\n\n        download_url = headers?.location\n      }\n\n      if (download_url) {\n        let expired_at = download_url.match(/Expires=(?<expired_at>\\d+)/i)?.groups.expired_at || 0\n        let max_age = 0\n        if (expired_at) {\n          max_age = +expired_at * 1000 - Date.now()\n        }\n\n        return { url: download_url, max_age }\n      }\n    }\n\n    return { error: {} }\n  }\n\n  async mkdir(id, name, { check_name_mode = 'refuse' }) {\n    let { cookie, safeRequest } = await this.getConfig()\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/file/createFolder.action?noCache=${Math.random()}`, {\n      method: 'POST',\n      headers: {\n        cookie,\n        accept: 'application/json;charset=UTF-8',\n      },\n      contentType: 'form',\n      data: {\n        folderName: name,\n        parentFolderId: id,\n      },\n    })\n\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\n\n    return {\n      id: data.id,\n      name: data.name,\n      parent_id: id\n    }\n  }\n\n  async rm(id) {\n    let originData = await this.get(id, true)\n    let { cookie, safeRequest } = await this.getConfig()\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/batch/createBatchTask.action?noCache=${Math.random()}`, {\n      method: 'POST',\n      headers: {\n        cookie,\n        accept: 'application/json;charset=UTF-8',\n      },\n      contentType: 'form',\n      data: {\n        type: 'DELETE',\n        taskInfos: [{ \"fileId\": id, \"fileName\": originData.name, \"isFolder\": originData.type == 'folder' ? 1 : 0 }],\n        targetFolderId: ''\n      },\n    })\n\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\n\n    let taskId = data.taskId\n\n    await this.monitor({ taskId, type: 'DELETE' })\n\n    return {\n      id: data.id,\n      name: data.name,\n      parent_id: originData.extra.parent_id\n    }\n  }\n\n  async mv(id, target_id, { copy, name } = {}) {\n    let originData = await this.get(id, true)\n\n    let { cookie, safeRequest } = await this.getConfig()\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/batch/createBatchTask.action?noCache=${Math.random()}`, {\n      method: 'POST',\n      headers: {\n        cookie,\n        accept: 'application/json;charset=UTF-8',\n      },\n      contentType: 'form',\n      data: {\n        type: copy ? 'COPY' : 'MOVE',\n        taskInfos: [{ \"fileId\": id, \"fileName\": originData.name, \"isFolder\": originData.type == 'folder' ? 1 : 0 }],\n        targetFolderId: target_id\n      },\n    })\n\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\n\n    let taskId = data.taskId\n\n    let res = await this.monitor({ taskId, type: copy ? 'COPY' : 'MOVE' })\n\n    if (res) {\n      return {\n        id: originData.id,\n        name: originData.name,\n        origin_parent_id: originData.extra.parent_id\n      }\n    }\n    //189cloud 不支持目的地存在相同文件，也不支持复制/移动时，重命名。 \n    return this.app.error({ message: '', code: 501 })\n  }\n\n  /**\n   * rename file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] new name\n   * @return {object}\n   *\n   * @api public\n   */\n  async rename(id, name, { check_name_mode = 'refuse' } = {}) {\n    let { cookie, safeRequest } = await this.getConfig()\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/file/renameFolder.action?noCache=${Math.random()}`, {\n      method: 'POST',\n      headers: {\n        cookie,\n        accept: 'application/json;charset=UTF-8',\n      },\n      contentType: 'form',\n      data: {\n        destFolderName: name,\n        folderId: id,\n      },\n    })\n\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\n\n    return {\n      id: data.id,\n      name: data.name,\n      parent_id: data.parentId\n    }\n  }\n\n  async generate_rsa_key() {\n    if (!this.rsa_key || (this.rsa_key.expire - Date.now() < 5 * 60 * 1000)) {\n      let { cookie, safeRequest } = await this.getConfig()\n      let { data } = await safeRequest(`${API_ENDPOINT}/api/security/generateRsaKey.action?noCache=${Math.random()}`, {\n        headers: {\n          cookie,\n          accept: 'application/json;charset=UTF-8',\n        },\n        responseType: 'json'\n      })\n      console.log('update rsa_key')\n      this.rsa_key = data\n    }\n\n    return this.rsa_key\n  }\n\n  async createRequest(url, formData) {\n    let { sessionKey } = await this.getConfig()\n    let { pkId, pubKey } = await this.generate_rsa_key()\n\n    let date = Date.now()\n    let pkey = uuid(\"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\").slice(0, 16 + 16 * Math.random() | 0)\n    let params = aesEncrypt(qs(formData), pkey.substring(0, 16))\n    let signature = hmac(`SessionKey=${sessionKey}&Operate=GET&RequestURI=${url}&Date=${date}&params=${params}`, pkey)\n    let encryptionText = rsaEncrypt(pkey, pubKey)\n\n    const headers = {\n      signature,\n      sessionKey,\n      encryptionText,\n      pkId,\n      'x-request-id': uuid('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'),\n      'x-request-date': date,\n      'origin': 'https://cloud.189.cn',\n      'referer': 'https://cloud.189.cn/'\n    }\n\n    return await this.app.request(`https://upload.cloud.189.cn${url}?params=${params}`, { headers })\n  }\n\n  async singleUpload(id, { size, name, stream, ...rest }) {\n    const { app } = this\n\n    let passStream = app.streamReader(stream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\n\n    let buffer = await passStream.read(UPLOAD_PART_SIZE)\n\n    let md5hash = md5(buffer)\n\n    let { data } = await this.createRequest('/person/initMultiUpload', {\n      parentFolderId: id,\n      fileName: name,\n      fileSize: size,\n      sliceSize: UPLOAD_PART_SIZE,\n      sliceMd5: md5hash,\n      fileMd5: md5hash\n    })\n\n    if (!data?.code == 'SUCCESS') return this.app.error({ message: 'a error occurred before upload.' })\n\n    let { uploadFileId, fileDataExists } = data.data\n\n    if (fileDataExists == 0) {\n\n      // Skip step\n      // let { data: d1, status } = await this.createRequest(\"/person/getUploadedPartsInfo\", {\n      //   uploadFileId\n      // })\n\n      let chunk_base64 = Buffer.from(md5hash, 'hex').toString('base64')\n      let { data: uploadData } = await this.createRequest('/person/getMultiUploadUrls', {\n        uploadFileId,\n        partInfo: `1-${chunk_base64}`,\n      })\n\n      uploadData = uploadData?.['uploadUrls'][`partNumber_1`]\n\n      let res = await app.request(uploadData.requestURL, {\n        method: 'put',\n        data: buffer,\n        contentType: 'buffer',\n        responseType: 'text',\n        headers: {\n          ...parseHeaders(uploadData.requestHeader),\n          \"referer\": 'https://cloud.189.cn/',\n        }\n      })\n\n      if (res.status != 200) app.error({ message: 'a error occurred during upload.' })\n    }\n    let { data: res } = await this.createRequest('/person/commitMultiUploadFile', {\n      uploadFileId,\n      fileMd5: md5hash,\n      //fileSize<=10MB,fileMD5 should equal sliceMd5,\n      sliceMd5: md5hash,\n      lazyCheck: 0,\n    })\n\n    return { id: res.file.userFileId }\n  }\n\n  async upload(id, stream, { size, name, manual, ...rest }) {\n    if (size <= UPLOAD_PART_SIZE) {\n      return await this.singleUpload(id, { size, name, stream, ...rest })\n    }\n\n    const { app } = this\n\n    let { data } = await this.createRequest('/person/initMultiUpload', {\n      parentFolderId: id,\n      fileName: name,\n      fileSize: size,\n      sliceSize: UPLOAD_PART_SIZE,\n      lazyCheck: 1\n    })\n    if (!data?.code == 'SUCCESS' || !data?.data) return this.app.error({ message: 'a error occurred before upload.' })\n\n    let { uploadFileId } = data.data\n    let start = 0\n    // 此操作疑似无实际效果\n    // await this.createRequest('/person/getUploadedPartsInfo', {\n    //   uploadFileId,\n    // })\n\n    if (!stream) {\n      return { uploadId: uploadFileId, start }\n    }\n\n    let part = Math.ceil(size / UPLOAD_PART_SIZE)\n    let passStream = app.streamReader(customStream || stream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\n    let md5chunk = []\n    let md5sum = crypto.createHash('md5')\n    for (let i = 1; i <= part; i++) {\n      let buffer = await passStream.read(UPLOAD_PART_SIZE)\n      let chunk_hash = md5(buffer).toUpperCase()\n      let chunk_base64 = Buffer.from(chunk_hash, 'hex').toString('base64')\n\n      md5chunk.push(chunk_hash)\n      md5sum.update(buffer)\n\n      let { data } = await this.createRequest('/person/getMultiUploadUrls', {\n        partInfo: `${i}-${chunk_base64}`,\n        uploadFileId,\n      })\n\n      let uploadData = data['uploadUrls'][`partNumber_${i}`]\n\n      let res = await app.request(uploadData.requestURL, {\n        method: 'put',\n        data: buffer,\n        contentType: 'buffer',\n        responseType: 'text',\n        headers: parseHeaders(uploadData.requestHeader)\n      })\n\n      if (res.status != 200) app.error({ message: 'a error occurred during upload.' })\n    }\n\n    let uniqueIdentifier = md5sum.digest('hex')\n\n    // commit\n    let { data: res } = await this.createRequest('/person/commitMultiUploadFile', {\n      uploadFileId,\n      fileMd5: uniqueIdentifier,\n      //fileSize<=10MB,fileMD5 should equal sliceMd5,\n      sliceMd5: md5(md5chunk.join('\\n')),\n      lazyCheck: 1,\n    })\n    return { id: res.file.userFileId }\n  }\n\n  async monitor(params, timeout = 5 * 1000) {\n    let { cookie, safeRequest } = await this.getConfig()\n\n    let startTime = Date.now()\n\n    while (Date.now() - startTime < timeout) {\n      let { data } = await safeRequest(`${API_ENDPOINT}/api/open/batch/checkBatchTask.action?noCache=${Math.random()}`, {\n        method: 'POST',\n        headers: {\n          cookie,\n          accept: 'application/json;charset=UTF-8',\n        },\n        contentType: 'form',\n        data: params,\n      })\n      if (data?.taskStatus == 4) {\n        return true\n      }\n\n      await sleep(300)\n    }\n  }\n}\n\nmodule.exports = { driver: Driver }"},{"hash":"7cfacb70e3b14b090690b800a949ca43","name":"FileFilter","namespace":"sharelist.plugin.file-filter","version":"1.0.0","license":"MIT","description":"提供基础目录过滤、加密功能","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-filter/index.js","script":"//===Sharelist===\n// @name         FileFilter\n// @namespace    sharelist.plugin.file-filter\n// @version      1.0.0\n// @license      MIT\n// @description  提供基础目录过滤、加密功能\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-filter/index.js\n//===/Sharelist==\n\n\nconst ignore = require('ignore')\n\nconst isIgnorePath = (p = '', config) => {\n  p = p.replace(/^\\//, '')\n  return p && ignore().add([].concat(config.acl_file, config.ignores)).ignores(p)\n}\n\nconst isForbiddenPath = () => false\n\nconst authMethods = {\n  basic(key, data) {\n    return data.some(i => '' + i === key)\n  },\n  async http(key, data, request) {\n    let { data: res } = await request(data.replace('{key}', key), { responseType: 'text' })\n    return res === 'success'\n  }\n}\n\nconst cache = {}\n\nmodule.exports = (sharelist) => {\n  const { config, driver, utils: { yaml, safeCall } } = sharelist\n\n  return {\n    config() {\n      return [\n        { code: 'acl_file', label: '加密文件名', type: 'string', default: '.passwd' },\n        { code: 'ignores', label: '忽略路径', type: 'array' },\n      ]\n    },\n\n    beforeList({ params, path }) {\n      //使用路径模式，提前排除\n      if (path && isIgnorePath(path, config)) {\n        throw { code: 404 }\n      }\n\n      if (path && isForbiddenPath(path, config)) {\n        throw { code: 404 }\n      }\n    },\n\n    async afterList({ data, params }) {\n      if (!config.acl_file) return\n      let hit = data?.files.find(i => i.name == config.acl_file)\n\n      if (hit) {\n        let scope = { id: data.id }\n\n        let auth = params.auth?.[data.id]\n\n        if (!auth) throw { code: 401, message: 'Invalid password', scope }\n\n        let content\n\n        if (cache[hit.id]) {\n          content = cache[hit.id]\n        } else {\n          await safeCall(async () => {\n            content = yaml.parse(await driver.getContent(hit.id))\n          })\n        }\n\n        if (!content) throw { code: 401, message: 'Invalid password', scope }\n\n        cache[hit.id] = content\n\n        if (await authMethods?.[content.type]('' + auth, content.data, sharelist.request) !== true) {\n          throw { code: 401, message: 'Invalid password', scope }\n        }\n\n      }\n\n    }\n  }\n}"},{"hash":"d6d9cf78258468cd24f3b765b6196aa6","name":"File System","namespace":"sharelist.plugin.file-system","version":"1.0.0","license":"MIT","description":"挂载本地磁盘","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-system/index.js","script":"//===Sharelist===\n// @name         File System\n// @namespace    sharelist.plugin.file-system\n// @version      1.0.0\n// @license      MIT\n// @description  挂载本地磁盘\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-system/index.js\n//===/Sharelist==\n\nconst { basename, dirname, posix, join } = require('path')\nconst fs = require('fs')\nconst os = require('os')\nconst { pipeline } = require('stream')\nconst crypto = require('crypto')\n\nconst isWinOS = os.platform() == 'win32'\n\nconst pipe = (...rest) => new Promise((resolve, reject) => pipeline(...rest, (err) => err ? reject({ message: 'The error occurred during pipe stream' }) : resolve()))\n\nconst md5 = content => crypto.createHash('md5').update(content).digest(\"hex\")\n\nconst md5file = (filepath, fast) => new Promise((resolve, reject) => {\n  const stream = fs.createReadStream(filepath);\n  const hash = crypto.createHash('md5');\n  stream.on('data', chunk => {\n    hash.update(chunk, 'utf8');\n  });\n  stream.on('end', () => {\n    resolve(hash.digest('hex'))\n  });\n})\n\nconst md5fileFast = (filepath, size = 256 * 1024) => {\n  fs.open(filepath, 'r', (err, fd) => {\n    const buff = Buffer.alloc(size);\n    fs.read(fd, buff, 0, buff.length, null, (err, bytesRead, chunk) => {\n      if (bytesRead) {\n        console.log(bytesRead, `md5: ${md5(chunk.slice(0, bytesRead))}`);\n      } else {\n        start = false;\n        console.timeEnd('readtime');\n        fs.closeSync(fd);\n      }\n    });\n  });\n}\n\nconst fileExist = (file) => new Promise((resolve, reject) => {\n  fs.access(file, fs.constants.F_OK, (err) => {\n    resolve(err ? false : true)\n  });\n})\n/**\n * Convert posix style path to windows style\n *\n * @param {string} [p]\n * @return {string}\n */\nconst winStyle = (p) =>\n  p\n    .replace(/^\\/([^\\/]+?)/, '$1:\\\\')\n    .replace(/\\//g, '\\\\')\n    .replace(/(?<!\\:)\\\\+$/, '')\n    .replace(/\\\\{2,}/g, '\\\\')\n\n/**\n * Convert windows style path to posix style\n *\n * @param {string} [p]\n * @return {string}\n */\nconst posixStyle = (p) =>\n  p\n    .split('\\\\')\n    .join('/')\n    .replace(/^([a-z])\\:/i, '/$1')\n\n/**\n * normalize path(posix style) and replace current path\n *\n * @param {string} [p]\n * @return {string}\n */\nconst normalize = (p) => posix.normalize(p.replace(/\\.\\//, slpath(process.cwd()) + '/'))\n\nconst slpath = (p) => (isWinOS ? posixStyle(p) : p)\n\n// const this.ospath = (p) => (isWinOS ? winStyle(p) : (p))\n\nconst parseRelativePath = (p) => p.replace(/\\.\\//, slpath(process.cwd()) + '/')\n// let stat = fs.statSync('D:\\CloudMusic\\Falcom Sound Team jdk - 浮游大陆アルジェス -Introduction-.mp3')\n// console.log(stat)\n\nconst ERROR_CODE = {\n  'EBUSY': 423,\n}\n\nconst fileStat = (src) => {\n  try {\n    return fs.statSync(src)\n  } catch (e) { }\n}\n\nconst fileRename = (filepath, targetpath) => {\n  try {\n    fs.renameSync(filepath, targetpath)\n  } catch (e) {\n  }\n}\n\nconst createError = (e) => {\n  console.log(e)\n\n  let error = { message: e.code }\n  if (ERROR_CODE[e.code]) {\n    error.code = ERROR_CODE[e.code]\n  }\n  return { error }\n}\n\nconst ospath = (p, base = '') => {\n  p = base + p\n  return isWinOS ? winStyle(p) : (p)\n}\n\nconst encode = (filepath) => {\n  return slpath(filepath).substring(1)\n}\n\nclass FileSystem {\n  static options = {\n    globalSearch: false,\n    localSearch: true,\n    protocol: \"fs\",\n    cache: false,\n    mountable: true,\n    pagination: false,\n    guide: [\n      { key: 'root_id', label: '目录地址', type: 'string', required: true },\n    ],\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.config = config\n  }\n\n  ospath(p) {\n    return ospath(p ? `/${p}` : (this.config.root_id))\n  }\n\n  isRoot(p) {\n    return p == this.config.root_id.substring(1)\n  }\n  /**\n    * 列出目录\n    *\n    * @param {string} [id] 文件(目录)id 唯一值\n    * \n    * @param {object} [options] 参数\n    * @param {object} [options.order_by] 排序\n    * @param {object} [options.search] 搜索内容\n    * @param {object} [options.page] 页码\n    * @param {object} [options.per_page] 每页条目数\n    * \n    * @return {object}\n    *\n    * @api public {Array<file>}\n    * \n    * files.id 资源ID\n    * files.name 资源名\n    * files.size 资源大小\n    * files.type 类型 'folder' | 'file'\n    * files.ctime 创建时间\n    * files.mtime 修改时间\n    */\n  async list(id, { search, orderBy } = {}) {\n    let filepath = this.ospath(id)\n    let stat = fs.statSync(filepath)\n\n\n    if (stat.isDirectory()) {\n      let files = []\n      fs.readdirSync(filepath).forEach((filename) => {\n        let dir = join(filepath, filename) //normalize(id + '/' + filename)\n        let stat\n        try {\n          stat = fs.statSync(dir)\n        } catch (e) {\n          // console.log(e)\n        }\n\n        let rid = encode(dir)\n        let obj = {\n          id: rid,\n          name: filename,\n        }\n        if (stat) {\n          if (stat.isDirectory()) {\n            obj.type = 'folder'\n          } else if (stat.isFile()) {\n            obj.type = 'file'\n            obj.size = stat.size\n          }\n          obj.ctime = stat.ctimeMs\n          obj.mtime = stat.mtimeMs\n          obj.extra = {\n            fid: rid,\n            parent_id: id\n          }\n        }\n\n        if (!search || filename.includes(search)) {\n          files.push(obj)\n        }\n      })\n\n      if (orderBy) {\n        let [type, isAsc] = orderBy\n        let aVal = isAsc ? 1 : -1\n        let bVal = isAsc ? -1 : 1\n        files.sort((a, b) => a[type] > [b.type] ? aVal : bVal)\n      }\n      files.sort((a, b) => (a.type == 'folder' && b.type != 'folder') ? -1 : 1)\n\n      return { id, files }\n    }\n\n    return this.app.error({ message: 'path is not exist' })\n  }\n\n  async get(id) {\n    let stat = fileStat(this.ospath(id))\n    if (!stat) return this.app.error({ code: 404 })\n    let isRoot = this.isRoot(id)\n\n    if (isRoot) {\n      return {\n        id,\n        name: '@drive_root',\n        type: 'folder'\n      }\n    }\n\n    let data = {\n      id: id,\n      name: basename(id),\n      size: stat.size,\n      type: stat.isDirectory() ? 'folder' : 'file',\n      ctime: stat.ctimeMs,\n      mtime: stat.mtimeMs,\n      extra: {\n        fid: id,\n        parent_id: id ? dirname(id) : undefined,\n      }\n    }\n    if (data.type == 'file') {\n      data.extra.md5 = await md5file(this.ospath(id))\n    }\n    return data\n  }\n\n  mkdir(id, name) {\n    let filepath = this.ospath(id)\n    let target = join(filepath, name)\n\n    if (fs.existsSync(target) == false) {\n      fs.mkdirSync(target)\n    }\n\n    return { id: normalize(id + '/' + name), name }\n  }\n\n  rm(id) {\n    let filepath = this.ospath(id)\n    try {\n      fs.rmSync(filepath, { force: false, recursive: true })\n    } catch (e) {\n      return createError(e)\n    }\n    return { id }\n  }\n\n  rename(id, name) {\n    let filepath = this.ospath(id)\n    let dir = dirname(filepath)\n    let targetpath = join(dir, name)\n    try {\n      fs.renameSync(filepath, targetpath)\n    } catch (e) {\n      console.log(e)\n      return createError(e)\n    }\n\n    return { id: `${dir + '/' + name}`, name }\n  }\n\n  /**\n   * move\n   * @param {*} id file or folder ID\n   * @param {string} target folder ID\n   * @returns \n   */\n  async mv(id, target) {\n    // console.log('mv', id, target)\n    let filepath = this.ospath(id)\n    let targetpath = this.ospath(target)\n\n    let dst = join(targetpath, basename(id))\n\n    try {\n      fs.renameSync(filepath, dst)\n    } catch (e) {\n      return createError(e)\n    }\n\n    return { id: encode(dst) }\n  }\n\n  async afterUpload() {\n    //rename filename.filepart -> filename\n  }\n\n  async beforeUpload(id, name) {\n    let filepath = this.ospath(id)\n    let tmpfile = join(filepath, name + '.filepart')\n\n    fs.access(file, fs.constants.F_OK, (err) => { console.log(`${file} ${err ? '不存在' : '存在'}`); });\n    fs.closeSync(fs.openSync(tmpfile, 'w'))\n\n    let uploadId = md5(id + '_' + name)\n    return { uploadId }\n  }\n\n  async upload(id, stream, { size, name, manual, uploadId, ...options }) {\n    let filepath = this.ospath(id)\n    let target = join(filepath, name)\n    let currentUploadId = md5(id + '_' + name)\n\n    if (currentUploadId != uploadId) {\n      // 不是同一个上传实例,似乎无关紧要\n    }\n    let uploadFile = target + '.filepart'\n    let filepart = await fileStat(uploadFile)\n    let start = 0\n    // 创建空文件\n    if (!filepart) {\n      fs.closeSync(fs.openSync(uploadFile, 'w'))\n    } else {\n      start = filepart.size\n    }\n\n\n    const done = async (customStream) => {\n      let writeStream = fs.createWriteStream(uploadFile, { ...options, start, flags: 'a' })\n      await pipe(stream || customStream, writeStream)\n      //rename\n      fileRename(uploadFile, target)\n      return { id: encode(target), name }\n    }\n    if (manual) {\n      //这个upload\n      return {\n        uploadId: currentUploadId, start, done\n      }\n    } else {\n      return await done(stream)\n    }\n  }\n\n  async createReadStream(id, options = {}) {\n    let filepath = this.ospath(id)\n    return fs.createReadStream(filepath, { ...options, highWaterMark: 64 * 1024 })\n  }\n}\n\nmodule.exports = { driver: FileSystem }"},{"hash":"7d1f8a4efde01769d3789bb4c109088d","name":"GoogleDrive","namespace":"sharelist.plugin.googledrive","version":"1.0.0","license":"MIT","description":"GoogleDrive","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/googledrive/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODcuMyA3OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxwYXRoIGQ9Im02LjYgNjYuODUgMy44NSA2LjY1Yy44IDEuNCAxLjk1IDIuNSAzLjMgMy4zbDEzLjc1LTIzLjhoLTI3LjVjMCAxLjU1LjQgMy4xIDEuMiA0LjV6IiBmaWxsPSIjMDA2NmRhIi8+Cgk8cGF0aCBkPSJtNDMuNjUgMjUtMTMuNzUtMjMuOGMtMS4zNS44LTIuNSAxLjktMy4zIDMuM2wtMjUuNCA0NGE5LjA2IDkuMDYgMCAwIDAgLTEuMiA0LjVoMjcuNXoiIGZpbGw9IiMwMGFjNDciLz4KCTxwYXRoIGQ9Im03My41NSA3Ni44YzEuMzUtLjggMi41LTEuOSAzLjMtMy4zbDEuNi0yLjc1IDcuNjUtMTMuMjVjLjgtMS40IDEuMi0yLjk1IDEuMi00LjVoLTI3LjUwMmw1Ljg1MiAxMS41eiIgZmlsbD0iI2VhNDMzNSIvPgoJPHBhdGggZD0ibTQzLjY1IDI1IDEzLjc1LTIzLjhjLTEuMzUtLjgtMi45LTEuMi00LjUtMS4yaC0xOC41Yy0xLjYgMC0zLjE1LjQ1LTQuNSAxLjJ6IiBmaWxsPSIjMDA4MzJkIi8+Cgk8cGF0aCBkPSJtNTkuOCA1M2gtMzIuM2wtMTMuNzUgMjMuOGMxLjM1LjggMi45IDEuMiA0LjUgMS4yaDUwLjhjMS42IDAgMy4xNS0uNDUgNC41LTEuMnoiIGZpbGw9IiMyNjg0ZmMiLz4KCTxwYXRoIGQ9Im03My40IDI2LjUtMTIuNy0yMmMtLjgtMS40LTEuOTUtMi41LTMuMy0zLjNsLTEzLjc1IDIzLjggMTYuMTUgMjhoMjcuNDVjMC0xLjU1LS40LTMuMS0xLjItNC41eiIgZmlsbD0iI2ZmYmEwMCIvPgo8L3N2Zz4=","script":"//===Sharelist===\n// @name         GoogleDrive\n// @namespace    sharelist.plugin.googledrive\n// @version      1.0.0\n// @license      MIT\n// @description  GoogleDrive\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/googledrive/index.js\n// @icon         data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODcuMyA3OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxwYXRoIGQ9Im02LjYgNjYuODUgMy44NSA2LjY1Yy44IDEuNCAxLjk1IDIuNSAzLjMgMy4zbDEzLjc1LTIzLjhoLTI3LjVjMCAxLjU1LjQgMy4xIDEuMiA0LjV6IiBmaWxsPSIjMDA2NmRhIi8+Cgk8cGF0aCBkPSJtNDMuNjUgMjUtMTMuNzUtMjMuOGMtMS4zNS44LTIuNSAxLjktMy4zIDMuM2wtMjUuNCA0NGE5LjA2IDkuMDYgMCAwIDAgLTEuMiA0LjVoMjcuNXoiIGZpbGw9IiMwMGFjNDciLz4KCTxwYXRoIGQ9Im03My41NSA3Ni44YzEuMzUtLjggMi41LTEuOSAzLjMtMy4zbDEuNi0yLjc1IDcuNjUtMTMuMjVjLjgtMS40IDEuMi0yLjk1IDEuMi00LjVoLTI3LjUwMmw1Ljg1MiAxMS41eiIgZmlsbD0iI2VhNDMzNSIvPgoJPHBhdGggZD0ibTQzLjY1IDI1IDEzLjc1LTIzLjhjLTEuMzUtLjgtMi45LTEuMi00LjUtMS4yaC0xOC41Yy0xLjYgMC0zLjE1LjQ1LTQuNSAxLjJ6IiBmaWxsPSIjMDA4MzJkIi8+Cgk8cGF0aCBkPSJtNTkuOCA1M2gtMzIuM2wtMTMuNzUgMjMuOGMxLjM1LjggMi45IDEuMiA0LjUgMS4yaDUwLjhjMS42IDAgMy4xNS0uNDUgNC41LTEuMnoiIGZpbGw9IiMyNjg0ZmMiLz4KCTxwYXRoIGQ9Im03My40IDI2LjUtMTIuNy0yMmMtLjgtMS40LTEuOTUtMi41LTMuMy0zLjNsLTEzLjc1IDIzLjggMTYuMTUgMjhoMjcuNDVjMC0xLjU1LS40LTMuMS0xLjItNC41eiIgZmlsbD0iI2ZmYmEwMCIvPgo8L3N2Zz4=\n//===/Sharelist==\n\n/**\n * 1. Google Drive allows duplicate names\n * 2. The root folder also has a unique ID, it can use the alias root to refer to the root folder anywhere a file ID is provided\n */\nconst API_ENDPOINT = 'https://www.googleapis.com'\n\nconst DEFAULT_ROOT_ID = 'root'\n\nclass Manager {\n  static getInstance(app, config) {\n    if (!this.instance) {\n      this.instance = new Manager(app)\n    }\n\n    return this.instance.createGetter(config)\n  }\n\n  constructor(app) {\n    this.app = app\n  }\n\n  createGetter(config) {\n    return async () => {\n      if (\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\n      ) {\n        await this.refreshAccessToken(config)\n      }\n      return {\n        ...config\n      }\n    }\n  }\n\n  /**\n   * 刷新令牌 / refresh token\n   *\n   * @param {object} credentials\n   * @param {object} { credentials: object } | { error:true, message:string }\n   * @api private\n   */\n  async refreshAccessToken(credentials) {\n    let { client_id, client_secret, redirect_uri, refresh_token, ...rest } = credentials\n\n    if (!(client_id && client_secret && refresh_token)) {\n      return { error: { message: 'Invalid parameters: An error occurred during refresh access token' } }\n    }\n\n    let formdata = {\n      client_id,\n      client_secret,\n      // redirect_uri,\n      refresh_token,\n      grant_type: 'refresh_token',\n    }\n    let { data } = await this.app.request.post('https://oauth2.googleapis.com/token', {\n      data: formdata,\n      contentType: 'json',\n      proxy: rest.proxy\n    })\n\n    if (data.error) {\n      throw { message: data.error_description || data.error }\n    }\n\n    let expires_at = data.expires_in * 1000 + Date.now()\n\n    credentials.access_token = data.access_token\n    credentials.expires_at = expires_at\n\n  }\n}\n\n\nclass Driver {\n  static options = {\n    protocol: \"googledrive\",\n\n    //支持全局搜索\n    globalSearch: true,\n    localSearch: true,\n\n    key: 'client_id',\n    defaultRoot: DEFAULT_ROOT_ID,\n\n    guide: [\n      { key: 'client_id', label: '应用ID / Client ID', type: 'string', required: true },\n      { key: 'client_secret', label: '应用机密 / Client Secret', type: 'string', required: true },\n      { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\n      { key: 'refresh_token', label: '刷新令牌 / Refresh Token', type: 'string', required: true },\n      { key: 'root_id', label: '初始文件夹ID / Rood ID', help: '', type: 'string', required: false },\n      { key: 'proxy', label: '代理地址 / Proxy Server', help: '', type: 'string', required: false },\n    ]\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.getConfig = Manager.getInstance(app, config)\n    this.abusiveFilesMap = {}\n  }\n\n  //docs: https://developers.google.com/drive/api/v3/reference/files/list\n  //per_page : 1-1000\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\n\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n\n    let usePagination = !!perPage\n\n    let { access_token, proxy } = await this.getConfig()\n    const url = `${API_ENDPOINT}/drive/v3/files`\n\n    const q = ['trashed = false', `'${id}' in parents`]\n\n    if (search) {\n      q.push(`name contains '${search}'`)\n    }\n\n    const params = {\n      includeItemsFromAllDrives: true,\n      supportsAllDrives: true,\n      pageSize: usePagination ? perPage : 1000,\n      fields: `nextPageToken, files(id,name,mimeType,parents,size,fileExtension,thumbnailLink,createdTime,modifiedTime,ownedByMe,md5Checksum)`,\n      q: q.join(' and '),\n    }\n\n    // order_by\n    // Valid keys are 'createdTime', 'folder', 'modifiedByMeTime', 'modifiedTime', 'name', 'name_natural', 'quotaBytesUsed', 'recency', 'sharedWithMeTime', 'starred', and 'viewedByMeTime'\n    if (orderBy) {\n      let [sortKey, sortType] = orderBy\n      sortKey = sortKey == 'mtime' ? 'modifiedTime' : sortKey == 'size' ? 'quotaBytesUsed' : 'name'\n      params.orderBy = 'folder,' + sortKey + ' ' + (sortType ? 'asc' : 'desc')\n    } else {\n      params.orderBy = 'folder'\n    }\n\n    let pageToken = nextPage, files = []\n\n    do {\n      let { data, error } = await request.get(url, {\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: { ...params, ...(pageToken ? { pageToken } : {}) },\n        proxy\n      })\n      if (data.error) {\n        // Exceeded\n        if (data.error.code == 403 && data.error.message == 'Rate Limit Exceeded') {\n\n        }\n        return this.app.error({ code: data.error.code, message: data.error.message })\n      }\n\n      pageToken = data.nextPageToken\n\n      //nextPageToken\n      data.files.forEach((i) => {\n        let item = {\n          id: i.id,\n          name: i.name,\n          type: i.mimeType.includes('.folder') ? 'folder' : 'file',\n          size: parseInt(i.size || 0),\n          ctime: new Date(i.createdTime).getTime(),\n          mtime: new Date(i.modifiedTime).getTime(),\n          thumb: data.thumbnailLink,\n          extra: {\n            fid: i.id,\n            //root also has a id, but it shouldn't be used here\n            parent_id: id, // i.parents?.[0],\n            md5: i.md5Checksum,\n          },\n        }\n\n        if (item.type == 'file') {\n          item.extra.mime = i.mimeType\n        } else if (i.folder) {\n          // item.extra.child_count = i.folder.childCount\n        }\n\n        files.push(item)\n\n        if (id == DEFAULT_ROOT_ID && !this.realRootId) {\n          this.realRootId = i.parents?.[0]\n        }\n\n      })\n    } while (!usePagination && pageToken)\n\n    let result = {\n      id, files\n    }\n\n    if (usePagination && pageToken) {\n      result.nextPage = pageToken\n    }\n\n    return result\n  }\n\n  //docs: https://developers.google.com/drive/api/v3/reference/files/get\n  /**\n   * get file\n   *\n   * @param {string} [id] path id\n   * @param {string} [key] key\n   * @return {object}\n   *\n   * @api public\n   */\n  async get(id) {\n    let { access_token, proxy } = await this.getConfig()\n\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n\n    let url = `${API_ENDPOINT}/drive/v3/files/${id}`\n    let { data } = await request.get(url, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        // acknowledgeAbuse: true,\n        fields: `*`,\n      },\n      proxy\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name: data.name,\n      type: data.mimeType.includes('.folder') ? 'folder' : 'file',\n      size: data.size,\n      ctime: timestamp(data.createdDateTime),\n      mtime: timestamp(data.lastModifiedDateTime),\n      thumb: data.thumbnailLink,\n      extra: {\n        fid: data.id,\n        //root also has a id, but it shouldn't be used here\n        parent_id: this.realRootId == data.parents?.[0] ? DEFAULT_ROOT_ID : data.parents?.[0],\n        md5: data.md5Checksum,\n        content_link: data.webContentLink,\n      },\n    }\n  }\n\n\n  /**\n   * create folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] folder name\n   * @param {object} [options] options\n   * @param {object} [options.check_name_mode] \n   * @return {object}\n   *\n   * @api public\n   */\n  async mkdir(parent_file_id, name, { check_name_mode = 'refuse' }) {\n    let { access_token, proxy } = await this.getConfig()\n\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/drive/v3/files`, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        'name': name,\n        'parents': [parent_file_id],\n        'mimeType': 'application/vnd.google-apps.folder',\n      },\n      contentType: 'json',\n      proxy\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name: data.name,\n      parent_id: parent_file_id\n    }\n  }\n\n  /**\n   * rename file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] new name\n   * @return {object}\n   *\n   * @api public\n   */\n  async rename(file_id, name, { check_name_mode = 'refuse' } = {}) {\n    let { access_token, proxy } = await this.getConfig()\n\n    let { data } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${file_id}`, {\n      method: 'PATCH',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        name,\n      },\n      contentType: 'json',\n      proxy\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name: data.name,\n    }\n  }\n\n\n  /**\n   * mv file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [parent_id] folder id\n   * @return {string | error}\n   *\n   * @api public\n   */\n  async mv(id, targetId, { name, copy } = {}) {\n    if (copy) return await this.copy(id, targetId, { name })\n\n    let { access_token, proxy } = await this.getConfig()\n    let filedata = await this.get(id)\n    let parentId = filedata?.extra.parent_id\n    let params = {}\n\n    if (name) params.name = name\n\n    let { data } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${id}?addParents=${targetId}&removeParents=${parentId}`, {\n      method: 'PATCH',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      contentType: 'json',\n      data: params,\n      proxy\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name: data.name,\n      origin_parent_id: parentId\n    }\n  }\n\n  /**\n   * copy file/folder\n   *\n   * @param {string} [id] folder id\n   * @return {string}\n   *\n   * @api public\n   */\n  async copy(id, destId, { name }) {\n    let { access_token, proxy } = await this.getConfig()\n\n    let dest = {\n      parents: [destId]\n    }\n    if (name) dest.name = name\n    console.log('copy', id, '-->', destId)\n    let { status, data } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${id}/copy`, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: dest,\n      contentType: 'json',\n      proxy\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name: data.name\n    }\n  }\n\n  /**\n   * remove file/folder\n   *\n   * @param {string} [id] folder id\n   * @return {string}\n   *\n   * @api public\n   */\n  async rm(file_id) {\n    let { access_token, proxy } = await this.getConfig()\n    let filedata = await this.get(file_id)\n\n    let { status } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${file_id}`, {\n      method: \"DELETE\",\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      responseType: 'text',\n      proxy\n    })\n\n    if (status != 204) {\n      return this.app.error({ message: 'An error occurred during delete files' })\n    }\n\n    return {\n      id: file_id,\n      parent_id: filedata.extra.parent_id\n    }\n  }\n\n  async beforeUpload(parent_id, { name, size, state }) {\n    let { access_token, proxy } = await this.getConfig()\n    //Resume an interrupted upload\n    if (state.uploadId) {\n      let { headers, status, data } = await this.app.request.put(state.uploadId, {\n        data: {\n          name,\n          parents: [parent_id]\n        },\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n          'Content-Range': '*/' + size\n        },\n        contentType: 'json',\n        responseType: 'text',\n        proxy\n      })\n      if (status == 200 || status == 201) {\n        return { completed: true }\n      }\n      //308 Resume Incomplete\n      else if (status == 308) {\n        return { uploadUrl: state.uploadId, start: +headers['range'].split('-')[1] }\n      }\n    }\n\n\n    let { headers, status, data } = await this.app.request.post(`${API_ENDPOINT}/upload/drive/v3/files?uploadType=resumable`, {\n      data: {\n        name,\n        parents: [parent_id]\n      },\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n        'X-Upload-Content-Length': size\n      },\n      contentType: 'json',\n      responseType: 'text',\n      proxy\n    })\n\n    if (status != 200) return this.app.error({ code: status, message: 'An error occurred during resumable upload' })\n\n    return { uploadUrl: headers?.location, start: 0 }\n  }\n\n  /**\n   * upload file\n   * Maximum file size: 5120GB\n   *\n   * @param {string} [id] folder id\n   * @param {ReadableStream} [stream] upload file stream\n   * @param {object} [options] upload file meta\n   * @param {number} [options.size] upload file size\n   * @param {string} [options.name] upload file name\n   * @param {object} [credentials] credentials\n   * @return {string | error}\n   *\n   * @api public\n   */\n  async upload(id, stream, { size, name, ...rest }) {\n    const { app } = this\n    let { proxy } = await this.getConfig()\n\n    let { uploadUrl, start } = await this.beforeUpload(id, { name, size, ...rest })\n\n    if (!uploadUrl) {\n      return app.error('An error occurred during upload, miss upload url')\n    }\n\n    rest?.setState?.({ uploadId: `${uploadUrl}`, start })\n\n    let { data } = await app.request(uploadUrl, {\n      method: 'put',\n      headers: {\n        'Content-Length': size - start,\n        'Content-Range': `bytes ${start}-${size - 1}/${size}`,\n      },\n      data: stream,\n      contentType: 'stream',\n      proxy\n    })\n\n    return {\n      id: data.id,\n      name: data.name,\n      parent_id: id\n    }\n  }\n  /**\n   * check if it is a abusive file\n   * @param {*} url \n   * @param {*} access_token \n   * @returns {boolean}\n   */\n  async isAbusiveFile(url, access_token) {\n    let { proxy } = await this.getConfig()\n\n    if (this.abusiveFilesMap[url]) {\n      return this.abusiveFilesMap[url]\n    } else {\n      const resp = await this.app.request(url, {\n        method: 'HEAD',\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        responseType: 'text',\n        proxy\n      })\n\n      this.abusiveFilesMap[url] = resp.status == 403\n\n      return this.abusiveFilesMap[url]\n    }\n  }\n\n  async createReadStream(id, options = {}) {\n\n    let { access_token, proxy } = await this.getConfig()\n\n    let url = `${API_ENDPOINT}/drive/v3/files/${id}?alt=media`\n\n    if (await this.isAbusiveFile(url, access_token)) {\n      url += '&acknowledgeAbuse=true'\n    }\n\n    let headers = {\n      Authorization: `Bearer ${access_token}`,\n    }\n\n    if ('start' in options) {\n      headers['range'] = `bytes=${options.start}-${options.end || ''}`\n    }\n\n    let resp = await this.app.request.get(url, {\n      headers,\n      responseType: 'stream',\n      retry: 0,\n      proxy\n    })\n\n    return resp.data\n  }\n\n}\n\nmodule.exports = { driver: Driver } "},{"hash":"58baf26da8d1f2af1fb9b7ff91d7daeb","name":"OneDrive","namespace":"sharelist.plugin.onedrive","version":"1.0.0","license":"MIT","description":"OneDrive","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/onedrive/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgNS41IDMyIDIwLjUiPjx0aXRsZT5PZmZpY2VDb3JlMTBfMzJ4XzI0eF8yMHhfMTZ4XzAxLTIyLTIwMTk8L3RpdGxlPjxnIGlkPSJTVFlMRV9DT0xPUiI+PHBhdGggZD0iTTEyLjIwMjQ1LDExLjE5MjkybC4wMDAzMS0uMDAxMSw2LjcxNzY1LDQuMDIzNzksNC4wMDI5My0xLjY4NDUxLjAwMDE4LjAwMDY4QTYuNDc2OCw2LjQ3NjgsMCwwLDEsMjUuNSwxM2MuMTQ3NjQsMCwuMjkzNTguMDA2Ny40Mzg3OC4wMTYzOWExMC4wMDA3NSwxMC4wMDA3NSwwLDAsMC0xOC4wNDEtMy4wMTM4MUM3LjkzMiwxMC4wMDIxNSw3Ljk2NTcsMTAsOCwxMEE3Ljk2MDczLDcuOTYwNzMsMCwwLDEsMTIuMjAyNDUsMTEuMTkyOTJaIiBmaWxsPSIjMDM2NGI4Ii8+PHBhdGggZD0iTTEyLjIwMjc2LDExLjE5MTgybC0uMDAwMzEuMDAxMUE3Ljk2MDczLDcuOTYwNzMsMCwwLDAsOCwxMGMtLjAzNDMsMC0uMDY4MDUuMDAyMTUtLjEwMjIzLjAwMjU4QTcuOTk2NzYsNy45OTY3NiwwLDAsMCwxLjQzNzMyLDIyLjU3Mjc3bDUuOTI0LTIuNDkyOTIsMi42MzM0Mi0xLjEwODE5LDUuODYzNTMtMi40Njc0NiwzLjA2MjEzLTEuMjg4NTlaIiBmaWxsPSIjMDA3OGQ0Ii8+PHBhdGggZD0iTTI1LjkzODc4LDEzLjAxNjM5QzI1Ljc5MzU4LDEzLjAwNjcsMjUuNjQ3NjQsMTMsMjUuNSwxM2E2LjQ3NjgsNi40NzY4LDAsMCwwLTIuNTc2NDguNTMxNzhsLS4wMDAxOC0uMDAwNjgtNC4wMDI5MywxLjY4NDUxLDEuMTYwNzcuNjk1MjhMMjMuODg2MTEsMTguMTlsMS42NjAwOS45OTQzOCw1LjY3NjMzLDMuNDAwMDdhNi41MDAyLDYuNTAwMiwwLDAsMC01LjI4Mzc1LTkuNTY4MDVaIiBmaWxsPSIjMTQ5MGRmIi8+PHBhdGggZD0iTTI1LjU0NjIsMTkuMTg0MzcsMjMuODg2MTEsMTguMTlsLTMuODA0OTMtMi4yNzkxLTEuMTYwNzctLjY5NTI4TDE1Ljg1ODI4LDE2LjUwNDIsOS45OTQ3NSwxOC45NzE2Niw3LjM2MTMzLDIwLjA3OTg1bC01LjkyNCwyLjQ5MjkyQTcuOTg4ODksNy45ODg4OSwwLDAsMCw4LDI2SDI1LjVhNi40OTgzNyw2LjQ5ODM3LDAsMCwwLDUuNzIyNTMtMy40MTU1NloiIGZpbGw9IiMyOGE4ZWEiLz48L2c+PC9zdmc+","script":"//===Sharelist===\n// @name         OneDrive\n// @namespace    sharelist.plugin.onedrive\n// @version      1.0.0\n// @license      MIT\n// @description  OneDrive\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/onedrive/index.js\n// @icon         data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgNS41IDMyIDIwLjUiPjx0aXRsZT5PZmZpY2VDb3JlMTBfMzJ4XzI0eF8yMHhfMTZ4XzAxLTIyLTIwMTk8L3RpdGxlPjxnIGlkPSJTVFlMRV9DT0xPUiI+PHBhdGggZD0iTTEyLjIwMjQ1LDExLjE5MjkybC4wMDAzMS0uMDAxMSw2LjcxNzY1LDQuMDIzNzksNC4wMDI5My0xLjY4NDUxLjAwMDE4LjAwMDY4QTYuNDc2OCw2LjQ3NjgsMCwwLDEsMjUuNSwxM2MuMTQ3NjQsMCwuMjkzNTguMDA2Ny40Mzg3OC4wMTYzOWExMC4wMDA3NSwxMC4wMDA3NSwwLDAsMC0xOC4wNDEtMy4wMTM4MUM3LjkzMiwxMC4wMDIxNSw3Ljk2NTcsMTAsOCwxMEE3Ljk2MDczLDcuOTYwNzMsMCwwLDEsMTIuMjAyNDUsMTEuMTkyOTJaIiBmaWxsPSIjMDM2NGI4Ii8+PHBhdGggZD0iTTEyLjIwMjc2LDExLjE5MTgybC0uMDAwMzEuMDAxMUE3Ljk2MDczLDcuOTYwNzMsMCwwLDAsOCwxMGMtLjAzNDMsMC0uMDY4MDUuMDAyMTUtLjEwMjIzLjAwMjU4QTcuOTk2NzYsNy45OTY3NiwwLDAsMCwxLjQzNzMyLDIyLjU3Mjc3bDUuOTI0LTIuNDkyOTIsMi42MzM0Mi0xLjEwODE5LDUuODYzNTMtMi40Njc0NiwzLjA2MjEzLTEuMjg4NTlaIiBmaWxsPSIjMDA3OGQ0Ii8+PHBhdGggZD0iTTI1LjkzODc4LDEzLjAxNjM5QzI1Ljc5MzU4LDEzLjAwNjcsMjUuNjQ3NjQsMTMsMjUuNSwxM2E2LjQ3NjgsNi40NzY4LDAsMCwwLTIuNTc2NDguNTMxNzhsLS4wMDAxOC0uMDAwNjgtNC4wMDI5MywxLjY4NDUxLDEuMTYwNzcuNjk1MjhMMjMuODg2MTEsMTguMTlsMS42NjAwOS45OTQzOCw1LjY3NjMzLDMuNDAwMDdhNi41MDAyLDYuNTAwMiwwLDAsMC01LjI4Mzc1LTkuNTY4MDVaIiBmaWxsPSIjMTQ5MGRmIi8+PHBhdGggZD0iTTI1LjU0NjIsMTkuMTg0MzcsMjMuODg2MTEsMTguMTlsLTMuODA0OTMtMi4yNzkxLTEuMTYwNzctLjY5NTI4TDE1Ljg1ODI4LDE2LjUwNDIsOS45OTQ3NSwxOC45NzE2Niw3LjM2MTMzLDIwLjA3OTg1bC01LjkyNCwyLjQ5MjkyQTcuOTg4ODksNy45ODg4OSwwLDAsMCw4LDI2SDI1LjVhNi40OTgzNyw2LjQ5ODM3LDAsMCwwLDUuNzIyNTMtMy40MTU1NloiIGZpbGw9IiMyOGE4ZWEiLz48L2c+PC9zdmc+\n//===/Sharelist==\n\nconst { URL } = require('url')\n\nconst DEFAULT_ROOT_ID = 'root'\n\nconst UPLOAD_PART_SIZE = 4 * 1024 * 1024\n\nconst UPLOAD_PART_SIZE_LARGE = 16 * 1024 * 1024\n\nconst atob = v => Buffer.from(v, 'base64').toString()\n\nconst btoa = v => Buffer.from(v).toString('base64')\n\nconst supportZones = {\n  GLOBAL: ['https://login.microsoftonline.com', 'https://graph.microsoft.com', '国际版'],\n  CN: ['https://login.chinacloudapi.cn', 'https://microsoftgraph.chinacloudapi.cn', '世纪互联'],\n  DE: ['https://login.microsoftonline.de', 'https://graph.microsoft.de', 'Azure Germany'],\n  US: ['https://login.microsoftonline.us', 'https://graph.microsoft.us', 'Azure US GOV'],\n}\n\nconst qs = (d) => new URLSearchParams(d).toString()\n\nconst sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time))\n\nclass Manager {\n  static getInstance(app, config) {\n    if (!this.instance) {\n      this.instance = new Manager(app)\n    }\n\n    // this.instance.add(config)\n    return this.instance.createGetter(config, app)\n  }\n\n  constructor(app) {\n    this.app = app\n    this.keyMaps = {}\n  }\n\n  createGetter(config) {\n    //May be public client_id\n    let [basePart] = config.client_id.split('.')\n    if (this.keyMaps[config.client_id]) {\n      config.client_id = basePart + '.' + ('' + Math.random()).substring(2)\n    }\n    this.keyMaps[basePart] = 1\n    return async () => {\n      if (\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\n      ) {\n        await this.refreshAccessToken(config)\n      }\n      return {\n        ...config\n      }\n    }\n  }\n\n  getAuthority(zone = 'GLOBAL', tenant_id) {\n    return supportZones[zone][0] + '/' + (tenant_id || 'common')\n  }\n\n  getGraphEndpoint(zone = 'GLOBAL', site_id = false) {\n    return supportZones[zone][1] + '/v1.0' + (site_id ? `/sites/${site_id}` : '/me') + '/drive'\n  }\n\n  getGraphEndpointSite(zone = 'GLOBAL', site_name) {\n    //sites/' . getConfig('siteid') . '\n    return supportZones[zone][1] + '/v1.0/sites/root:/' + site_name\n  }\n\n  /**\n   * 从分享链接中解析 credentials\n   * access token 有效期 5h\n   *\n   * @param {object} config\n   * @param {object} { credentials }\n   * @api private\n   */\n  async refreshShareAccessToken(config) {\n    const {\n      request\n    } = this.app\n\n    const url = decodeURIComponent(config.share_url)\n\n    let { headers } = await request(url, {\n      responseType: 'text',\n      followRedirect: false,\n      headers: {\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36',\n      },\n    })\n\n    let cookie = headers['set-cookie']\n    let obj = new URL(headers['location'])\n    let origin = obj.origin\n    let rootFolder = obj.searchParams.get('id')\n    let account = rootFolder\n      .split(' ')[0]\n      .replace('/Shared', '')\n      .replace(/Documents.*?$/, '')\n\n    let query = {\n      a1: `'${rootFolder.replace(/(?<=Documents).*$/, '')}'`,\n      RootFolder: rootFolder,\n      TryNewExperienceSingle: 'TRUE',\n    }\n\n    let formdata = {\n      parameters: {\n        __metadata: { type: 'SP.RenderListDataParameters' },\n        RenderOptions: 1216519,\n        ViewXml:\n          '<View Name=\"{95F0CAAD-9DE2-4864-AE8D-33094C998625}\" DefaultView=\"TRUE\" MobileView=\"TRUE\" MobileDefaultView=\"TRUE\" Type=\"HTML\" ReadOnly=\"TRUE\" DisplayName=\"All\" Url=\"/personal/mengskysama_makedie_onmicrosoft_com/Documents/Forms/All.aspx\" Level=\"1\" BaseViewID=\"51\" ContentTypeID=\"0x\" ImageUrl=\"/_layouts/15/images/dlicon.png?rev=47\"><Query><OrderBy><FieldRef Name=\"FileLeafRef\"/></OrderBy></Query><ViewFields><FieldRef Name=\"DocIcon\"/><FieldRef Name=\"LinkFilename\"/><FieldRef Name=\"Modified\"/><FieldRef Name=\"SharedWith\"/><FieldRef Name=\"Editor\"/></ViewFields><RowLimit Paged=\"TRUE\">70</RowLimit><JSLink>clienttemplates.js</JSLink><XslLink Default=\"TRUE\">main.xsl</XslLink><Toolbar Type=\"Standard\"/></View>',\n        AllowMultipleValueFilterForTaxonomyFields: true,\n        AddRequiredFields: true,\n      },\n    }\n\n    let newurl = `${origin}${account}/_api/web/GetListUsingPath(DecodedUrl=@a1)/RenderListDataAsStream?@${qs(query)}`;\n\n    let { data } = await request.post(newurl, {\n      data: formdata,\n      headers: {\n        origin,\n        cookie,\n        accept: 'application/json;odata=verbose',\n        'content-type': 'application/json;odata=verbose',\n      },\n    })\n\n\n    if (data?.error) {\n      return this.app.error({ message: data.error.message.value })\n    }\n\n    if (!data?.ListSchema['.driveAccessToken']) {\n      return this.app.error({ message: '请将分享文件夹设置[拥有链接的任何人都可编辑] / The shared folder must be given editing permissions' })\n    }\n\n    let access_token = data['ListSchema']['.driveAccessToken'].replace('access_token=', '')\n    let graph = data['ListSchema']['.driveUrl']\n    let expires_at = parseInt(JSON.parse(atob(access_token.split('.')[1]))['exp']) * 1000\n\n    config.access_token = access_token\n    config.expires_at = expires_at\n    config.graph = graph\n\n    config.key = btoa(decodeURIComponent(url))\n  }\n\n  /**\n   * 刷新令牌 / refresh token\n   *\n   * @param {object} credentials\n   * @param {object} { credentials: object } | { error:true, message:string }\n   * @api private\n   */\n  async refreshAccessToken(credentials) {\n    let { client_id, client_secret, redirect_uri, refresh_token, zone, tenant_id, type, ...rest } =\n      credentials\n    if (type == 'sharelink') {\n      return await this.refreshShareAccessToken(credentials)\n    }\n\n    if (!(client_id && client_secret && refresh_token)) {\n      return { error: { message: 'Invalid parameters: An error occurred during refresh access token' } }\n    }\n\n    let formdata = {\n      client_id: client_id.split('.')[0],\n      client_secret,\n      redirect_uri,\n      refresh_token,\n      grant_type: 'refresh_token',\n    }\n    let metadata = this.getAuthority(zone, tenant_id)\n    let { data } = await this.app.request.post(`${metadata}/oauth2/v2.0/token`, { data: formdata, contentType: 'form' })\n\n    if (data.error) {\n      return this.app.error({ message: data.error_description || data.error })\n    }\n\n    let expires_at = data.expires_in * 1000 + Date.now()\n\n    credentials.graph = this.getGraphEndpoint(data.zone, data.site_id)\n    credentials.refresh_token = data.refresh_token\n    credentials.access_token = data.access_token\n    credentials.expires_at = expires_at\n  }\n\n}\n\nconst mountData = () => {\n  let zone = Object.entries(supportZones).map(([key, value]) => {\n    return {\n      value: key,\n      label: value[2],\n    }\n  })\n\n  return [\n    {\n      key: 'type',\n      label: 'OneDrive 挂载类型',\n      type: 'string',\n      required: true,\n      options: [\n        { value: 'onedrive', label: 'OneDrive' },\n        { value: 'sharepoint', label: 'SharePoint' },\n        { value: 'sharelink', label: 'Share Link / 分享链接' },\n      ],\n      fields: [\n        [\n          { key: 'zone', label: '地域', type: 'string', options: zone, required: true },\n          { key: 'client_id', label: '应用ID / Client ID', required: true },\n          { key: 'client_secret', label: '应用机密 / App Secret', type: 'string', required: true },\n          { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\n          { key: 'refresh_token', label: '刷新令牌 / Refresh Token', required: true },\n          { key: 'tenant_id', label: '租户ID / Tenant ID' },\n          { key: 'root_id', label: '初始目录ID' },\n        ],\n        [\n          { key: 'zone', label: '地域', type: 'string', options: zone, required: true },\n          { key: 'client_id', label: '应用ID / Client ID', required: true },\n          { key: 'client_secret', label: '应用机密 / App Secret', type: 'string', required: true },\n          { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\n          { key: 'refresh_token', label: '刷新令牌 / Refresh Token', required: true },\n          { key: 'site_id', label: 'SharePoint 站点ID / Site ID', type: 'string' },\n          { key: 'tenant_id', label: '租户ID / Tenant ID', type: 'string' },\n          { key: 'root_id', label: '初始目录ID', type: 'string' },\n        ],\n        [\n          { key: 'share_url', label: '分享链接URL', type: 'string', required: true },\n          { key: 'root_id', label: '初始目录ID', type: 'string' },\n        ],\n      ],\n    },\n  ]\n}\n\n\nclass Driver {\n  static options = {\n    protocol: \"onedrive\",\n\n    //支持全局搜索\n    //searchDepth: 1,\n    globalSearch: true,\n    localSearch: false,\n\n    key: 'client_id',\n    defaultRoot: DEFAULT_ROOT_ID,\n    guide: mountData()\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.getConfig = Manager.getInstance(app, config)\n  }\n\n  /**\n   * Lists or search files\n   *\n   * @param {string} [id] folder id\n   * @param {object} [options] list options\n   * @param {object} [options.sort] sort methods\n   * @param {object} [options.search] search key\n   * @return {object | error}\n   *\n   * @api public\n   *\n   * docs: https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_list_children?view=odsp-graph-online\n   * docs: https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/resources/driveitem\n   * \n   * TODO: there are two methods for request\n   * With a known id:  GET /{drive-id}/items/{item-id}/children\n   * With a known path: GET /{drive-id}/root:/{path-relative-to-root}:/children\n   * \n   * Search Drive Root: GET /root/search(q='{search-text}')\n   * Search Dir : GET /items/{item-id}/search(q='text')\n   */\n  async list(id, { search, orderBy, perPage, nextPage }) {\n    let { graph, access_token } = await this.getConfig()\n\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n\n    let usePagination = !!perPage\n\n    // https://makedie-my.sharepoint.com/_api/v2.0/drives/b!0JNeDoFvlUSa2fAugQnhNBuZYcN0WQJPrYD8Vq2FUAfsmI8YwdGNQ5zG5mhlt3sY\n\n    let url = graph + `${id == DEFAULT_ROOT_ID ? '/root/' : `/items/${id}/`}` + `${search ? `search(q='${encodeURIComponent(search)}')` : 'children'}`\n\n    if (search) console.log('search', url)\n    let params = {\n      $select:\n        'id,name,size,file,folder,parentReference,@microsoft.graph.downloadUrl,thumbnails,createdDateTime,lastModifiedDateTime',\n      $expand: 'thumbnails',\n    }\n\n    // TODO: Note that in OneDrive for Business and SharePoint Server 2016, the orderby query string only works with name and url.\n    if (orderBy) {\n      let [sortKey, sortType] = orderBy\n      sortKey = sortKey == 'mtime' ? 'lastModifiedDateTime' : sortKey\n      params.$orderby = sortKey + ' ' + (sortType ? 'asc' : 'desc')\n    }\n\n    // set per page\n    params.$top = usePagination ? perPage : 1000\n\n    let skipToken = nextPage, files = []\n\n    do {\n      let { data } = await request.get(url, {\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: { ...params, ...(skipToken ? { '$skipToken': skipToken } : {}) },\n      })\n\n      if (data.error) this.app.error({ message: data.error.message })\n\n      //extract token from @odata.nextLink\n      skipToken = data['@odata.nextLink']?.match(/skiptoken=([a-z0-9A-Z!_]+)/i)?.[1]\n      data.value.forEach((i) => {\n        let item = {\n          id: i.id,\n          name: i.name,\n          type: i.folder ? 'folder' : 'file',\n          size: i.size,\n          ctime: timestamp(i.createdDateTime),\n          mtime: timestamp(i.lastModifiedDateTime),\n          thumb: i.thumbnails.length > 0 ? i.thumbnails[0].medium.url : '',\n          extra: {\n            fid: i.id,\n            parent_id: id //i.parentReference?.id,\n          },\n        }\n        if (i.file) {\n          if (i.file.hashes?.sha1Hash) {\n            item.extra.sha1 = i.file.hashes.sha1Hash.toLowerCase()\n          }\n          item.extra.mime = i.file.mimeType\n          item.download_url = i['@microsoft.graph.downloadUrl'] || i['@content.downloadUrl']\n        } else if (i.folder) {\n          item.extra.child_count = i.folder.childCount\n        }\n        files.push(item)\n      })\n\n    } while (!usePagination && skipToken)\n\n\n    let result = {\n      id, files\n    }\n\n    if (usePagination && skipToken) {\n      result.nextPage = skipToken\n    }\n\n    return result\n  }\n\n\n  /**\n   * get file\n   *\n   * @param {string} [id] file id\n   * @param {string} [key] key\n   * @return {object}\n   *\n   * @api public\n   */\n  async get(id) {\n    let { graph, access_token } = await this.getConfig()\n\n    const {\n      request,\n      utils: { timestamp },\n    } = this.app\n    let url = `${graph}/items/${id}`\n\n    let { data, error } = await request(url, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        $expand: 'thumbnails',\n      },\n    })\n\n    if (error) return { error: error }\n\n    if (data.error) return { error: data.error.message }\n    let result = {\n      id: data.id,\n      name: data.name,\n      type: data.folder ? 'folder' : 'file',\n      size: data.size,\n      ctime: timestamp(data.createdDateTime),\n      mtime: timestamp(data.lastModifiedDateTime),\n      download_url: data['@microsoft.graph.downloadUrl'] || data['@content.downloadUrl'],\n      thumb: data.thumbnails.length > 0 ? data.thumbnails[0].medium.url : '',\n      // the download link expires after 3600s\n      max_age: 3600 * 1000,\n      extra: {\n        fid: data.id,\n        parent_id: data.parentReference.path ? (data.parentReference.path.endsWith('root:') ? DEFAULT_ROOT_ID : data.parentReference?.id) : DEFAULT_ROOT_ID,\n        path: data.parentReference ? data.parentReference.path.split('root:')[1] : '',\n      },\n    }\n\n    if (data.file) {\n      if (data.file.hashes?.sha1Hash) {\n        result.extra.sha1 = data.file.hashes?.sha1Hash.toLowerCase()\n      }\n      result.extra.mime = data.file.mimeType\n    } else if (data.folder) {\n      result.extra.child_count = i.folder.childCount\n    }\n\n    return result\n  }\n\n  /**\n   * create folder\n   *\n   * @param {string} [parent_id] folder id\n   * @param {string} [name] folder name\n   * @param {object} [options] options\n   * @param {object} [options.conflictBehavior] \n   * @return {object}\n   *\n   * @api public\n   */\n  async mkdir(parent_id, name, { conflictBehavior = 'rename' }) {\n    let { graph, access_token } = await this.getConfig()\n    let url = graph + `${parent_id == DEFAULT_ROOT_ID ? '/root' : `/items/${parent_id}`}` + '/children'\n    let { data } = await this.app.request.post(url, {\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        name,\n        \"folder\": {},\n        \"@microsoft.graph.conflictBehavior\": \"rename\"\n      },\n      contentType: 'json',\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name,\n      parent_id\n    }\n  }\n\n  /**\n   * rename file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [name] folder name\n   * @param {object} [options] options\n   * @param {object} [options.check_name_mode] \n   * @param {string} [key] key\n   * @return {object}\n   *\n   * @api public\n   */\n  async rename(id, name, { check_name_mode = 'rename' }) {\n    let { graph, access_token } = await this.getConfig()\n    let url = graph + (id == DEFAULT_ROOT_ID ? '/root' : `/items/${id}`)\n\n    let { data } = await this.app.request(url, {\n      method: 'patch',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: {\n        name\n      },\n      contentType: 'json',\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n    return {\n      id: data.id,\n      name,\n    }\n  }\n\n  /**\n   * remove file/folder\n   *\n   * @param {string} [id] id\n   * @param {string} [key] key\n   * @return {object}\n   *\n   * @api public\n   */\n  async rm(id) {\n    let { graph, access_token } = await this.getConfig()\n    let filedata = await this.get(id)\n    let url = graph + `/items/${id}`\n\n    let { data, status } = await this.app.request(url, {\n      method: 'delete',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      responseType: 'text'\n    })\n\n    if (status == 204) {\n      return {\n        id,\n        parent_id: filedata.extra.parent_id\n      }\n    } else {\n      data = JSON.parse(data)\n      return this.app.error({ message: data?.error?.message, code: status })\n    }\n\n  }\n\n  /**\n   * move file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [target_id] dest folder\n   * @param {string} [key] key\n   * @return {object}\n   *\n   * @api public\n   */\n  async mv(id, target_id, { copy, name } = {}) {\n\n    if (copy) return await this.copy(id, target_id, { name })\n\n    let { graph, access_token } = await this.getConfig()\n\n    let dest = {\n      parentReference: {\n        id: target_id || DEFAULT_ROOT_ID\n      }\n    }\n    if (name) dest.name = name\n\n    let { data } = await this.app.request(`${graph}/items/${id}`, {\n      method: 'patch',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: dest,\n      contentType: 'json',\n    })\n\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return {\n      id: data.id,\n      name: data.name,\n    }\n  }\n\n  /**\n   * copy file/folder\n   *\n   * @param {string} [id] folder id\n   * @param {string} [target_id] dest folder\n   * @param {string} [key] key\n   * @return {object}\n   *\n   * @api public\n   */\n  async copy(id, target_id, { name } = {}) {\n    //POST /users/{userId}/drive/items/{itemId}/copy\n    let { graph, access_token } = await this.getConfig()\n    let url = graph + `/items/${id}/copy`\n\n    //TODO: It can NOT use the \"id:root\" when copy items to the root of a OneDrive, use {\"path\": \"/drive/root\"} instead.\n    let dest = {\n      parentReference: target_id == DEFAULT_ROOT_ID ? { path: '/drive/root' } : { id: target_id }\n    }\n\n    if (name) dest.name = name\n\n    let { data, headers, status } = await this.app.request(url, {\n      method: 'post',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n      },\n      data: dest,\n      contentType: 'json',\n      responseType: 'text'\n    })\n\n\n    if (status != 202) {\n      return this.app.error(JSON.parse(data)?.error.message)\n    }\n\n    let monitorUrl = headers.location\n\n    let result = await this.monitor(monitorUrl)\n\n    if (result?.id) {\n      return {\n        id: result.id,\n        name: data.name,\n        parent: target_id,\n      }\n    } else {\n      return this.app.error({ message: 'Task has been accepted, but monitor returned no result.' })\n    }\n\n  }\n\n  async singleUpload(id, { size, name, stream, ...rest }) {\n    let { graph, access_token } = await this.getConfig()\n    let url = `${graph}${id == DEFAULT_ROOT_ID ? '/root' : `/items/${id}`}:/${encodeURIComponent(name)}:/content`\n    // console.log(url)\n    let { data } = await this.app.request(url, {\n      method: 'put',\n      headers: {\n        Authorization: `Bearer ${access_token}`,\n        'content-type': 'application/octet-stream'\n      },\n      data: stream,\n      contentType: 'stream',\n    })\n    if (data.error) return this.app.error({ message: data.error.message })\n\n    return { id: data.id, name: data.name, parent_id: id }\n  }\n\n  async beforeUpload(uploadId, { id, name, size, conflictBehavior }) {\n    let uploadUrl, start = 0\n    let { app } = this\n    //resume upload\n    if (uploadId) {\n      uploadUrl = atob(uploadId)\n      let { data } = await app.request(uploadUrl)\n      if (data.error) app.error({ message: data.error.message })\n      //upload session has expired.\n      if (data.expirationDateTime && Date.now() - new Date(data.expirationDateTime) > 0) {\n        uploadUrl = ''\n      } else {\n        start = +data.nextExpectedRanges[0].split('-')[0]\n      }\n    }\n\n    // create new upload session\n    if (!uploadUrl) {\n      let { graph, access_token } = await this.getConfig()\n      let { data } = await app.request(graph + (id == DEFAULT_ROOT_ID ? '/root' : `/items/${id}`) + `:/${encodeURIComponent(name)}:/` + '/createUploadSession', {\n        method: 'post',\n        headers: {\n          Authorization: `Bearer ${access_token}`,\n        },\n        data: {\n          item: {\n            \"@microsoft.graph.conflictBehavior\": \"rename\",\n            // name\n          }\n        },\n        contentType: 'json',\n      })\n      if (data.error) return app.error({ message: data.error.message })\n      uploadUrl = data.uploadUrl\n      start = 0\n    }\n\n    return {\n      uploadUrl, start, uploadId: btoa(uploadUrl)\n    }\n\n  }\n\n\n  /**\n   * upload file\n   * doc: https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_createuploadsession?view=odsp-graph-online\n   *\n   * @param {string} [id] folder id\n   * @param {object} [options] upload file meta\n   * @param {number} [options.size] upload file size\n   * @param {string} [options.name] upload file name\n   * @param {ReadableStream} [options.stream] upload file stream\n   * @param {object} [credentials] credentials\n   * @return {string | error}\n   * \n   * @api public\n   */\n  async upload(id, stream, { size, name, manual, conflictBehavior, ...rest }) {\n\n    const app = this.app\n\n    let { uploadId, uploadUrl, start } = await this.beforeUpload(rest.uploadId, { id, name, size, conflictBehavior })\n\n    if (!stream) {\n      return { uploadId, start }\n    }\n\n    let retries = rest.retries || 3\n\n    while (retries-- > 0) {\n\n      let readStream = (typeof stream == 'function') ? await stream(start, { uploadId }) : stream\n\n      if (readStream === undefined) return\n      let res = await app.request(uploadUrl, {\n        method: 'put',\n        data: readStream,\n        contentType: 'stream',\n        signal: rest.signal,\n        // responseType: 'text',\n        headers: {\n          'Content-Range': `bytes ${start}-${size - 1}/${size}`,\n          'Content-Length': size - start,\n        }\n      })\n\n      if (res.status != 201 && res.status != 202) {\n        // 500 502 503 504 retry\n        if (+res.status >= 500) {\n          await sleep(app.utils.retryTime(3 - retries))\n          continue\n        } else {\n          return this.app.error({ message: res.data?.error?.message || ('An error occurred during upload: ' + name) })\n        }\n      }\n\n      return {\n        id: res.data.id,\n        name: res.data.name,\n        parent_id: id\n      }\n\n    }\n\n  }\n\n\n  async monitor(url, timeout = 8 * 1000) {\n    console.log('[monitor]', url)\n    let startTime = Date.now()\n\n    while (Date.now() - startTime < timeout) {\n      let { data } = await this.app.request.get(url, { responseType: 'json' })\n\n      if (data?.status == 'completed') {\n        return { id: data.resourceId }\n      }\n\n      await sleep(200)\n    }\n\n  }\n}\n\nmodule.exports = { driver: Driver }\n"},{"hash":"c7cb506365d9d867233a56eef76916c9","name":"VirtualDrive","namespace":"sharelist.plugin.vdrive","version":"1.0.0","license":"MIT","description":"sharelist 内置的虚拟网盘，使用yaml/json进行描述。","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/vdrive/index.js","script":"//===Sharelist===\n// @name         VirtualDrive\n// @namespace    sharelist.plugin.vdrive\n// @version      1.0.0\n// @license      MIT\n// @description  sharelist 内置的虚拟网盘，使用yaml/json进行描述。\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/vdrive/index.js\n//===/Sharelist==\nconst yaml = require('yaml')\n\nconst { URL } = require('url')\n\nconst crypto = require('crypto')\n\nconst fs = require('fs')\n\nconst os = require('os')\n\nconst md5 = (v) => {\n  return crypto.createHash('md5').update(v).digest('hex')\n}\nconst decode = v => decodeURIComponent(Buffer.from(v, 'base64').toString())\n\nconst encode = v => Buffer.from(encodeURIComponent(v)).toString('base64')\n\nconst isWinOS = os.platform() == 'win32'\n\nconst winStyle = (p) =>\n  p\n    .replace(/^\\/([^\\/]+?)/, '$1:\\\\')\n    .replace(/\\//g, '\\\\')\n    .replace(/(?<!\\:)\\\\+$/, '')\n    .replace(/\\\\{2,}/g, '\\\\')\n\nconst ospath = (p, base = '') => {\n  p = base + p\n  return isWinOS ? winStyle(p) : (p)\n}\n\nconst diskMap = {}\nconst parse = (id) => {\n  let data = new URL(id)\n\n  let rootId = data.hostname\n  let path = data.pathname.replace(/^\\/+/, '').split('/')\n  return {\n    disk: diskMap[rootId],\n    path,\n  }\n}\nclass Driver {\n  static options = {\n    globalSearch: false,\n    localSearch: true,\n    protocol: \"vdrive\",\n    cache: false,\n    pagination: false,\n    guide: [\n      { key: 'src', label: '目录地址', type: 'string', help: '可指定远程地址(HTTP/HTTPS协议) 或者 本地文件(posix风格)', required: true },\n    ],\n  }\n\n  constructor(app, config) {\n    this.app = app\n    this.config = config\n  }\n\n  async getRoot() {\n    if (!this.key) {\n      let rootId = this.config.src\n      let key = md5(rootId)\n      this.key = key\n      diskMap[key] = {\n        id: rootId\n      }\n\n      if (/^https?/i.test(rootId)) {\n        let res = await this.app.request(rootId, {\n          responseType: 'text'\n        })\n        let json = yaml.parse(res)\n        diskMap[key].data = json\n      } else {\n        try {\n          let res = fs.readFileSync(ospath(rootId), { encoding: 'utf-8' })\n          let json = yaml.parse(res)\n          diskMap[key].data = json\n        } catch (e) {\n          console.log(e)\n          throw { message: 'can not read rootId' }\n        }\n      }\n    }\n\n    return { children: diskMap[this.key].data }\n  }\n\n  async list(id, { search, orderBy } = {}) {\n    let disk = await this.getRoot()\n\n    id = id || 'root'\n\n    let path = id == 'root' ? [] : id.split('/').filter(Boolean).map(decode)\n    if (disk) {\n      for (let i = 0; i < path.length && disk; i++) {\n        if (!disk.children) {\n          throw { code: 404 }\n        }\n        disk = disk.children.find((j) => j.name == decodeURIComponent(path[i])) //[ parseInt(path[i]) ]\n      }\n      let isDir = (disk.children && !disk.url)\n\n      if (isDir) {\n        return {\n          id,\n          files: disk.children.map(i => ({\n            id: [...path, i.name].map(encode).join('/'),\n            name: i.name,\n            type: (i.children && !i.url) ? 'folder' : 'file',\n            size: i.size || 0,\n          }))\n        }\n      }\n\n    }\n\n    throw { code: 404 }\n\n  }\n\n  async get(id) {\n    if (!id) {\n      return {\n        id: '@drive_root',\n        name: '@drive_root'\n      }\n    }\n\n    let disk = await this.getRoot()\n\n    let path = id.split('/').filter(Boolean).map(decode)\n    if (disk) {\n      for (let i = 0; i < path.length && disk; i++) {\n        disk = disk.children.find((j) => j.name == path[i]) //[ parseInt(path[i]) ]\n      }\n\n      return {\n        id,\n        name: disk.name,\n        size: disk.size,\n        type: (disk.children && !disk.url) ? 'folder' : 'file',\n        ctime: Date.now(),\n        mtime: Date.now(),\n        download_url: disk.url,\n        extra: {\n          parent_id: path.slice(0, -1).filter(Boolean).map(encode).join('/')\n        }\n      }\n    }\n\n    throw { code: 404 }\n  }\n}\n\nmodule.exports = { driver: Driver }\n"},{"hash":"efc5535da20ddea45083391776ee8e48","name":"⚡️XV⚡️","namespace":"sharelist.plugin.xv","version":"0.1.0","license":"MIT","description":"For mounting a top-10 globally visited website","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/xv/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMjUiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDU4NCAxNDkiPgogIDxwYXRoIHN0cm9rZS13aWR0aD0iLjA0NCIgZD0iTS40MzQuNzAzaDk5LjIwN3YyMy44MjRILjQzNHoiLz4KICA8cGF0aCBkPSJNMTEuMDY3IDkuODkzbDIuNjY2LTUuNDU3aDQuMzRsLTQuNjM1IDguMDE1IDQuOTkyIDguMTU0aC00LjU1N2wtMi43Ni01LjU2NS0yLjc2IDUuNTY1aC00LjM0bDQuNzYtOC4xNTQtNC42MzYtOC4wMTVoNC4yOTR6IiBmaWxsPSIjZGUyNjAwIi8+CiAgPHBhdGggZD0iTTc0LjMgNC4xODhjLTIuMDQ2IDAtMy43MDQuNjM3LTQuOTc2IDEuOTM5LTEuMjcxIDEuMzAyLTEuOTA2IDIuOTQzLTEuOTA2IDQuOTI4djIuOTE2YzAgMiAuNjM1IDMuNjQzIDEuOTA2IDQuOTMgMS4yNzIgMS4yODYgMi45NDYgMS45MzcgNC45OTIgMS45MzcgMi4wMzEgMCAzLjY5LS42NTEgNC45NDYtMS45MzggMS4yNTYtMS4zMDIgMS44OS0yLjkzIDEuODktNC45M2guMDE2di0yLjkxNWMwLTItLjYzNS0zLjYyNi0xLjkwNi00LjkyOC0xLjI4Ny0xLjI4Ny0yLjkzLTEuOTQtNC45NjEtMS45NHptMTUuMDA3LjAxNWMtMS43OTggMC0zLjI4Ny40Mi00LjQ2NSAxLjI1Ni0xLjE3OC44MzctMS43NjggMS45MzktMS43NjggMy4yODcgMCAxLjM5NS40ODEgMi40NSAxLjQ3MyAzLjE5My45NzcuNzQ1IDIuNDk3IDEuNDI3IDQuNTQzIDIuMDc5Ljk3Ny4zNTYgMS42NTkuNjgyIDIuMDMxLjk5Mi4zODcuMzEuNTc0Ljc0My41NzQgMS4zMTYgMCAuNDk3LS4yMDIuOS0uNTU4IDEuMjI1LS4zNzIuMzEtLjk2Mi40NjUtMS43MzcuNDY1LTEuMDIzIDAtMS43OTgtLjItMi4yOTUtLjYwNC0uNTExLS40MDMtLjc2LTEuMDctLjc2LTJoLTMuNjU3bC0uMDE2LjA2M2MtLjA0NyAxLjczNi42MiAzLjA3IDEuOTUzIDMuOTg0IDEuMzMzLjkxNSAyLjkxNSAxLjM3OSA0Ljc2IDEuMzc5IDEuODMgMCAzLjMwMS0uNDAyIDQuNDAyLTEuMjEgMS4xLS43OSAxLjY1OC0xLjkwNyAxLjY1OC0zLjMzMyAwLTEuMzk2LS40NjQtMi40OTYtMS4zOTQtMy4zMDMtLjkzLS43OS0yLjMxLTEuNDctNC4xNTUtMi4wMTMtMS4xOTQtLjQzNS0xLjk5OS0uNzkyLTIuNDMzLTEuMDctLjQzNC0uMjgtLjY1Mi0uNjUyLS42NTItMS4xMzIgMC0uNDk2LjIxOC0uOTE1LjY1Mi0xLjI0LjQzNC0uMzI2IDEuMDIyLS40OTYgMS43ODEtLjQ5Ni43NzUgMCAxLjM4LjIgMS44MTUuNjA0LjQzNC40MDMuNjUyLjkxNS42NTIgMS41NjZoMy42NDNsLjAxNS0uMDYzYy4wNDctMS40NTctLjUxMy0yLjY1LTEuNjYtMy41NjQtMS4xNDctLjkxNS0yLjYwNC0xLjM4LTQuNDAyLTEuMzh6bS0zNC4yNDQuMjMzdjE2LjE3SDY2LjN2LTIuODgzaC03LjQ3VjEzLjY5aDYuMzM5di0yLjloLTYuMzQydi0zLjQ3aDcuNTA0VjQuNDM1aC0xMS4yN3ptLTM2Ljc3Mi4wMDJsNS4yMjUgMTYuMTgzaDQuMDZsNS4yNC0xNi4xODNIMjguODhsLTMuMjEgMTEuODI2LS4xMDguNTQzSDI1LjVsLS4xMS0uNTg4TDIyLjIzIDQuNDM4SDE4LjI5em0xNS44MTMgMHYxNi4xNjdoMy43NTFWNC40MzhoLTMuNzUxem02LjMwOCAwdjE2LjE4MWg1Ljg0NmMxLjkwNiAwIDMuNDg2LS42MiA0Ljc3My0xLjg2IDEuMjg4LTEuMjM5IDEuOTI0LTIuODIgMS45MjQtNC43NzNWMTEuMDdjMC0xLjkzNy0uNjM3LTMuNTMzLTEuOTI0LTQuNzczLTEuMjcxLTEuMjQtMi44NjctMS44Ni00Ljc3My0xLjg2aC01Ljg0NnptMzMuODU4IDIuNjVjLjk5MiAwIDEuNzY3LjM3IDIuMzEgMS4xMTUuNTQzLjcyOS44MiAxLjY3NS44MiAyLjgzOGwuMDAyIDIuOTNjMCAxLjE3OC0uMjY0IDIuMTIyLS44MDYgMi44NjctLjU0My43NDQtMS4zMDMgMS4xMTctMi4yOTUgMS4xMTctMS4wMjMgMC0xLjgtLjM3My0yLjM0Mi0xLjExN3MtLjgyLTEuNzA1LS44Mi0yLjg2N3YtMi45M2MwLTEuMTYzLjI2My0yLjEwOS44MDYtMi44NTMuNTI3LS43MyAxLjMxNy0xLjEgMi4zMjUtMS4xem0tMzAuMDkuMjQ2aDEuODNjLjk5MiAwIDEuNzgxLjM0MSAyLjM0IDEuMDIzLjU1OC42ODMuODM4IDEuNTgxLjgzOCAyLjY5OHYyLjkzMWMwIDEuMTE2LS4yOCAyLjAzMS0uODM4IDIuNzEzLS41NTkuNjgyLTEuMzMzIDEuMDIyLTIuMzQgMS4wMjJoLTEuODNWNy4zMzR6IiBmaWxsPSIjZmZmIiBzdHJva2Utd2lkdGg9Ii4yMTkiLz4KPC9zdmc+Cg==","script":"//===Sharelist===\n// @name         ⚡️XV⚡️\n// @namespace    sharelist.plugin.xv\n// @version      0.1.0\n// @license      MIT\n// @description  For mounting a top-10 globally visited website\n// @author       reruin@gmail.com\n// @supportURL   https://github.com/reruin/sharelist\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/xv/index.js\n// @icon         data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMjUiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDU4NCAxNDkiPgogIDxwYXRoIHN0cm9rZS13aWR0aD0iLjA0NCIgZD0iTS40MzQuNzAzaDk5LjIwN3YyMy44MjRILjQzNHoiLz4KICA8cGF0aCBkPSJNMTEuMDY3IDkuODkzbDIuNjY2LTUuNDU3aDQuMzRsLTQuNjM1IDguMDE1IDQuOTkyIDguMTU0aC00LjU1N2wtMi43Ni01LjU2NS0yLjc2IDUuNTY1aC00LjM0bDQuNzYtOC4xNTQtNC42MzYtOC4wMTVoNC4yOTR6IiBmaWxsPSIjZGUyNjAwIi8+CiAgPHBhdGggZD0iTTc0LjMgNC4xODhjLTIuMDQ2IDAtMy43MDQuNjM3LTQuOTc2IDEuOTM5LTEuMjcxIDEuMzAyLTEuOTA2IDIuOTQzLTEuOTA2IDQuOTI4djIuOTE2YzAgMiAuNjM1IDMuNjQzIDEuOTA2IDQuOTMgMS4yNzIgMS4yODYgMi45NDYgMS45MzcgNC45OTIgMS45MzcgMi4wMzEgMCAzLjY5LS42NTEgNC45NDYtMS45MzggMS4yNTYtMS4zMDIgMS44OS0yLjkzIDEuODktNC45M2guMDE2di0yLjkxNWMwLTItLjYzNS0zLjYyNi0xLjkwNi00LjkyOC0xLjI4Ny0xLjI4Ny0yLjkzLTEuOTQtNC45NjEtMS45NHptMTUuMDA3LjAxNWMtMS43OTggMC0zLjI4Ny40Mi00LjQ2NSAxLjI1Ni0xLjE3OC44MzctMS43NjggMS45MzktMS43NjggMy4yODcgMCAxLjM5NS40ODEgMi40NSAxLjQ3MyAzLjE5My45NzcuNzQ1IDIuNDk3IDEuNDI3IDQuNTQzIDIuMDc5Ljk3Ny4zNTYgMS42NTkuNjgyIDIuMDMxLjk5Mi4zODcuMzEuNTc0Ljc0My41NzQgMS4zMTYgMCAuNDk3LS4yMDIuOS0uNTU4IDEuMjI1LS4zNzIuMzEtLjk2Mi40NjUtMS43MzcuNDY1LTEuMDIzIDAtMS43OTgtLjItMi4yOTUtLjYwNC0uNTExLS40MDMtLjc2LTEuMDctLjc2LTJoLTMuNjU3bC0uMDE2LjA2M2MtLjA0NyAxLjczNi42MiAzLjA3IDEuOTUzIDMuOTg0IDEuMzMzLjkxNSAyLjkxNSAxLjM3OSA0Ljc2IDEuMzc5IDEuODMgMCAzLjMwMS0uNDAyIDQuNDAyLTEuMjEgMS4xLS43OSAxLjY1OC0xLjkwNyAxLjY1OC0zLjMzMyAwLTEuMzk2LS40NjQtMi40OTYtMS4zOTQtMy4zMDMtLjkzLS43OS0yLjMxLTEuNDctNC4xNTUtMi4wMTMtMS4xOTQtLjQzNS0xLjk5OS0uNzkyLTIuNDMzLTEuMDctLjQzNC0uMjgtLjY1Mi0uNjUyLS42NTItMS4xMzIgMC0uNDk2LjIxOC0uOTE1LjY1Mi0xLjI0LjQzNC0uMzI2IDEuMDIyLS40OTYgMS43ODEtLjQ5Ni43NzUgMCAxLjM4LjIgMS44MTUuNjA0LjQzNC40MDMuNjUyLjkxNS42NTIgMS41NjZoMy42NDNsLjAxNS0uMDYzYy4wNDctMS40NTctLjUxMy0yLjY1LTEuNjYtMy41NjQtMS4xNDctLjkxNS0yLjYwNC0xLjM4LTQuNDAyLTEuMzh6bS0zNC4yNDQuMjMzdjE2LjE3SDY2LjN2LTIuODgzaC03LjQ3VjEzLjY5aDYuMzM5di0yLjloLTYuMzQydi0zLjQ3aDcuNTA0VjQuNDM1aC0xMS4yN3ptLTM2Ljc3Mi4wMDJsNS4yMjUgMTYuMTgzaDQuMDZsNS4yNC0xNi4xODNIMjguODhsLTMuMjEgMTEuODI2LS4xMDguNTQzSDI1LjVsLS4xMS0uNTg4TDIyLjIzIDQuNDM4SDE4LjI5em0xNS44MTMgMHYxNi4xNjdoMy43NTFWNC40MzhoLTMuNzUxem02LjMwOCAwdjE2LjE4MWg1Ljg0NmMxLjkwNiAwIDMuNDg2LS42MiA0Ljc3My0xLjg2IDEuMjg4LTEuMjM5IDEuOTI0LTIuODIgMS45MjQtNC43NzNWMTEuMDdjMC0xLjkzNy0uNjM3LTMuNTMzLTEuOTI0LTQuNzczLTEuMjcxLTEuMjQtMi44NjctMS44Ni00Ljc3My0xLjg2aC01Ljg0NnptMzMuODU4IDIuNjVjLjk5MiAwIDEuNzY3LjM3IDIuMzEgMS4xMTUuNTQzLjcyOS44MiAxLjY3NS44MiAyLjgzOGwuMDAyIDIuOTNjMCAxLjE3OC0uMjY0IDIuMTIyLS44MDYgMi44NjctLjU0My43NDQtMS4zMDMgMS4xMTctMi4yOTUgMS4xMTctMS4wMjMgMC0xLjgtLjM3My0yLjM0Mi0xLjExN3MtLjgyLTEuNzA1LS44Mi0yLjg2N3YtMi45M2MwLTEuMTYzLjI2My0yLjEwOS44MDYtMi44NTMuNTI3LS43MyAxLjMxNy0xLjEgMi4zMjUtMS4xem0tMzAuMDkuMjQ2aDEuODNjLjk5MiAwIDEuNzgxLjM0MSAyLjM0IDEuMDIzLjU1OC42ODMuODM4IDEuNTgxLjgzOCAyLjY5OHYyLjkzMWMwIDEuMTE2LS4yOCAyLjAzMS0uODM4IDIuNzEzLS41NTkuNjgyLTEuMzMzIDEuMDIyLTIuMzQgMS4wMjJoLTEuODNWNy4zMzR6IiBmaWxsPSIjZmZmIiBzdHJva2Utd2lkdGg9Ii4yMTkiLz4KPC9zdmc+Cg==\n//===/Sharelist==\n\nconst HOST = Buffer.from('aHR0cHM6Ly93d3cueHZpZGVvcy5jb20=', 'base64').toString();\n\nconst decode = v => Buffer.from(v, 'base64').toString()\n\nconst encode = v => Buffer.from(v).toString('base64')\n\nconst re = v => v.split('').reverse().join('')\n\nconst UA = `Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36`\n\nconst getListUrl = (id, sk, page = 1) => {\n  let tag = id != '@' ? decode(id) : ''\n  let key\n  if (sk) {\n    key = `/?k=${sk}&p=${page}`\n  }\n  else if (tag.startsWith('/' + re('nrop')) || tag.startsWith('/lang')) {\n    key = tag + '/' + page\n  }\n  else if (/^\\/c\\//.test(tag)) {\n    key = tag + '/' + page\n  }\n  else if (/^\\/\\?k=/.test(tag)) {\n    key = tag + '&p=' + page\n  }\n  else {\n    key = '/new/' + page\n  }\n  return HOST + key\n}\n\nclass Driver {\n\n  static options = {\n    globalSearch: true,\n    localSearch: false,\n    protocol: \"xv\",\n    cache: false,\n    readonly: true,\n    guide: [\n      { key: 'zone', label: '地区 / Zone', help: '不同国家对应不同推荐内容，填写 cn/en/jp 等', type: 'string', required: false },\n      { key: 'group', label: '页码分组', type: 'boolean', help: '', required: false },\n      { key: 'quality', label: '默认清晰度', \n        options: [\n          { value: 'LD', label: 'Low' },\n          { value: 'HD', label: 'High' },\n        ]\n        , help: '下载/预览时的清晰度', required: false },\n      { key: 'proxy', label: '代理地址', help: '设置后该挂载盘的所有请求均使用此代理。支持HTTP/HTTPS', type: 'string', required: false },\n    ]\n  }\n\n  /**\n   * \n   * @param {*} app \n   * @param {*} config 默认配置(响应式)\n   */\n  constructor(app, config) {\n    this.app = app\n    this.config = config\n\n    // this.getConfig = Manager.getInstance(app, config)\n  }\n\n  /**\n   * 列出目录\n   *\n   * @param {string} [id] 文件(目录)id 唯一值\n   * \n   * @param {object} [options] 参数\n   * @param {object} [options.order_by] 排序\n   * @param {object} [options.page] 页码\n   * @param {object} [options.per_page] 每页条目数\n   * @param {object} [options.search] 搜索内容\n   * \n   * @return {object}\n   *\n   * @api public {Array<file>}\n   * \n   * files.id 资源ID\n   * files.name 资源名\n   * files.size 资源大小\n   * files.type 类型 'folder' | 'file'\n   * files.ctime 创建时间\n   * files.mtime 修改时间\n   */\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\n    let usePagination = !!perPage\n\n    //使用自然分页\n    nextPage = nextPage || 1\n    if (!id) {\n      if (nextPage > 1) return { files: [] }\n      else return {\n        files: await this.getCats()\n      }\n    }\n    if (!id.startsWith('@')) {\n      return { files: [] }\n    }\n\n\n    let url = getListUrl(id.substring(1), search, nextPage)\n    let res = await this.app.request.get(url, {\n      proxy: this.config.proxy,\n      responseType: 'text',\n      'user-agent': UA\n    })\n    let files = []\n    const htmlEntity = this.app.utils.htmlEntity\n    res.data?.replace(/<img[\\w\\W]+?data-src=\"([^\"]+?)\"[\\w\\W]+?<a href=\"([^\"]+?)\"\\s+title=\"([^\"]+?)\"/g, ($0, $1, $2, $3) => {\n      files.push({\n        id: encode($2),\n        name: htmlEntity.decode($3) + '.mp4', //$3 is title\n        type: 'file',\n        size: 0,\n        mime: 'video/mp4',\n        ctime: Date.now(),\n        mtime: Date.now(),\n        extra: {\n          sources: [\n            { size: 480, quality: 'LD' },\n            { size: 720, quality: 'HD' }\n          ]\n        },\n        thumb: $1,\n      })\n    })\n    return { id, files, nextPage: nextPage+1 }\n  }\n\n\n  //获取分类\n  async getCats() {\n    const ua = `Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36`\n    if (!this.cats) {\n      let zone = this.config.zone || 'cn'\n      let proxy = this.config.proxy\n\n      let { data, headers } = await this.app.request.get(`${HOST}/change-country/${zone}`, {\n        // followRedirect: false,\n        responseType: 'text',\n        headers: {\n          'User-Agent': ua,\n        },\n        proxy\n      })\n      const cats = [{\n        id: '@',\n        name: '所有',\n        type: 'folder',\n        size: 0,\n        ctime: Date.now(),\n        mtime: Date.now(),\n      }]\n\n      data.replace(/<span[^>]+><\\/span>/g, '').replace(/<li class=\"dyn[^>]+?><a[\\w\\W]+?href=\"([^\"]+?)\"[^>]*?>([^<]+?)<\\/a><\\/li>/g, ($0, $1, $2) => {\n        cats.push({\n          id: '@' + encode($1),\n          name: $2.replace(/^\\s*/, ''),\n          type: 'folder',\n          size: 0,\n          ctime: Date.now(),\n          mtime: Date.now(),\n        })\n        return ''\n      })\n\n      this.cats = cats\n    }\n    return this.cats.map(i => ({ ...i }))\n  }\n\n  /**\n   * 获取文件详情\n   * @param {*} id 文件(目录)id 唯一值\n   * @param {*} key \n   */\n  async get(id) {\n    if (id == 'root') {\n      return {\n        id: 'root',\n        name: '@root',\n        type: 'folder'\n      }\n    }\n    const pathname = decode(id)\n\n    let { data } = await this.app.request.get(HOST + pathname, {\n      responseType: 'text',\n      'user-agent': UA,\n      proxy: this.config.proxy\n\n    })\n\n    let url_low = (data.match(/setVideoUrlLow\\('([^'\"]+?)'/) || ['', ''])[1]\n\n    let url_high = (data.match(/setVideoUrlHigh\\('([^'\"]+?)'/) || ['', ''])[1]\n\n    let url_hls = (data.match(/setVideoHLS\\('([^'\"]+?)'/) || ['', ''])[1]\n\n    let thumb = (data.match(/setThumbUrl169\\('([^'\"]+?)'/) || ['', ''])[1]\n\n    let name = (data.match(/setVideoTitle\\('([^'\"]+?)'/) || ['', ''])[1]\n\n    let quality = this.config.quality\n    \n    const sources = [\n      { name: 'LD', src: url_low },\n      { name: 'HD', src: url_high },\n    ]\n    const source = sources.find(i => i.name == quality) ?? sources[0]\n    \n    let size = await this.getSize(source.src)\n    let result = {\n      id: id,\n      name: `${name}.mp4`,\n      size,\n      type: 'file',\n      ctime: Date.now(),\n      mtime: Date.now(),\n      thumb,\n      download_url: source.src,\n      extra: {\n        parent_id: 'root',\n        category: 'video',\n        sources: [\n          { name: 'LD', src: url_low },\n          { name: 'HD', src: url_high },\n        ]\n      }\n    }\n\n    if (this.config.proxy) {\n      result.extra.proxy = {\n        proxy_server: this.config.proxy,\n        headers: {\n          'user-agent': UA,\n          'referer': HOST\n        },\n      }\n    }\n\n    return result\n  }\n\n  async getSize(url){\n    const controller = new AbortController();\n\n    const res = await this.app.request.get(url, {\n      responseType: 'blob',\n      'user-agent': UA,\n      proxy: this.config.proxy,\n      signal: controller.signal \n    })\n    const size = +(res.headers['content-length'] ?? '0')\n    controller.abort();\n    return size\n  }\n\n}\n\nmodule.exports = { driver: Driver }"}]