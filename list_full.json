[{"hash":"0994e45821ee18fb1a542f3342d9e414","name":"AliyunDrive","namespace":"sharelist.plugin.aliyundrive","version":"1.0.0","license":"MIT","description":"Aliyun Drive","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/aliyundrive/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTIyLjAzNTUgMTMuODA2MUMyMS43NjQ2IDEzLjczMzggMjEuNTkxIDEzLjQ2MjEgMjEuNjUxNSAxMy4xODlDMjIuODc4MSA3LjU1NjU1IDE5LjQ1MDkgMS44Nzk1MSAxMy44MDU1IDAuMzcxOTc5QzcuOTk5NTEgLTEuMTc4NDQgMi4wMDgzNyAyLjI2MDA0IDAuNDM5MTc3IDguMDM5MDhDMC40Mzg1MzUgOC4wNDE0NyAwLjQzNzg5MiA4LjA0Mzg2IDAuNDM2NjA4IDguMDQ4NjNDMC40MzUzMjMgOC4wNTM0MSAwLjQzMzM5NyA4LjA2MDU4IDAuNDMyMTEyIDguMDY1MzZDLTAuNTIzMzgxIDExLjY0NzggMC4xMTY1MSAxNS40MDI5IDIuMjQ0NjcgMTguNTA1N0MzLjcyNzEzIDIwLjY2NTUgNS44NjcwNCAyMi4zMTk5IDguMzMwOTEgMjMuMjE4NUMxNS4yMTgyIDI1LjcyNTkgMjIuNjMzNiAyMS45Njg4IDI0LjgyNTUgMTUuMjVDMjQuOTM5NyAxNC45MDE2IDI0LjczNDcgMTQuNTI2OSAyNC4zNzc1IDE0LjQzMTVMMjIuMDM1NSAxMy44MDYxWk0xMC41OTQyIDE5LjI2MzNDOC40Nzk4NyAxOC42OTg3IDYuNzEyODggMTcuMzQ4NyA1LjYyMDE4IDE1LjQ1OTRDNC41MjY4MyAxMy41NzI1IDQuMjM1NzEgMTEuMzc3NSA0Ljc5OTExIDkuMjcyNDdDNS43MzQ3NyA1LjgzMDYyIDkuMzAxNzUgMy43ODI2NiAxMi43NjA5IDQuNzA2MzhDMTYuMDQ1IDUuNTgzMzcgMTguMDY4NSA4LjgyNzIxIDE3LjQ4MDYgMTIuMTAzM0MxNy40MjYgMTIuNDExNCAxNy42MSAxMi43MTE0IDE3LjkxNDQgMTIuNzkyN0wyMC4xMTk4IDEzLjM4MTZDMjAuNDAwMyAxMy40NTY1IDIwLjU1NzMgMTMuNzUxOSAyMC40NjM2IDE0LjAyMzhDMTkuMDgzNSAxOC4wNDg1IDE0Ljc3NDkgMjAuMzc5NyAxMC41OTQyIDE5LjI2MzNaIiBmaWxsPSJyZ2IoMTAzLDEyNSwyMzgpIj48L3BhdGg+PC9zdmc+","script":"//===Sharelist===\r\n// @name         AliyunDrive\r\n// @namespace    sharelist.plugin.aliyundrive\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  Aliyun Drive\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/aliyundrive/index.js\r\n// @icon         data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTIyLjAzNTUgMTMuODA2MUMyMS43NjQ2IDEzLjczMzggMjEuNTkxIDEzLjQ2MjEgMjEuNjUxNSAxMy4xODlDMjIuODc4MSA3LjU1NjU1IDE5LjQ1MDkgMS44Nzk1MSAxMy44MDU1IDAuMzcxOTc5QzcuOTk5NTEgLTEuMTc4NDQgMi4wMDgzNyAyLjI2MDA0IDAuNDM5MTc3IDguMDM5MDhDMC40Mzg1MzUgOC4wNDE0NyAwLjQzNzg5MiA4LjA0Mzg2IDAuNDM2NjA4IDguMDQ4NjNDMC40MzUzMjMgOC4wNTM0MSAwLjQzMzM5NyA4LjA2MDU4IDAuNDMyMTEyIDguMDY1MzZDLTAuNTIzMzgxIDExLjY0NzggMC4xMTY1MSAxNS40MDI5IDIuMjQ0NjcgMTguNTA1N0MzLjcyNzEzIDIwLjY2NTUgNS44NjcwNCAyMi4zMTk5IDguMzMwOTEgMjMuMjE4NUMxNS4yMTgyIDI1LjcyNTkgMjIuNjMzNiAyMS45Njg4IDI0LjgyNTUgMTUuMjVDMjQuOTM5NyAxNC45MDE2IDI0LjczNDcgMTQuNTI2OSAyNC4zNzc1IDE0LjQzMTVMMjIuMDM1NSAxMy44MDYxWk0xMC41OTQyIDE5LjI2MzNDOC40Nzk4NyAxOC42OTg3IDYuNzEyODggMTcuMzQ4NyA1LjYyMDE4IDE1LjQ1OTRDNC41MjY4MyAxMy41NzI1IDQuMjM1NzEgMTEuMzc3NSA0Ljc5OTExIDkuMjcyNDdDNS43MzQ3NyA1LjgzMDYyIDkuMzAxNzUgMy43ODI2NiAxMi43NjA5IDQuNzA2MzhDMTYuMDQ1IDUuNTgzMzcgMTguMDY4NSA4LjgyNzIxIDE3LjQ4MDYgMTIuMTAzM0MxNy40MjYgMTIuNDExNCAxNy42MSAxMi43MTE0IDE3LjkxNDQgMTIuNzkyN0wyMC4xMTk4IDEzLjM4MTZDMjAuNDAwMyAxMy40NTY1IDIwLjU1NzMgMTMuNzUxOSAyMC40NjM2IDE0LjAyMzhDMTkuMDgzNSAxOC4wNDg1IDE0Ljc3NDkgMjAuMzc5NyAxMC41OTQyIDE5LjI2MzNaIiBmaWxsPSJyZ2IoMTAzLDEyNSwyMzgpIj48L3BhdGg+PC9zdmc+\r\n//===/Sharelist==\r\n\r\n\r\nconst UPLOAD_PART_SIZE = 10 * 1024 * 1024\r\n\r\nconst API_ENDPOINT = 'https://api.aliyundrive.com'\r\n\r\nconst DEFAULT_UA = `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.67 Safari/537.36`\r\n\r\nconst REFERER = `https://www.aliyundrive.com/`\r\n\r\nconst atob = v => Buffer.from(v, 'base64').toString()\r\n\r\nconst isMobileToken = (access_token) => {\r\n  try {\r\n    return !JSON.parse(JSON.parse(atob(access_token.split('.')[1])).customJson).ref\r\n  } catch (e) {\r\n\r\n  }\r\n  return false\r\n}\r\n\r\nconst replaceCDNUrl = (url) => {\r\n  return url.replace(/https:\\/\\/([\\w\\W]+?)\\./, (_, srv) => `https://${srv}-enet.`)\r\n}\r\n\r\n/**\r\n * auth manager class\r\n */\r\nclass Manager {\r\n  static getInstance(app, config) {\r\n    if (!this.instance) {\r\n      this.instance = new Manager(app)\r\n    }\r\n\r\n    // this.instance.add(config)\r\n    const getter = this.instance.createGetter(config)\r\n\r\n    // lazy load config\r\n    // getter()\r\n\r\n    return getter\r\n  }\r\n\r\n  constructor(app) {\r\n    this.app = app\r\n  }\r\n\r\n  createGetter(config) {\r\n    let DRIVE_KEY = this.app.DRIVE_KEY\r\n\r\n    if (!config[DRIVE_KEY] && config.user_id) {\r\n      config[DRIVE_KEY] = config.user_id\r\n    }\r\n\r\n    return async () => {\r\n      if (\r\n        !config.user_id ||\r\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\r\n      ) {\r\n        await this.refreshAccessToken(config)\r\n      }\r\n      if (!config[DRIVE_KEY]) {\r\n        config[DRIVE_KEY] = config.user_id\r\n      }\r\n\r\n      return {\r\n        ...config\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * refreshAccessToken\r\n   *\r\n   * @param {object} options\r\n   * @param {string} options.refresh_token\r\n   * @return {object} [credentials]\r\n   * @api private\r\n   */\r\n  async refreshAccessToken(config) {\r\n    let { refresh_token: lastRefeshToken } = config\r\n    //TODO: Web client API CAN NOT support mobile token\r\n    // https://auth.aliyundrive.com/v2/account/token\r\n    // mobile: ${API_ENDPOINT}/v2/account/token\r\n    // web: ${API_ENDPOINT}/token/refresh\r\n    let { data, headers } = await this.app.request.post(`${API_ENDPOINT}/v2/account/token`, {\r\n      data: {\r\n        refresh_token: lastRefeshToken,\r\n        grant_type: \"refresh_token\"\r\n      },\r\n      headers: {\r\n        'User-Agent': 'None',\r\n      },\r\n      contentType: 'json',\r\n    })\r\n    if (data && !data.access_token) {\r\n      throw new Error({ message: data.message || 'An error occurred during refresh access token' })\r\n    }\r\n    let { user_id, access_token, default_drive_id: drive_id, expires_in, refresh_token, device_id } = data\r\n\r\n    // expires_in 7200s\r\n    let expires_at = Date.now() + expires_in * 1000\r\n\r\n    config.user_id = user_id\r\n    config.refresh_token = refresh_token\r\n    config.access_token = access_token\r\n    config.expires_at = expires_at\r\n    config.drive_id = drive_id\r\n    config.token_type = isMobileToken(access_token) ? 'mobile' : 'web'\r\n    config.device_id = device_id\r\n\r\n    // key 内部属性, 区分不同挂载盘\r\n    if (!config.key) {\r\n      config.key = user_id\r\n    }\r\n  }\r\n}\r\n\r\nclass Driver {\r\n  static options = {\r\n    protocol: \"aliyun\",\r\n\r\n    //支持全局搜索\r\n    globalSearch: true,\r\n    localSearch: false,\r\n\r\n    hash: 'sha1',\r\n    uploadHash: 'sha1',\r\n    // key: 'user_id',\r\n    defaultRoot: 'root',\r\n\r\n    guide: [\r\n      { key: 'refresh_token', label: 'Refresh Token', type: 'string', required: true },\r\n      {\r\n        key: 'root_id',\r\n        label: '初始文件夹ID / Root ID',\r\n        help: 'https://www.aliyundrive.com/drive/folder/xxxxxxxxxxx 地址中 xxxx 的部分',\r\n        type: 'string',\r\n      },\r\n    ]\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.getConfig = Manager.getInstance(app, config)\r\n\r\n  }\r\n  /**\r\n   * list files\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {object} [options] list options\r\n   * @param {object} [options.sort] sort methods\r\n   * @param {object} [options.search] search\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async list(id, { search, orderBy, perPage, nextPage }) {\r\n\r\n    const {\r\n      request,\r\n      utils: { timestamp },\r\n    } = this.app\r\n\r\n    let { drive_id, access_token, device_id } = await this.getConfig()\r\n\r\n    let isSearch = !!search\r\n\r\n    let usePagination = !!perPage\r\n\r\n    let url = `${API_ENDPOINT}/adrive/v3/file/${isSearch ? 'search' : 'list'}`\r\n    let params = isSearch ? {\r\n      drive_id,\r\n      limit: 100, // max 100\r\n      query: `name match \\\"${search}\\\"`,\r\n      order_by: \"updated_at DESC\"\r\n    } : {\r\n      drive_id,\r\n      parent_file_id: id,\r\n      limit: 200,\r\n      fields: \"*\",\r\n      url_expire_sec: 1600\r\n    }\r\n\r\n    if (orderBy) {\r\n      let [sortKey, isASC] = orderBy\r\n      if (isSearch) {\r\n        params.order_by = `${sortKey || 'name'} ${isASC ? 'ASC' : 'DESC'}`\r\n      } else {\r\n        params.order_by = sortKey || 'name'\r\n        params.order_direction = isASC ? 'ASC' : 'DESC'\r\n      }\r\n    }\r\n\r\n    let marker = nextPage, files = []\r\n\r\n    do {\r\n      let { data } = await request.post(url, {\r\n        data: { ...params, ...(marker ? { marker } : {}) },\r\n\r\n        headers: {\r\n          Authorization: access_token,\r\n          'user-agent': DEFAULT_UA,\r\n          'x-canary': 'client=web,app=adrive,version=v3.6.1',\r\n          'x-device-id': device_id,\r\n          'referer': REFERER\r\n        },\r\n        contentType: 'json',\r\n      })\r\n\r\n      // if (!data.items) return { error: { message: 'An error occurred when list folder' } }\r\n      if (data.error) return data\r\n\r\n      if (!data.items) return this.app.error({ message: data.message })\r\n\r\n      for (let i of data.items) {\r\n        files.push({\r\n          id: i.file_id,\r\n          name: i.name,\r\n          type: i.type == 'folder' ? 'folder' : 'file',\r\n          size: i.size,\r\n          ctime: timestamp(i.created_at),\r\n          mtime: timestamp(i.updated_at),\r\n          download_url: i.url,\r\n          extra: {\r\n            fid: i.file_id,\r\n            parent_id: i.parent_file_id,\r\n            sha1: i.content_hash\r\n          },\r\n        })\r\n      }\r\n\r\n      marker = data.next_marker\r\n    } while (!usePagination && marker)\r\n\r\n\r\n    let result = {\r\n      id, files\r\n    }\r\n\r\n    if (usePagination && marker) {\r\n      result.nextPage = marker\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * get file\r\n   *\r\n   * @param {string} [file_id] folder/file id\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async get(file_id) {\r\n    const {\r\n      request,\r\n      utils: { timestamp },\r\n    } = this.app\r\n\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    let { data } = await request.post(`${API_ENDPOINT}/v2/file/get`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        drive_id,\r\n        file_id,\r\n      },\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.error) return data.error\r\n    let result = {\r\n      id: data.file_id,\r\n      name: data.name,\r\n      type: data.type,\r\n      size: data.size,\r\n      ctime: timestamp(data.created_at),\r\n      mtime: timestamp(data.updated_at),\r\n      download_url: data.download_url,\r\n      extra: {\r\n        fid: data.file_id,\r\n        parent_id: data.parent_file_id,\r\n      },\r\n    }\r\n\r\n\r\n\r\n\r\n    if (result.type == 'file') {\r\n      // if (data.category == 'video') {\r\n      //   let sources = await this.video_preview(access_token, id, drive_id)\r\n      //   result.extra.category = 'video'\r\n      //   if (sources.length) {\r\n      //     result.extra.sources = sources\r\n      //   }\r\n      // }\r\n\r\n      if (!result.download_url) {\r\n        let res = await this.get_download_url(file_id)\r\n        result.download_url = res.url\r\n      } else {\r\n        // result.download_url = replaceCDNUrl(result.download_url)\r\n      }\r\n\r\n      //The referer needs to be verified when using web refresh_token\r\n      if (result.download_url?.includes('x-oss-additional-headers=referer')) {\r\n        result.extra.proxy = {\r\n          headers: {\r\n            referer: REFERER,\r\n            //'user-agent': 'SmartDrive/24732503 CFNetwork/1331.0.7 Darwin/21.4.0'\r\n          },\r\n        }\r\n      }\r\n      let expired_at = +(result.download_url.match(/x\\-oss\\-expires=(\\d+)/)?.[1] || 0) * 1000\r\n\r\n      // The download link will expire after 15 minutes.\r\n      result.max_age = expired_at - Date.now()\r\n    } else {\r\n      result.max_age = 1 * 3600 * 1000\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  async get_path(file_id) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n    const { request } = this.app\r\n\r\n    try {\r\n      let { data } = await request.post(`${API_ENDPOINT}/adrive/v1/file/get_path`, {\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: {\r\n          drive_id,\r\n          file_id,\r\n        },\r\n        contentType: 'json',\r\n      })\r\n\r\n      return data?.items || []\r\n    } catch (e) {\r\n    }\r\n  }\r\n\r\n  /**\r\n   * get download url\r\n   *\r\n   * @param {string} [file_id] file id\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async get_download_url(file_id) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n    const { request } = this.app\r\n\r\n    try {\r\n      let { data } = await request.post(`${API_ENDPOINT}/v2/file/get_download_url`, {\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: {\r\n          drive_id,\r\n          file_id,\r\n        },\r\n        contentType: 'json',\r\n      })\r\n\r\n      const ret = { url: data?.cdn_url || data?.url, size: data.size, max_age: new Date(data.expiration).getTime() - Date.now() }\r\n      if (ret.url?.includes('x-oss-additional-headers=referer')) {\r\n        ret.proxy = {\r\n          headers: {\r\n            referer: REFERER,\r\n          },\r\n        }\r\n      }\r\n      return ret\r\n    } catch (e) {\r\n      return {}\r\n    }\r\n  }\r\n\r\n  /**\r\n   * create folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] folder name\r\n   * @param {object} [options] options\r\n   * @param {object} [options.check_name_mode] \r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async mkdir(parent_file_id, name, { check_name_mode = 'refuse' }) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/adrive/v2/file/createWithFolders`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        drive_id,\r\n        parent_file_id,\r\n        name,\r\n        type: 'folder',\r\n        check_name_mode,\r\n      },\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.error) return data.error\r\n\r\n    return {\r\n      id: data.file_id,\r\n      name,\r\n      parent_id: parent_file_id\r\n    }\r\n  }\r\n\r\n  /**\r\n   * rename file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] new name\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rename(file_id, name, { check_name_mode = 'refuse' } = {}) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    let { data, status } = await this.app.request.post(`${API_ENDPOINT}/v3/file/update`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        drive_id,\r\n        file_id,\r\n        name,\r\n        check_name_mode,\r\n      },\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.code) {\r\n      if (data.code === 'AlreadyExist.File') {\r\n        return this.app.error({ code: 409 })\r\n      } else {\r\n        return this.app.error(data)\r\n      }\r\n    }\r\n\r\n    return {\r\n      id: data.file_id,\r\n      name: data.name,\r\n      parent_id: data.parent_file_id\r\n    }\r\n  }\r\n\r\n  /**\r\n   * remove file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @return {string}\r\n   *\r\n   * @api public\r\n   */\r\n  async rm(file_id) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/v2/batch`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        \"requests\":\r\n          [{ \"body\": { drive_id, file_id }, \"headers\": { \"Content-Type\": \"application/json\" }, \"id\": file_id, \"method\": \"POST\", \"url\": \"/recyclebin/trash\" }],\r\n        \"resource\": \"file\"\r\n      }\r\n      ,\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.code) {\r\n      return this.app.error(data)\r\n    }\r\n\r\n    return { id: file_id }\r\n  }\r\n\r\n\r\n  /**\r\n   * mv file/folder\r\n   *\r\n   * @param {string} [file_id] folder id\r\n   * @param {string} [target_id] folder id\r\n   * @return {string | error}\r\n   *\r\n   * @api public\r\n   */\r\n  async mv(file_id, target_id, options = {}) {\r\n    if (options.copy) {\r\n      throw { code: 501, message: \"Not implemented\" }\r\n    }\r\n\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/v3/batch`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        \"requests\":\r\n          [\r\n            {\r\n              \"body\": { drive_id, file_id, to_drive_id: drive_id, to_parent_file_id: target_id },\r\n              \"headers\": { \"Content-Type\": \"application/json\" },\r\n              \"id\": file_id,\r\n              \"method\": \"POST\",\r\n              \"url\": \"/file/move\"\r\n            }],\r\n        \"resource\": \"file\"\r\n      }\r\n      ,\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.code) {\r\n      return this.app.error(data)\r\n    }\r\n\r\n    if (options.name) {\r\n      await this.rename(file_id, options.name)\r\n    }\r\n\r\n    return { id: file_id }\r\n  }\r\n\r\n  /**\r\n   * upload file\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {object} [options] upload file meta\r\n   * @param {ReadableStream} [options.stream] upload file stream\r\n   * @param {number} [options.size] upload file size\r\n   * @param {string} [options.name] upload file name\r\n   * @param {string} [options.sha1] file sha1 hash\r\n   * @param {string} [options.taskId] task id\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async upload(id, stream, { size, name, uploadId, conflictBehavior, ...rest }) {\r\n    const { app } = this\r\n\r\n    let res = await this.beforeUpload(uploadId, { id, name, size, ...rest })\r\n\r\n    let { file_id, upload_id, file_name, rapid_upload, start = 0 } = res\r\n\r\n    uploadId = upload_id + '-' + file_id + '-1'\r\n\r\n    if (rapid_upload) {\r\n      return {\r\n        id: file_id,\r\n        name: file_name,\r\n        parent_id: id,\r\n        completed: true,\r\n      }\r\n    }\r\n\r\n    const done = async (stream) => {\r\n      let readStream = (typeof stream == 'function') ? await stream(start, uploadId) : stream\r\n      let uploadParts = res.part_info_list\r\n      let passStream = app.streamReader(readStream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\r\n      for (let part of uploadParts) {\r\n        let uploadUrl = part.upload_url\r\n        rest.updateUploadState?.(upload_id + '-' + file_id + '-' + part.part_number)\r\n\r\n        let chunk = await passStream.read(UPLOAD_PART_SIZE)\r\n        let headers = {\r\n          'Referer': REFERER,\r\n          'Origin': 'https://www.aliyundrive.com',\r\n          'User-Agent': DEFAULT_UA,\r\n          'Content-Type': ''\r\n        }\r\n\r\n        headers['Content-Length'] = chunk.length\r\n\r\n        let res = await app.request(uploadUrl, {\r\n          method: 'put',\r\n          data: chunk,\r\n          contentType: 'buffer',\r\n          responseType: 'text',\r\n          headers\r\n        })\r\n        if (res.status != 200) {\r\n          let message = res.data.match(/<Code>([\\w\\W]+?)<\\/Code>/)?.[1] || 'unknown'\r\n          return this.app.error({ message: 'An error occurred during upload: ' + message })\r\n        }\r\n      }\r\n\r\n      await this.afterUpload(file_id, upload_id)\r\n\r\n      return { id: file_id, name: file_name, parent_id: id }\r\n    }\r\n\r\n    if (!stream) {\r\n      return { uploadId, start }\r\n    } else {\r\n      return await done(stream)\r\n    }\r\n\r\n  }\r\n\r\n  async haveSameFile(parent_id, name, size) {\r\n    try {\r\n      let files = this.list(parent_id, {})\r\n      return files.find(i => i.name === name && i.size === size)\r\n    } catch (e) {\r\n\r\n    }\r\n    return false\r\n  }\r\n\r\n  async beforeUpload(uploadId, { id, name, size, conflictBehavior, sha1, ...rest } = { conflictBehavior: 'rename' }) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n    //resume upload progress\r\n    let partCount = Math.ceil(size / UPLOAD_PART_SIZE)\r\n\r\n    if (uploadId) {\r\n      let [taskId, fileId, partNumber] = uploadId.split('-')\r\n      partNumber = partNumber ? +partNumber : 1\r\n\r\n      const partList = new Array(partCount - partNumber + 1).fill(0).map((i, idx) => ({ part_number: idx + partNumber }))\r\n\r\n      let { data } = await this.app.request.post(`${API_ENDPOINT}/v2/file/get_upload_url`, {\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: {\r\n          drive_id,\r\n          upload_id: taskId,\r\n          file_id: fileId,\r\n          part_info_list: partList\r\n        },\r\n        signal: rest.signal,\r\n        contentType: 'json',\r\n      })\r\n\r\n      if (data) {\r\n        data.start = (partNumber - 1) * UPLOAD_PART_SIZE\r\n        return data\r\n      }\r\n    }\r\n\r\n    const partList = new Array(Math.ceil(size / UPLOAD_PART_SIZE)).fill(0).map((i, idx) => ({ part_number: idx + 1 }))\r\n\r\n    const checkNameMap = {\r\n      1: 'auto_rename',\r\n      2: 'overwrite'\r\n    }\r\n    let params = {\r\n      parent_file_id: id,\r\n      drive_id,\r\n      name,\r\n      size,\r\n      type: \"file\",\r\n      check_name_mode: checkNameMap[conflictBehavior],\r\n      part_info_list: partList,\r\n    }\r\n\r\n    if (sha1) {\r\n      params.pre_hash = sha1.toUpperCase()\r\n    }\r\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/adrive/v2/file/createWithFolders`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: params,\r\n      contentType: 'json',\r\n    })\r\n    if (data.code) {\r\n      return this.app.error(data)\r\n    }\r\n\r\n    return data\r\n  }\r\n\r\n  async afterUpload(file_id, upload_id) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    const {\r\n      request,\r\n    } = this.app\r\n    let { data } = await request.post(`${API_ENDPOINT}/v2/file/complete`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        drive_id,\r\n        upload_id,\r\n        file_id\r\n      },\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.code) {\r\n      return this.app.error(data)\r\n    }\r\n\r\n    return data\r\n  }\r\n\r\n  async video_preview(id) {\r\n    let { drive_id, access_token } = await this.getConfig()\r\n\r\n    const {\r\n      request,\r\n      utils: { videoQuality },\r\n    } = this.app\r\n\r\n    let data = []\r\n    try {\r\n      let res = await request.post(`${API_ENDPOINT}/v2/file/get_video_preview_play_info`, {\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: {\r\n          category: 'live_transcoding',\r\n          drive_id,\r\n          file_id: id,\r\n          template_id: '',\r\n        },\r\n        contentType: 'json',\r\n      })\r\n\r\n      data = res.data\r\n    } catch (e) {\r\n    }\r\n\r\n    return data.video_preview_play_info.live_transcoding_task_list\r\n      .filter((i) => !!i.url)\r\n      .map((i) => ({ size: videoQuality(i.template_id), type: 'video/mp4', quality: i.template_id, src: i.url }))\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = { driver: Driver }"},{"hash":"8520edbdffbb16b3d7b33f1c2864ff0d","name":"BaiduNetDisk","namespace":"sharelist.plugin.baidu","version":"1.0.0","license":"MIT","description":"Baidu Net Disk","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/baidu/index.js","icon":"https://nd-static.bdstatic.com/m-static/wp-brand/favicon.ico","script":"//===Sharelist===\r\n// @name         BaiduNetDisk\r\n// @namespace    sharelist.plugin.baidu\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  Baidu Net Disk\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/baidu/index.js\r\n// @icon         https://nd-static.bdstatic.com/m-static/wp-brand/favicon.ico\r\n//===/Sharelist==\r\n\r\n// doc: https://pan.baidu.com/union/document/basic#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8\r\n\r\nconst API = 'https://pan.baidu.com/rest/2.0/xpan'\r\n\r\nconst ERR_CODE = {\r\n  0: '请求成功',\r\n  2: '参数错误',\r\n  '-6': '身份验证失败, access_token 是否有效? 部分接口需要申请对应的网盘权限',\r\n  '-7': '文件或目录无权访问',\r\n  '-9': '文件或目录不存在',\r\n  31034: '命中接口频控',\r\n  42000: '访问过于频繁',\r\n  42211: '图片详细信息查询失败',\r\n  42212: '共享目录文件上传者信息查询失败',\r\n  42213: '共享目录鉴权失败',\r\n  42214: '文件基础信息查询失败',\r\n}\r\n\r\nconst DEFAULT_ROOT_ID = 'root'\r\n\r\n/**\r\n * auth manager class\r\n */\r\nclass Manager {\r\n  static getInstance(app, config) {\r\n    if (!this.instance) {\r\n      this.instance = new Manager(app)\r\n    }\r\n\r\n    return this.instance.createGetter(config)\r\n  }\r\n\r\n  constructor(app) {\r\n    this.app = app\r\n  }\r\n\r\n  createGetter(config) {\r\n    return async () => {\r\n      if (\r\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\r\n      ) {\r\n        await this.refreshAccessToken(config)\r\n      }\r\n      return {\r\n        ...config\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 刷新令牌 / refresh token\r\n   *\r\n   * @param {object} credentials\r\n   * @param {object} { credentials: object } | { error:true, message:string }\r\n   * @api private\r\n   */\r\n  async refreshAccessToken(credentials) {\r\n    console.log('refreshAccessToken')\r\n    let { client_id, client_secret, redirect_uri, refresh_token, ...rest } = credentials\r\n\r\n    if (!(client_id && client_secret && refresh_token)) {\r\n      return this.app.error({ message: 'Invalid parameters: An error occurred during refresh access token' })\r\n    }\r\n\r\n    let formdata = {\r\n      client_id: client_id.split('::')[0],\r\n      client_secret,\r\n      // redirect_uri,\r\n      refresh_token,\r\n      grant_type: 'refresh_token',\r\n    }\r\n\r\n    let { data } = await this.app.request.get(`https://openapi.baidu.com/oauth/2.0/token`, { data: formdata })\r\n\r\n    if (data.error) return this.app.error({ message: data.error_description || data.error })\r\n\r\n    // expires_in 30 days\r\n    let expires_at = data.expires_in * 1000 + Date.now()\r\n\r\n    credentials.access_token = data.access_token\r\n    credentials.refresh_token = data.refresh_token\r\n    credentials.expires_at = expires_at\r\n  }\r\n\r\n}\r\n\r\n// const getRealId = v => [v.split('/').pop().replace('@f', ''), v.endsWith('@f'), v.split('/').slice(0, -1).join('/')]\r\n\r\nconst getRealId = v => [v.split('/').pop().replace('~', ''), v.includes('~'), v.split('/').slice(0, -1).join('/')]\r\n\r\nconst fullpath = (basepath, subpath) => {\r\n  return (basepath == '/' ? '' : basepath) + '/' + subpath\r\n}\r\n\r\nclass Driver {\r\n  static options = {\r\n    protocol: \"baidu\",\r\n\r\n    //支持全局搜索\r\n    globalSearch: true,\r\n    localSearch: false,\r\n\r\n    key: 'client_id',\r\n    defaultRoot: DEFAULT_ROOT_ID,\r\n    guide: [\r\n      { key: 'client_id', label: '应用ID / AppKey', type: 'string', required: true },\r\n      { key: 'client_secret', label: '应用机密 / SecretKey', type: 'string', required: true },\r\n      { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\r\n      { key: 'refresh_token', label: '刷新令牌 / Refresh Token', type: 'string', required: true },\r\n      { key: 'root_id', label: '初始文件夹ID', help: '', type: 'string', required: false },\r\n      { key: 'access_token', label: '令牌', help: '', type: 'hidden', required: false },\r\n      { key: 'expires_at', label: '有效期', help: '', type: 'hidden', required: false },\r\n    ]\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.getConfig = Manager.getInstance(app, config)\r\n  }\r\n\r\n  /**\r\n   * Lists or search files\r\n   *\r\n   * @param {string} [id] folder id  e.g. baidu://{key}/{id}?query\r\n   * @param {object} [options] list options\r\n   * @param {object} [options.sort] sort methods\r\n   * @param {object} [options.search] search key\r\n   * @return {object | error}\r\n   *\r\n   * @api public\r\n   */\r\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\r\n\r\n    let [fid, isFile] = getRealId(id)\r\n\r\n    if (isFile) {\r\n      return []\r\n    }\r\n\r\n    let usePagination = !!perPage\r\n\r\n    const { request } = this.app\r\n\r\n    let { access_token } = await this.getConfig()\r\n\r\n    let data = await this.meta(fid)\r\n    let dir = data.extra.path || '/'\r\n    if (data.type != 'folder') return []\r\n\r\n    // perPage 1000 ~ 10000\r\n    let start = nextPage || 0, limit = perPage || 1000, files = []\r\n\r\n    do {\r\n      let { data } = await request(`${API}/file`, {\r\n        data: {\r\n          method: 'list',\r\n          access_token,\r\n          dir,\r\n          web: 'web',\r\n          start,\r\n          limit\r\n        },\r\n        contentType: 'json',\r\n      })\r\n      if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\r\n\r\n      data.list.forEach((i) => {\r\n        let item = {\r\n          id: id + '/' + (i.isdir ? '' : '~') + i.fs_id,\r\n          name: i.server_filename,\r\n          type: i.isdir ? 'folder' : 'file',\r\n          size: parseInt(i.size),\r\n          ctime: i.server_ctime * 1000,\r\n          mtime: i.server_mtime * 1000,\r\n          thumb: i.thumbs ? i.thumbs.url2 : '',\r\n          extra: {\r\n            fid: id + '/' + (i.isdir ? '' : '~') + i.fs_id,\r\n            parent_id: id,\r\n            path: i.path,\r\n            md5: i.md5,\r\n          },\r\n        }\r\n\r\n        files.push(item)\r\n      })\r\n\r\n      if (limit <= data.list.length) {\r\n        start += limit\r\n      } else {\r\n        start = null\r\n        break\r\n      }\r\n    } while (!usePagination && start)\r\n\r\n    let result = {\r\n      id, files\r\n    }\r\n\r\n    if (usePagination && start) {\r\n      result.nextPage = start\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n  * get file\r\n  *\r\n  * @param {string} [id] id\r\n  * @param {string} [key] key\r\n  * @return {object}\r\n  *\r\n  * @api public\r\n  */\r\n  async get(id) {\r\n    let [fid, isFile, parentId] = getRealId(id)\r\n\r\n    let result = await this.meta(fid)\r\n\r\n    if (result.type == 'file') {\r\n      let { access_token } = await this.getConfig()\r\n      // file.dlink 8 小时有效\r\n      let { headers } = await this.app.request(`${result.extra.dlink}&access_token=${access_token}`, {\r\n        followRedirect: false,\r\n        headers: {\r\n          'user-agent': 'pan.baidu.com',\r\n        },\r\n      })\r\n\r\n      //http://xxxx.baidupcs.com/file  expires: 8h\r\n      if (headers.location) {\r\n        result.download_url = headers.location\r\n        result.max_age = 8 * 3600 * 1000 - 60 * 1000\r\n      }\r\n    }\r\n\r\n    if (result.download_url) {\r\n      // 50M 以上，直接下载包 sign error, 使用中转\r\n      if (result.size >= 50 * 1024 * 1024) {\r\n        result.extra.proxy = {\r\n          headers: {\r\n            'user-agent': 'pan.baidu.com',\r\n            'referer': 'https://pan.baidu.com'\r\n          },\r\n        }\r\n      }\r\n    }\r\n\r\n    result.extra.parent_id = parentId\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  async meta(id) {\r\n    if (!id || id === DEFAULT_ROOT_ID) {\r\n      return {\r\n        id,\r\n        type: 'folder',\r\n        extra: {\r\n          path: '/'\r\n        }\r\n      }\r\n    }\r\n\r\n    const { request } = this.app\r\n\r\n    let { access_token } = await this.getConfig()\r\n\r\n    let { data } = await request(`${API}/multimedia`, {\r\n      data: {\r\n        method: 'filemetas',\r\n        access_token,\r\n        fsids: `[${id}]`,\r\n        dlink: 1,\r\n      },\r\n    })\r\n\r\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\r\n\r\n    let file = data.list[0]\r\n    let result = {\r\n      id,\r\n      name: file.filename,\r\n      type: file.isdir ? 'folder' : 'file',\r\n      size: parseInt(file.size),\r\n      ctime: file.server_ctime * 1000,\r\n      mtime: file.server_mtime * 1000,\r\n      thumb: file.thumbs ? file.thumbs.url2 : '',\r\n      extra: {\r\n        fid: file.fs_id,\r\n        path: file.path,\r\n        md5: file.md5,\r\n        dlink: file.dlink\r\n      },\r\n    }\r\n\r\n    return result\r\n  }\r\n  /**\r\n   * create folder\r\n   *\r\n   * @param {string} [parent_id] folder id\r\n   * @param {string} [name] folder name\r\n   * @param {object} [options] options\r\n   * @param {object} [options.check_name_mode] \r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async mkdir(parent_id, name, { check_name_mode = 'refuse' }) {\r\n    let [id, isFile] = getRealId(parent_id)\r\n\r\n    let filedata = await this.meta(id)\r\n\r\n    let { access_token } = await this.getConfig()\r\n    let { data } = await this.app.request.post(`${API}/file?method=create&access_token=${access_token}`, {\r\n      data: {\r\n        isdir: 1,\r\n        size: 0,\r\n        path: fullpath(filedata.extra.path, name)\r\n      },\r\n      contentType: 'form',\r\n    })\r\n\r\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\r\n\r\n    return {\r\n      id: (parent_id ? `${parent_id}/` : '') + data.fs_id,\r\n      name: data.server_filename,\r\n      parent_id\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * rename file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] new name\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rename(id, name, { check_name_mode = 'refuse' } = {}) {\r\n\r\n    let [fid, isFile, parent_id] = getRealId(id)\r\n\r\n    let filedata = await this.meta(fid)\r\n\r\n    let { access_token } = await this.getConfig()\r\n    let { data } = await this.app.request.post(`${API}/file?method=filemanager&access_token=${access_token}&opera=rename`, {\r\n      data: {\r\n        async: 0,\r\n        filelist: [{ path: filedata.extra.path, newname: name }],\r\n        ondup: 'fail'\r\n      },\r\n      contentType: 'form',\r\n    })\r\n\r\n    // console.log(data, {\r\n    //   async: 0,\r\n    //   filelist: JSON.stringify([{ path: filedata.extra.path, newname: name }]),\r\n    // })\r\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\r\n\r\n    return {\r\n      id: id,\r\n      name: name,\r\n      parent_id\r\n    }\r\n  }\r\n\r\n  /**\r\n   * rm file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rm(id) {\r\n    let [fid, isFile, parent_id] = getRealId(id)\r\n\r\n    let filedata = await this.meta(fid)\r\n\r\n    let { access_token } = await this.getConfig()\r\n    let { data } = await this.app.request.post(`${API}/file?method=filemanager&access_token=${access_token}&opera=delete`, {\r\n      data: {\r\n        filelist: [filedata.extra.path],\r\n      },\r\n      contentType: 'form',\r\n    })\r\n\r\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\r\n\r\n    return { id, name: filedata.name, parent_id }\r\n  }\r\n\r\n  /**\r\n   * mv file/folder\r\n   *\r\n   * @param {string} [id] file/folder id\r\n   * @param {string} [target_id] folder id\r\n   * @return {string | error}\r\n   *\r\n   * @api public\r\n   */\r\n  async mv(id, target_id) {\r\n    let [fid, isFile, parent_id] = getRealId(id)\r\n\r\n    let [target_fid] = getRealId(target_id)\r\n\r\n    let { access_token } = await this.getConfig()\r\n\r\n    let filedata = await this.meta(fid)\r\n\r\n    let targetData = await this.meta(target_fid)\r\n\r\n    let { data } = await this.app.request.post(`${API}/file?method=filemanager&access_token=${access_token}&opera=move`, {\r\n      data: {\r\n        filelist: [{ path: filedata.extra.path, dest: targetData.extra.path }],\r\n      },\r\n      contentType: 'form',\r\n    })\r\n\r\n    if (data.errno) return this.app.error({ message: ERR_CODE[data.errno] })\r\n\r\n    let newId = target_id + '/' + id.split('/').pop()\r\n\r\n    return { id: newId, parent_id }\r\n  }\r\n}\r\n\r\nmodule.exports = { driver: Driver }\r\n"},{"hash":"592971a8b5a54a0f1d85d9854711edf0","name":"CMCCCloud","namespace":"sharelist.plugin.cmcc","version":"1.0.0","license":"MIT","description":"移动云盘","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/cmcc/index.js","script":"//===Sharelist===\r\n// @name         CMCCCloud\r\n// @namespace    sharelist.plugin.cmcc\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  移动云盘\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/cmcc/index.js\r\n//===/Sharelist==\r\n\r\n\r\n/**\r\n * 1. taskType: 1 copy,2 remove,3 move\r\n */\r\n const crypto = require('crypto')\r\n\r\n const DEFAULT_ROOT_ID = '00019700101000000001'\r\n \r\n const UPLOAD_PART_SIZE = 10 * 1024 * 1024\r\n \r\n const sleep = (time) => new Promise((resolve) => setTimeout(resolve, time))\r\n \r\n const md5 = (v) => {\r\n   return crypto.createHash('md5').update(v).digest('hex')\r\n }\r\n \r\n const getRandomSring = (e) => {\r\n   let n = ''\r\n   for (let t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', a = 0; a < e; a++) {\r\n     let o = Math.floor(Math.random() * t.length)\r\n     n += t.substring(o, o + 1)\r\n   }\r\n   return n\r\n }\r\n \r\n \r\n //base64 encode\r\n const btoa = (v) => Buffer.from(v).toString('base64')\r\n \r\n const utob = (str) => {\r\n   const u = String.fromCharCode\r\n   return str.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g, (t) => {\r\n     if (t.length < 2) {\r\n       var e = t.charCodeAt(0);\r\n       return e < 128 ? t : e < 2048 ? u(192 | e >>> 6) + u(128 | 63 & e) : u(224 | e >>> 12 & 15) + u(128 | e >>> 6 & 63) + u(128 | 63 & e)\r\n     }\r\n     e = 65536 + 1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320);\r\n     return u(240 | e >>> 18 & 7) + u(128 | e >>> 12 & 63) + u(128 | e >>> 6 & 63) + u(128 | 63 & e)\r\n   })\r\n }\r\n \r\n const unicode = (s) => s.split('').map((c) => ('\\\\u' + ('0000' + c.charCodeAt(0).toString(16).toUpperCase()).slice(-4))).join('')\r\n \r\n const getNewSign = (e, t, a, n) => {\r\n   let i = \"\";\r\n   if (t) {\r\n     let s = Object.assign({}, t);\r\n     i = JSON.stringify(s),\r\n       i = i.replace(/\\s*/g, \"\"),\r\n       i = encodeURIComponent(i);\r\n     let c = i.split(\"\"),\r\n       u = c.sort();\r\n     i = u.join(\"\")\r\n   }\r\n   let A = md5(btoa(utob(i))),\r\n     l = md5(a + \":\" + n);\r\n   return md5(A + l).toUpperCase()\r\n }\r\n \r\n const datetimeFormat = (d) =>\r\n   d ? d.replace(/(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/, '$1-$2-$3 $4:$5:$6+08:00') : ''\r\n \r\n const moment = (a, expr = 'yyyy-MM-dd hh:mm:ss') => {\r\n   let y = a.getFullYear(),\r\n     M = a.getMonth() + 1,\r\n     d = a.getDate(),\r\n     D = a.getDay(),\r\n     h = a.getHours(),\r\n     m = a.getMinutes(),\r\n     s = a.getSeconds(),\r\n     w = a.getDay()\r\n \r\n   const zeroize = v => `${v > 9 ? '' : '0'}${v}`\r\n \r\n   return expr.replace(/(?:s{1,2}|w{1,2}|m{1,2}|h{1,2}|d{1,2}|M{1,4}|y{1,4})/g, function (str) {\r\n \r\n     switch (str) {\r\n       case 's':\r\n         return s;\r\n       case 'ss':\r\n         return zeroize(s);\r\n       case 'm':\r\n         return m;\r\n       case 'mm':\r\n         return zeroize(m);\r\n       case 'h':\r\n         return h;\r\n       case 'hh':\r\n         return zeroize(h);\r\n       case 'd':\r\n         return d;\r\n       case 'w':\r\n         return w;\r\n       case 'ww':\r\n         return w == 0 ? 7 : w;\r\n       case 'dd':\r\n         return zeroize(d);\r\n       case 'M':\r\n         return M;\r\n       case 'MM':\r\n         return zeroize(M);\r\n       case 'MMMM':\r\n         return ['十二', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十', '十一'][m] + '月';\r\n       case 'yy':\r\n         return String(y).substr(2);\r\n       case 'yyyy':\r\n         return y;\r\n       default:\r\n         return str.substr(1, str.length - 2);\r\n     }\r\n   })\r\n }\r\n \r\n const createHeaders = (body) => {\r\n   // let timestamp = Date.now()\r\n   // let key = getRandomSring(16)\r\n \r\n   let timestamp = moment(new Date())\r\n   let key = getRandomSring(16)\r\n   let sign = getNewSign(undefined, body, timestamp, key)\r\n \r\n   let headers = {\r\n     'x-huawei-channelSrc': '10000034',\r\n     'x-inner-ntwk': '2',\r\n     'mcloud-channel': '1000101',\r\n     'mcloud-client': '10701',\r\n     'mcloud-sign': timestamp + \",\" + key + \",\" + sign,\r\n     // 'mcloud-skey': null,\r\n \r\n     'content-type': \"application/json;charset=UTF-8\",\r\n     'caller': 'web',\r\n     'CMS-DEVICE': 'default',\r\n     'x-DeviceInfo': '||9|85.0.4183.83|chrome|85.0.4183.83|||windows 10||zh-CN|||',\r\n     'x-SvcType': '1',\r\n     'referer': 'https://yun.139.com/w/',\r\n \r\n   }\r\n \r\n   // let headers = {\r\n   //   caller: 'web',\r\n   //   'CMS-CLIENT': '0010101',\r\n   //   'CMS-DEVICE': 'default',\r\n   //   'CMS-SIGN': timestamp + ',' + key + ',' + getSign(undefined, body, timestamp),\r\n   //   'x-DeviceInfo': '||9|92.0.4515.107|chrome|92.0.4515.107|||windows 10||zh-CN|||',\r\n   //   Referer: 'https://yun.139.com/w/',\r\n   // }\r\n \r\n   return headers\r\n }\r\n \r\n /**\r\n  * auth manager class\r\n  */\r\n /**\r\n  * auth manager class\r\n  */\r\n class Manager {\r\n   static getInstance(app, config) {\r\n     if (!this.instance) {\r\n       this.instance = new Manager(app)\r\n     }\r\n \r\n     // this.instance.add(config)\r\n     return this.instance.createGetter(config)\r\n   }\r\n \r\n   constructor(app) {\r\n     this.app = app\r\n   }\r\n \r\n   createGetter(config) {\r\n     return () => {\r\n       if (\r\n         config.mobile && config.token && config.account\r\n       ) {\r\n         return {\r\n           ...config,\r\n           cookie: `ORCHES-C-TOKEN=${config.token}; ORCHES-C-ACCOUNT=${config.account}; ORCHES-I-ACCOUNT-ENCRYPT=${btoa(config.mobile)}; `\r\n         }\r\n       }\r\n \r\n       throw { message: 'unmounted', code: 500 }\r\n     }\r\n   }\r\n }\r\n \r\n const getRealId = v => [v.split('/').pop().replace('~', ''), v.includes('~'), v.split('/').slice(0, -1).join('/')]\r\n \r\n class Driver {\r\n   static options = {\r\n     protocol: \"caiyun\",\r\n     //支持全局搜索\r\n     globalSearch: true,\r\n     localSearch: true,\r\n \r\n     uploadHash: 'md5',\r\n     hash: 'md5',\r\n     key: 'mobile',\r\n     defaultRoot: DEFAULT_ROOT_ID,\r\n \r\n     guide: [\r\n       { key: 'account', label: 'ORCHES-C-ACCOUNT', type: 'string', help: '登录官网从cookies中获取ORCHES系列参数', required: true },\r\n       { key: 'token', label: 'ORCHES-C-TOKEN', type: 'string', required: true },\r\n       { key: 'mobile', label: '手机号', type: 'string', required: true },\r\n       { key: 'root', label: '初始目录ID', type: 'string', required: false },\r\n     ]\r\n   }\r\n \r\n   constructor(app, config) {\r\n     this.app = app\r\n     this.getConfig = Manager.getInstance(app, config)\r\n   }\r\n \r\n   /**\r\n   * Lists or search files\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {object} [options] list options\r\n   * @param {object} [options.sort] sort\r\n   * @param {object} [options.search] search\r\n   * @param {string} [key] key\r\n   * @return {array}\r\n   *\r\n   * @api public\r\n   */\r\n   async list(id, { search, orderBy, perPage, nextPage } = {}) {\r\n     let { cookie, mobile } = await this.getConfig()\r\n     let [fid, isFile] = getRealId(id)\r\n \r\n     if (isFile) {\r\n       return []\r\n     }\r\n \r\n     const {\r\n       request,\r\n       utils: { timestamp },\r\n     } = this.app\r\n \r\n     let usePagination = !!perPage\r\n \r\n     let offset = nextPage || 0, size = perPage || 200, files = []\r\n \r\n     do {\r\n       let params = {\r\n         catalogID: fid,\r\n         sortDirection: 1,\r\n         filterType: 0,\r\n         catalogSortType: 0,\r\n         contentSortType: 0,\r\n         startNumber: offset + 1,\r\n         endNumber: offset + size,\r\n         commonAccountInfo: { account: mobile, accountType: 1 }\r\n       }\r\n \r\n       if (orderBy) {\r\n         let [sortKey, isAsc] = orderBy\r\n         params.catalogSortType = params.contentSortType = sortKey == 'name' ? '0' : sortKey == 'ctime' ? '1' : '0'\r\n         params.sortDirection = isAsc ? 1 : 0\r\n       }\r\n \r\n       let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/catalog/v1.0/getDisk', {\r\n         data: params,\r\n         headers: {\r\n           ...createHeaders(params),\r\n           cookie,\r\n         },\r\n         contentType: 'json',\r\n       })\r\n \r\n \r\n       if (!data.success) {\r\n         return this.app.error({ message: data.message })\r\n       }\r\n \r\n       if (data.data.result.resultCode != '0') this.app.error({ message: data.data.result.resultDesc })\r\n \r\n       data = data.data.getDiskResult\r\n \r\n       if (data?.catalogList) {\r\n         for (let i of data.catalogList) {\r\n           files.push({\r\n             id: id + '/' + i.catalogID,\r\n             name: i.catalogName,\r\n             type: 'folder',\r\n             size: i.size,\r\n             ctime: timestamp(datetimeFormat(i.createTime)),\r\n             mtime: timestamp(datetimeFormat(i.updateTime)),\r\n             extra: {\r\n               fid: id + '/' + i.catalogID,\r\n               parent_id: id,\r\n             },\r\n           })\r\n         }\r\n       }\r\n \r\n       if (data?.contentList) {\r\n         for (let i of data.contentList) {\r\n           files.push({\r\n             id: id + '/~' + i.contentID,\r\n             name: i.contentName,\r\n             type: 'file',\r\n             size: i.contentSize,\r\n             ctime: timestamp(datetimeFormat(i.uploadTime)),\r\n             mtime: timestamp(datetimeFormat(i.updateTime)),\r\n             thumb: i.thumbnailURL,\r\n             extra: {\r\n               fid: id + '/~' + i.contentID,\r\n               parent_id: id,\r\n               md5: i.digest,\r\n               // path: i.path,\r\n               preview_url: i.presentURL\r\n             },\r\n           })\r\n         }\r\n       }\r\n \r\n       if (offset + size < parseInt(data.nodeCount)) {\r\n         offset += size\r\n       } else {\r\n         offset = null\r\n         break\r\n       }\r\n     } while (!usePagination && offset)\r\n \r\n     let result = {\r\n       id, files\r\n     }\r\n \r\n     if (usePagination && offset) {\r\n       result.nextPage = offset\r\n     }\r\n \r\n     return result\r\n   }\r\n \r\n   // caiyun 没有获取文件详情的单独接口\r\n   // 缺少name !!\r\n   async get(id) {\r\n     let paths = id.split('/')\r\n     let [fid, isFile] = getRealId(id)\r\n \r\n     const data = {\r\n       id,\r\n       type: isFile ? 'file' : 'folder',\r\n       extra: {\r\n         fid: id,\r\n         parent_id: paths.slice(0, -1).join('/')\r\n       },\r\n     }\r\n \r\n     if (data.type == 'file') {\r\n       let { url, max_age } = await this.get_download_url(id)\r\n       data.download_url = url\r\n       data.max_age = max_age\r\n     }\r\n     return data\r\n   }\r\n \r\n   async get_download_url(id) {\r\n     let { cookie, mobile } = await this.getConfig()\r\n     let [fid, isFile] = getRealId(id)\r\n \r\n     const { request } = this.app\r\n \r\n     let params = {\r\n       appName: '',\r\n       contentID: fid,\r\n       commonAccountInfo: { account: mobile, accountType: 1 }\r\n     }\r\n \r\n     let headers = createHeaders(params)\r\n \r\n     try {\r\n \r\n       let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/uploadAndDownload/v1.0/downloadRequest', {\r\n         data: params,\r\n         headers: {\r\n           ...headers,\r\n           'User-Agent':\r\n             'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n           cookie,\r\n \r\n         },\r\n         contentType: 'json',\r\n       })\r\n       if (data?.data?.downloadURL) return { url: data.data.downloadURL, max_age: 1 * 60000 }\r\n     } catch (e) {\r\n       return {}\r\n     }\r\n \r\n   }\r\n \r\n   async mkdir(parentId, name, { check_name_mode = 'refuse' }) {\r\n     const { request } = this.app\r\n     let { cookie, mobile } = await this.getConfig()\r\n     let [fid] = getRealId(parentId)\r\n \r\n     let params = {\r\n       createCatalogExtReq: {\r\n         parentCatalogID: fid,\r\n         newCatalogName: name,\r\n         commonAccountInfo: { account: mobile, accountType: 1 }\r\n       }\r\n     }\r\n \r\n     let headers = createHeaders(params)\r\n \r\n     let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/catalog/v1.0/createCatalogExt', {\r\n       data: params,\r\n       headers: {\r\n         ...headers,\r\n         'User-Agent':\r\n           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n         cookie,\r\n       },\r\n       contentType: 'json',\r\n     })\r\n \r\n     if (!data.success) return this.app.error({ message: data.message })\r\n \r\n     if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\r\n \r\n     let file_id = data.data.catalogInfo.catalogID\r\n \r\n     /*\r\n     parentCatalogId: \"0511YJIR62Bj00019700101000000043\"\r\n     path: \"00019700101000000001/0511YJIR62Bj00019700101000000043/0511YJIR62Bj06720210909171001rec\"\r\n     */\r\n     return {\r\n       id: parentId + '/' + file_id,\r\n       name,\r\n       parent_id: parentId\r\n     }\r\n   }\r\n \r\n   async rename(id, name, { check_name_mode = 'refuse' } = {}) {\r\n     const { request } = this.app\r\n \r\n     let { cookie, mobile } = await this.getConfig()\r\n \r\n     let [fid, isFile, parent_id] = getRealId(id)\r\n \r\n     let params = {\r\n       [isFile ? 'contentID' : 'catalogID']: fid,\r\n       [isFile ? 'contentName' : 'catalogName']: name,\r\n       commonAccountInfo: { \"account\": mobile, \"accountType\": 1 }\r\n     }\r\n \r\n     let headers = createHeaders(params)\r\n \r\n     let { data } = await request.post(`https://yun.139.com/orchestration/personalCloud/${isFile ? 'content' : 'catalog'}/v1.0/${isFile ? 'updateContentInfo' : 'updateCatalogInfo'}`, {\r\n       data: params,\r\n       headers: {\r\n         ...headers,\r\n         'User-Agent':\r\n           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n         cookie,\r\n       },\r\n       contentType: 'json',\r\n     })\r\n \r\n     if (!data.success) {\r\n       if (data.code == '1010010005') {\r\n         return this.app.error({ code: 404 })\r\n       }\r\n       return this.app.error({ message: data.message })\r\n     }\r\n \r\n     if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\r\n \r\n     return {\r\n       id,\r\n       name: data.data.updateContentInfoRes?.contentName || data.data.updateCatalogRes.catalogName,\r\n       parent_id\r\n     }\r\n \r\n   }\r\n \r\n   async rm(id) {\r\n     const { request } = this.app\r\n     const { cookie, mobile } = await this.getConfig()\r\n     let [fid, isFile, parent_id] = getRealId(id)\r\n     let params = {\r\n       \"createBatchOprTaskReq\": {\r\n         \"taskType\": 2,\r\n         \"actionType\": 201,\r\n         \"taskInfo\": {\r\n           \"newCatalogID\": \"\",\r\n           [isFile ? 'contentInfoList' : 'catalogInfoList']: [fid]\r\n         },\r\n         \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\r\n       }\r\n     }\r\n \r\n     let headers = createHeaders(params)\r\n \r\n     let { data, error } = await request.post('https://yun.139.com/orchestration/personalCloud/batchOprTask/v1.0/createBatchOprTask', {\r\n       data: params,\r\n       headers: {\r\n         ...headers,\r\n         'User-Agent':\r\n           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n         cookie,\r\n       },\r\n       contentType: 'json',\r\n     })\r\n     if (!data.success) return this.app.error({ message: data.message })\r\n     if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\r\n \r\n     let taskId = data.data.createBatchOprTaskRes.taskID\r\n \r\n     await this.monitor(taskId)\r\n \r\n     return { id, parent_id }\r\n   }\r\n \r\n   /**\r\n    * mv file/folder\r\n    *\r\n    * @param {string} [id] folder id\r\n    * @return {string | error}\r\n    *\r\n    * @api public\r\n    */\r\n   async mv(id, target_id, { name, copy }) {\r\n     const { request } = this.app\r\n     const { cookie, mobile } = await this.getConfig()\r\n     let [fid, isFile, origin_parent_id] = getRealId(id)\r\n     let [destFid] = getRealId(target_id)\r\n     let params = {\r\n       \"createBatchOprTaskReq\": {\r\n         \"taskType\": copy ? 1 : 3,\r\n         \"actionType\": copy ? '309' : '304',\r\n         \"taskInfo\": {\r\n           \"contentInfoList\": [],\r\n           \"catalogInfoList\": [],\r\n           \"newCatalogID\": destFid,\r\n           [isFile ? 'contentInfoList' : 'catalogInfoList']: [fid]\r\n         },\r\n         \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\r\n       }\r\n     }\r\n \r\n     let headers = createHeaders(params)\r\n \r\n     let { data } = await request.post('https://yun.139.com/orchestration/personalCloud/batchOprTask/v1.0/createBatchOprTask', {\r\n       data: params,\r\n       headers: {\r\n         ...headers,\r\n         'User-Agent':\r\n           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n         cookie,\r\n       },\r\n       contentType: 'json',\r\n     })\r\n \r\n     if (!data.success) return this.app.error({ message: data.message })\r\n \r\n     if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\r\n \r\n     let taskId = data.data.createBatchOprTaskRes.taskID\r\n \r\n     let newData = await this.monitor(taskId)\r\n \r\n     if (newData) {\r\n       let newId = target_id + '/' + (isFile ? '~' : '') + newData.id\r\n       if (name) {\r\n         await this.rename(newId, name)\r\n       }\r\n       return { id: newId, origin_parent_id }\r\n     }\r\n \r\n     //不支持目的地存在相同文件，也不支持复制/移动时重命名。 \r\n     return this.app.error({ message: '', code: 501 })\r\n   }\r\n \r\n   async hashFile(fileId, { name, hash }) {\r\n     let res = await this.beforeUpload(fileId, {\r\n       name, size: 1, md5: hash\r\n     })\r\n \r\n     let fastSave = !res.redirectionUrl\r\n     if (fastSave) {\r\n       return {\r\n         id: fileId + '/~' + res.newContentIDList[0].contentID\r\n       }\r\n     } else {\r\n       return {}\r\n     }\r\n   }\r\n \r\n   async monitor(taskId, timeout = 5 * 1000) {\r\n     const { request } = this.app\r\n     const { cookie, mobile } = await this.getConfig()\r\n     let startTime = Date.now()\r\n \r\n     let params = {\r\n       \"queryBatchOprTaskDetailReq\": {\r\n         \"taskID\": taskId,\r\n         \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\r\n       }\r\n     }\r\n \r\n     while (Date.now() - startTime < timeout) {\r\n       let headers = createHeaders(params)\r\n \r\n       let { data, error } = await request.post('https://yun.139.com/orchestration/personalCloud/batchOprTask/v1.0/queryBatchOprTaskDetail', {\r\n         data: params,\r\n         headers: {\r\n           ...headers,\r\n           'User-Agent':\r\n             'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n           cookie,\r\n         },\r\n         contentType: 'json',\r\n       })\r\n \r\n       if (data?.data?.queryBatchOprTaskDetailRes?.batchOprTask?.progress == 100) {\r\n         let taskType = data.data.queryBatchOprTaskDetailRes.batchOprTask.taskType\r\n         let destId, base = data.data.queryBatchOprTaskDetailRes\r\n \r\n         // copy get destId\r\n         if (taskType == 1) {\r\n           destId = base.contentList?.[0]?.rstId || base.catalogList?.[0]?.rstId\r\n         } else {\r\n           destId = base.contentList?.[0]?.srcId || base.catalogList?.[0]?.srcId\r\n         }\r\n         return { id: destId }\r\n       }\r\n \r\n       await sleep(500)\r\n     }\r\n \r\n   }\r\n \r\n   async resumeUpload(uploadId, retry = 2) {\r\n     const { cookie, mobile } = await this.getConfig()\r\n \r\n     let [taskId, path, contentId] = uploadId.split('-')\r\n     console.log('resumeUpload', taskId, path, contentId)\r\n     let params = {\r\n       \"account\": '',\r\n       \"taskList\": [{\r\n         \"contentID\": contentId,\r\n         \"path\": path,\r\n         \"taskID\": taskId\r\n       }],\r\n       \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\r\n     }\r\n \r\n     let { data } = await this.app.request.post('https://yun.139.com/orchestration/personalCloud/uploadAndDownload/v1.0/syncUploadTaskInfo', {\r\n       data: params,\r\n       headers: {\r\n         ...createHeaders(params),\r\n         'User-Agent':\r\n           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n         cookie,\r\n       },\r\n       contentType: 'json',\r\n     })\r\n \r\n     //签名校验失败\r\n     if (data.code == '1010010014' && retry > 0) {\r\n       // retry\r\n       return await resumeUpload(uploadId, retry--)\r\n     }\r\n     if (!data.success) {\r\n       return {\r\n         error: { message: '[' + data.data?.result.resultCode || 'unknow' + ']' + data.message }\r\n       }\r\n     }\r\n     //this.app.error({ message: '[' + data.data.result.resultCode + ']' + data.message })\r\n \r\n     // console.log('resume from', data.data.array[0].fileUploadInfos[0])\r\n     return {\r\n       start: +data.data.array[0].fileUploadInfos[0].pgs,\r\n       taskId,\r\n       contentId,\r\n       uploadUrl: data.data.array[0].uploadURL\r\n     }\r\n   }\r\n \r\n   async beforeUpload(id, { name, size, md5 }) {\r\n     const { cookie, mobile } = await this.getConfig()\r\n     const [fid] = getRealId(id)\r\n \r\n     const params = {\r\n       \"manualRename\": 2,\r\n       \"operation\": 0,\r\n       \"fileCount\": 1,\r\n       \"totalSize\": size,\r\n       \"uploadContentList\": [{\r\n         \"contentName\": name,\r\n         \"contentSize\": size,\r\n         // \"digest\": \"5a3231986ce7a6b46e408612d385bafa\"\r\n       }],\r\n       \"parentCatalogID\": fid,\r\n       \"newCatalogName\": \"\",\r\n       \"commonAccountInfo\": { \"account\": mobile, \"accountType\": 1 }\r\n     }\r\n \r\n     if (md5) {\r\n       params.uploadContentList[0].digest = md5\r\n     }\r\n     //console.log(params)\r\n \r\n     let headers = createHeaders(params)\r\n \r\n     let { data } = await this.app.request.post('https://yun.139.com/orchestration/personalCloud/uploadAndDownload/v1.0/pcUploadFileRequest', {\r\n       data: params,\r\n       headers: {\r\n         ...headers,\r\n         'User-Agent':\r\n           'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',\r\n         cookie,\r\n       },\r\n       contentType: 'json',\r\n     })\r\n \r\n     if (!data.success) return this.app.error({ message: data.message })\r\n \r\n     if (data.data.result.resultCode != '0') return this.app.error({ message: data.data.result.resultDesc })\r\n \r\n     let res = data.data.uploadResult\r\n \r\n     return {\r\n       uploadUrl: res.redirectionUrl,\r\n       taskId: res.uploadTaskID,\r\n       contentId: res.newContentIDList[0].contentID\r\n     }\r\n   }\r\n \r\n   async upload(parent_id, stream, { size, name, manual, ...rest }) {\r\n     const { app } = this\r\n     const [fid] = getRealId(parent_id)\r\n     console.log('UPLOAD', rest.uploadId)\r\n     let res = rest.uploadId ?\r\n       await this.resumeUpload(rest.uploadId) :\r\n       await this.beforeUpload(parent_id, { name, size, ...rest })\r\n \r\n\r\n     //恢复状态发生错误，尝试重新创建\r\n     if (rest.uploadId && res.error) {\r\n       console.log('create new upload session', res.error)\r\n       res = await this.beforeUpload(parent_id, { name, size, ...rest })\r\n     }\r\n \r\n     let { uploadUrl, taskId, contentId, start = 0 } = res\r\n \r\n     // fast upload\r\n     if (!uploadUrl) {\r\n       console.log('fast upload success')\r\n       //no need\r\n       let ret = { id: parent_id + '/~' + contentId, name, parent_id }\r\n \r\n       if (manual) {\r\n         ret.completed = true\r\n       }\r\n \r\n       return ret\r\n     }\r\n \r\n     let uploadId = taskId + '-' + fid + '-' + contentId\r\n     const done = async (customStream) => {\r\n       let { status, data } = await app.request.post(uploadUrl, {\r\n         data: customStream || stream,\r\n         contentType: 'stream',\r\n         responseType: 'text',\r\n         signal: rest.signal,\r\n         highWaterMark: 1024 * 1024,\r\n         headers: {\r\n           'Accept': '*/*',\r\n           'Content-Type': `text/plain;name=${unicode(name)}`,\r\n           'contentSize': size,\r\n \r\n           'range': `bytes=${start}-${size - 1}`,\r\n           'content-length': size - start,\r\n \r\n           'uploadtaskID': taskId,\r\n           'rangeType': 0,\r\n           'Referer': 'https://yun.139.com/',\r\n           'x-SvcType': 1,\r\n           'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'\r\n         }\r\n       })\r\n \r\n \r\n       if (status != 200) return this.app.error({ code: status })\r\n \r\n       return { id: parent_id + '/~' + contentId, name, parent_id }\r\n \r\n     }\r\n \r\n     if (manual) {\r\n       return {\r\n         uploadId, start, done\r\n       }\r\n     } else {\r\n       return await done(stream)\r\n     }\r\n \r\n     // let passStream = app.streamReader(stream, { highWaterMark: 1.5 * UPLOAD_PART_SIZE })\r\n     // let part = Math.ceil(size / UPLOAD_PART_SIZE)\r\n     // let point = 0\r\n     // for (let i = 0; i < part; i++) {\r\n     //   let buffer = await passStream.read(UPLOAD_PART_SIZE)\r\n     //   let ret = await app.request.post(upload_url, {\r\n     //     data: buffer,\r\n     //     contentType: 'buffer',\r\n     //     responseType: 'text',\r\n     //     headers: {\r\n     //       'Accept': '*/*',\r\n     //       'Content-Type': `text/plain;name=${unicode(name)}`,\r\n     //       'contentSize': size,\r\n \r\n     //       'range': `bytes=${point}-${point + buffer.length - 1}`,\r\n     //       'content-length': buffer.length,\r\n \r\n     //       'uploadtaskID': taskId,\r\n     //       'rangeType': 0,\r\n     //       'Referer': 'https://yun.139.com/',\r\n     //       'x-SvcType': 1,\r\n     //       'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36'\r\n     //     }\r\n     //   })\r\n     //   console.log(ret, '<<')\r\n     //   point += buffer.length\r\n     // }\r\n \r\n   }\r\n }\r\n \r\n module.exports = { driver: Driver }"},{"hash":"6eb35a1ec816e7bff81deaa9ff4cfde6","name":"CTCCloud","namespace":"sharelist.plugin.ctc","version":"1.0.0","license":"MIT","description":"天翼云盘","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/ctc/index.js","icon":"https://cloud.189.cn/web/logo.ico","script":"//===Sharelist===\r\n// @name         CTCCloud\r\n// @namespace    sharelist.plugin.ctc\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  天翼云盘\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/ctc/index.js\r\n// @icon         https://cloud.189.cn/web/logo.ico\r\n//===/Sharelist==\r\n\r\nconst API_ENDPOINT = 'https://cloud.189.cn'\r\n\r\nconst UPLOAD_PART_SIZE = 10 * 1024 * 1024\r\n\r\nconst crypto = require('crypto')\r\n\r\nconst NodeRSA = require('node-rsa')\r\n\r\nconst safeJSONParse = (data) =>\r\n  JSON.parse(\r\n    data.replace(/(?<=:\\s*)(\\d+)/g, ($0, $1) => {\r\n      if (!Number.isSafeInteger(+$1)) {\r\n        return `\"${$1}\"`\r\n      } else {\r\n        return $1\r\n      }\r\n    }),\r\n  )\r\n\r\nconst sleep = (time) => new Promise((resolve) => setTimeout(resolve, time))\r\n\r\nconst hmac = (v, key) => {\r\n  return crypto.createHmac('sha1', key).update(v).digest('hex')\r\n}\r\n\r\nconst md5 = (v) => crypto.createHash('md5').update(v).digest('hex')\r\n\r\nconst aesEncrypt = (data, key, iv = \"\") => {\r\n  let cipher = crypto.createCipheriv('aes-128-ecb', key, iv);\r\n  let encrypted = cipher.update(data, 'utf8', 'hex');\r\n  encrypted += cipher.final('hex');\r\n  return encrypted\r\n}\r\n\r\nconst rsaEncrypt = (data, publicKey, charset = 'base64') => {\r\n  publicKey = '-----BEGIN PUBLIC KEY-----\\n' + publicKey + '\\n-----END PUBLIC KEY-----'\r\n\r\n  let key = new NodeRSA(publicKey, { encryptionScheme: 'pkcs1' })\r\n  return key.encrypt(data, charset)\r\n}\r\n\r\nconst uuid = (v) => {\r\n  return v.replace(/[xy]/g, (e) => {\r\n    var t = 16 * Math.random() | 0\r\n      , i = \"x\" === e ? t : 3 & t | 8;\r\n    return i.toString(16)\r\n  })\r\n}\r\n\r\nconst qs = d => Object.keys(d).map(i => `${i}=${encodeURI(d[i])}`).join('&')\r\n\r\nconst parseHeaders = v => {\r\n  let ret = {}\r\n  for (let pair of decodeURIComponent(v).split('&').map(i => i.split('='))) {\r\n    ret[pair[0].toLowerCase()] = pair.slice(1).join('=')\r\n  }\r\n  return ret\r\n}\r\n/**\r\n * auth manager class\r\n */\r\nclass Manager {\r\n  static getInstance(app, config) {\r\n    if (!this.instance) {\r\n      this.instance = new Manager(app)\r\n    }\r\n\r\n    // this.instance.add(config)\r\n    return this.instance.createGetter(config, app)\r\n  }\r\n\r\n  constructor(app) {\r\n    this.app = app\r\n  }\r\n\r\n  createGetter(config, app) {\r\n    let safeRequest = async (url, options, retry = 3) => {\r\n      let { data, status, headers } = await app.request(url, options)\r\n      if (JSON.stringify(data).includes('InvalidSessionKey')) {\r\n        if (retry > 0) {\r\n          await this.refreshCookie(config)\r\n          options.headers.cookie = config.cookie\r\n          return await safeRequest(url, options, --retry)\r\n        } else {\r\n          app.error({ message: 'Invalid Session Key' })\r\n        }\r\n      }\r\n\r\n      return { data, status, headers }\r\n    }\r\n    return async () => {\r\n      if (\r\n        !config.account ||\r\n        !config.cookie\r\n      ) {\r\n        await this.refreshCookie(config)\r\n      }\r\n      return {\r\n        ...config,\r\n        safeRequest\r\n      }\r\n    }\r\n  }\r\n\r\n  async needCaptcha(data, cookie) {\r\n    let resp = await this.app.request.post('https://open.e.189.cn/api/logbox/oauth2/needcaptcha.do', {\r\n      data,\r\n      headers: {\r\n        cookie: cookie,\r\n        referer: 'https://open.e.189.cn/api/logbox/oauth2/loginSubmit.do',\r\n      },\r\n      contentType: 'form',\r\n      responseType: 'text'\r\n    })\r\n\r\n    if (resp?.data == '1') {\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  async getCaptcha(captchaToken, reqId, cookie) {\r\n    let resp = await this.app.request(\r\n      `https://open.e.189.cn/api/logbox/oauth2/picCaptcha.do?token=${captchaToken}&REQID=${reqId}&rnd=${Date.now()}`,\r\n      {\r\n        headers: {\r\n          cookie,\r\n          Referer: 'https://open.e.189.cn/api/logbox/oauth2/loginSubmit.do',\r\n        },\r\n        responseType: 'buffer',\r\n      },\r\n    )\r\n\r\n    if (resp.error) return { error: resp.error }\r\n\r\n    let imgBase64 =\r\n      'data:' + resp.headers['content-type'] + ';base64,' + Buffer.from(resp.data).toString('base64')\r\n\r\n    return await this.app.ocr(imgBase64)\r\n  }\r\n\r\n  async getSessionKey(cookie) {\r\n    let { data: baseData } = await this.app.request(`${API_ENDPOINT}/v2/getUserBriefInfo.action?noCache=${Math.random()}`, {\r\n      headers: {\r\n        cookie,\r\n        // accept: 'application/json;charset=UTF-8'\r\n      },\r\n      responseType: 'json'\r\n    })\r\n    return baseData.sessionKey\r\n  }\r\n\r\n  /**\r\n   * refreshCookie\r\n   *\r\n   * @param {object} {account , password}\r\n   * @param {boolean} force\r\n   * @return {object} { credentials | error }\r\n   * @api private\r\n   */\r\n  async refreshCookie(config) {\r\n    let { account, password, cookie_login_user } = config\r\n\r\n    const { request } = this.app\r\n\r\n    if (cookie_login_user) {\r\n      const cookie = `COOKIE_LOGIN_USER=${cookie_login_user};`\r\n      const sessionKey = await this.getSessionKey(cookie)\r\n\r\n      config.sessionKey = sessionKey\r\n      config.cookie = cookie\r\n\r\n      config.key = account\r\n      return\r\n    }\r\n\r\n    //0 准备工作： 获取必要数据\r\n    let defaultHeaders = {\r\n      'User-Agent':\r\n        'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',\r\n    }\r\n    let { data, headers } = await request.get(\r\n      `${API_ENDPOINT}/api/portal/loginUrl.action?redirectURL=https://cloud.189.cn/web/redirect.html`,\r\n      {\r\n        headers: { ...defaultHeaders },\r\n        responseType: 'text',\r\n      },\r\n    )\r\n\r\n    let { data: data2 } = await request.post(`https://open.e.189.cn/api/logbox/config/encryptConf.do`, {\r\n      data: {\r\n        appId: 'cloud'\r\n      }\r\n    })\r\n    let { pubKey, pre, upSmsOn } = data2.data\r\n\r\n    let captchaToken = (data.match(/name='captchaToken' value='(.*?)'>/) || ['', ''])[1],\r\n      returnUrl = (data.match(/returnUrl = '(.*?)'\\,/) || ['', ''])[1],\r\n      paramId = (data.match(/var paramId = \"(.*?)\";/) || ['', ''])[1],\r\n      lt = (data.match(/var lt = \"(.*?)\";/) || ['', ''])[1],\r\n      reqId = (data.match(/reqId = \"(.*?)\";/) || ['', ''])[1]\r\n\r\n    // console.log(headers, pubKey)\r\n    let cookie = headers['set-cookie']\r\n\r\n    let formdata = {\r\n      appKey: 'cloud',\r\n      accountType: '01',\r\n      userName: `${pre}${rsaEncrypt(account, pubKey)}`,\r\n      password: `${pre}${rsaEncrypt(password, pubKey)}`,\r\n      userName: account,\r\n      password: password,\r\n      validateCode: '',\r\n      captchaToken: captchaToken,\r\n      returnUrl: returnUrl,\r\n      mailSuffix: '@189.cn',\r\n      dynamicCheck: 'FALSE',\r\n      clientType: '1',\r\n      cb_SaveName: '1',\r\n      isOauth2: 'false',\r\n      state: '',\r\n      paramId: paramId,\r\n    }\r\n    // console.log(pubKey, pre, formdata)\r\n    // return this.app.error({ message: 'haha' })\r\n    let retry = 3\r\n    let needcaptcha = await this.needCaptcha(\r\n      {\r\n        accountType: '01',\r\n        userName: account,\r\n        appKey: 'cloud',\r\n      },\r\n      cookie,\r\n    )\r\n\r\n    while (retry--) {\r\n      // 验证码\r\n      if (needcaptcha) {\r\n        let { error, code } = await this.getCaptcha(captchaToken, reqId, cookie)\r\n\r\n        if (error) return { error }\r\n\r\n        code = code.replace(/\\n/g, '')\r\n        if (code.length == 4) {\r\n          formdata.validateCode = code\r\n        } else {\r\n          continue\r\n        }\r\n\r\n      }\r\n\r\n      // 登陆\r\n      let { data } = await request.post('https://open.e.189.cn/api/logbox/oauth2/loginSubmit.do', {\r\n        headers: {\r\n          Referer: 'https://open.e.189.cn/api/logbox/oauth2/unifyAccountLogin.do',\r\n          reqid: reqId,\r\n          lt: lt,\r\n        },\r\n        data: formdata,\r\n        contentType: 'form',\r\n        responseType: 'json'\r\n      })\r\n\r\n      //验证码错误\r\n      if (data.result == -2) {\r\n        console.log('validateCode:[' + formdata.validateCode + '] error')\r\n        continue\r\n      }\r\n      if (!data.toUrl) return this.app.error({ message: data.msg })\r\n\r\n      let { headers } = await request.get(data.toUrl, {\r\n        followRedirect: false,\r\n        headers: {\r\n          ...defaultHeaders,\r\n          referer: 'https://open.e.189.cn/'\r\n        },\r\n        responseType: 'text',\r\n      })\r\n      //COOKIE_LOGIN_USER=xxxxx;\r\n      let loginUser = headers?.['set-cookie'].match(/COOKIE_LOGIN_USER=(?<token>[a-z\\d]+)/i)?.groups.token\r\n\r\n      if (!loginUser) return this.app.error({ message: 'login failed. Can not get cookies!' })\r\n\r\n      const loginCookie = `COOKIE_LOGIN_USER=${loginUser};`\r\n      const sessionKey = await this.getSessionKey(loginCookie)\r\n\r\n      config.cookie = loginCookie\r\n      config.sessionKey = sessionKey\r\n      config.updated_at = Date.now()\r\n\r\n      config.key = account\r\n\r\n      return\r\n    }\r\n\r\n    return this.app.error({ message: `Login failed` })\r\n  }\r\n}\r\n\r\nclass Driver {\r\n  static options = {\r\n    protocol: \"ctc\",\r\n\r\n    //支持全局搜索\r\n    globalSearch: true,\r\n    localSearch: true,\r\n\r\n    hash: 'md5',\r\n    uploadHash: 'md5_chunk',\r\n    key: 'client_id',\r\n    defaultRoot: '-11',\r\n\r\n    guide: [\r\n      {\r\n        key: 'type',\r\n        label: '类型 / Type',\r\n        type: 'string',\r\n        required: true,\r\n        options: [\r\n          { value: '1', label: '个人版' },\r\n          // { value: '2', label: '家庭版' },\r\n          // { value: '3', label: '企业版' }\r\n        ],\r\n      },\r\n      { key: 'account', label: '手机号 / Account', type: 'string', required: true },\r\n      { key: 'password', label: '密码 / Password', type: 'string', required: true },\r\n      { key: 'cookie_login_user', label: 'COOKIE_LOGIN_USER', type: 'string', required: false, help: 'Cookies 中的COOKIE_LOGIN_USER字段，若提供此项则优先使用Cookies登录。' },\r\n      {\r\n        key: 'root',\r\n        label: '初始文件夹ID / Root Id',\r\n        help: 'https://cloud.189.cn/web/main/file/folder/xxxx 地址中 xxxx 的部分',\r\n        type: 'string',\r\n      },\r\n    ]\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.getConfig = Manager.getInstance(app, config)\r\n  }\r\n\r\n  /**\r\n   * 列出目录\r\n   *\r\n   * @param {string} [id] 文件(目录)id 唯一值\r\n   * \r\n   * @param {object} [options] 参数\r\n   * @param {object} [options.order_by] 排序\r\n   * @param {object} [options.page] 页码\r\n   * @param {object} [options.per_page] 每页条目数\r\n   * @param {object} [options.search] 搜索内容\r\n   * \r\n   * @return {object}\r\n   *\r\n   * @api public {Array<file>}\r\n   *\r\n   */\r\n  async list(id, { search, local_search, orderBy, perPage, nextPage } = {}) {\r\n    const {\r\n      utils: { timestamp },\r\n    } = this.app\r\n\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n\r\n    let usePagination = !!perPage\r\n\r\n    const files = []\r\n\r\n    let isSearch = !!search\r\n\r\n    nextPage = nextPage || 1\r\n\r\n    let url = `${API_ENDPOINT}/api/open/file/${isSearch ? 'searchFiles' : 'listFiles'}.action`\r\n\r\n    let params = {\r\n      folderId: id,\r\n      inGroupSpace: false,\r\n      mediaType: 0,\r\n      iconOption: 5,\r\n      descending: true,\r\n      orderBy: 'filename',\r\n      pageSize: usePagination ? perPage : 1000,\r\n      noCache: Math.random(),\r\n    }\r\n\r\n\r\n    if (orderBy) {\r\n      let [sortKey, isAsc] = orderBy\r\n      params.orderBy = sortKey == 'name' ? 'filename' : sortKey == 'mtime' ? 'lastOpTime' : sortKey == 'size' ? 'filesize' : 'filename'\r\n      params.descending = isAsc ? false : true\r\n    }\r\n\r\n    if (isSearch) {\r\n      params.filename = search\r\n      params.recursive = !!local_search ? 0 : 1\r\n    }\r\n\r\n    do {\r\n\r\n      let { data } = await safeRequest(url, {\r\n        data: {\r\n          ...params,\r\n          pageNum: nextPage\r\n        },\r\n        headers: {\r\n          cookie,\r\n          // default format is xml\r\n          accept: 'application/json;charset=UTF-8',\r\n          // 'sign-type': 1,\r\n        },\r\n        responseType: 'text',\r\n      })\r\n\r\n      data = safeJSONParse(data)\r\n\r\n      if (data?.errorCode) return this.app.error({ message: data.errorMsg })\r\n\r\n      const vo = isSearch ? data : data.fileListAO\r\n\r\n      if (vo?.folderList) {\r\n        for (let i of vo.folderList) {\r\n          files.push({\r\n            id: i.id,\r\n            name: i.name,\r\n            type: 'folder',\r\n            size: i.size,\r\n            ctime: timestamp(i.createDate),\r\n            mtime: timestamp(i.lastOpTime),\r\n            extra: {\r\n              fid: i.id,\r\n              parent_id: i.parentId,\r\n              count: i.fileCount,\r\n            },\r\n          })\r\n        }\r\n      }\r\n\r\n      if (vo?.fileList) {\r\n        for (let i of vo.fileList) {\r\n          files.push({\r\n            id: i.id,\r\n            name: i.name,\r\n            type: 'file',\r\n            size: i.size,\r\n            ctime: timestamp(i.createDate),\r\n            mtime: timestamp(i.lastOpTime),\r\n            thumb: i.icon?.smallUrl,\r\n            extra: {\r\n              fid: i.id,\r\n              parent_id: id,\r\n              md5: i.md5.toLowerCase(),\r\n            },\r\n          })\r\n        }\r\n      }\r\n\r\n      if (nextPage * params.pageSize < parseInt(data.recordCount)) {\r\n        nextPage++\r\n      } else {\r\n        break\r\n      }\r\n    } while (!usePagination && nextPage)\r\n\r\n\r\n    let result = {\r\n      id, files\r\n    }\r\n\r\n    if (usePagination && nextPage) {\r\n      result.nextPage = nextPage\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * get file\r\n   *\r\n   * @param {string} [id] path id\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async get(id, skipDownloadUrl = false) {\r\n\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n\r\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/portal/getFileInfo.action`, {\r\n      headers: {\r\n        cookie,\r\n        // default format is xml\r\n        accept: 'application/json;charset=UTF-8',\r\n      },\r\n      data: {\r\n        noCache: Math.random(),\r\n        fileId: id,\r\n      },\r\n    })\r\n\r\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\r\n    let result = {\r\n      id: data.fileId,\r\n      name: data.fileName,\r\n      type: data.isFolder ? 'folder' : 'file',\r\n      size: data.fileSize,\r\n      ctime: data.createTime,\r\n      mtime: data.lastOpTime,\r\n      // download_url: data.isFolder ? '' : `https:${data.downloadUrl}`,\r\n      extra: {\r\n        fid: data.fileId,\r\n        parent_id: data.parentId,\r\n        downloadUrl: data.downloadUrl\r\n      },\r\n    }\r\n\r\n    if (data.imageInfo?.icon) {\r\n      result.thumb = data.imageInfo.icon.smallUrl\r\n    }\r\n    else if (data.audioInfo?.icon) {\r\n      result.thumb = data.audioInfo.icon.smallUrl\r\n    }\r\n    else if (data.videoInfo?.icon) {\r\n      result.thumb = data.videoInfo.icon.smallUrl\r\n    }\r\n\r\n    if (!skipDownloadUrl && !result.download_url && result.type != 'folder') {\r\n      let { url, max_age } = await this.get_download_url(id, 'https:' + data.downloadUrl)\r\n      if (url) {\r\n        result.download_url = url\r\n        result.max_age = max_age\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  async get_download_url(id, download_url) {\r\n    if (!download_url) {\r\n      let res = await this.get(id, true)\r\n      download_url = res.extra.downloadUrl\r\n    }\r\n    let { cookie } = await this.getConfig()\r\n\r\n    if (download_url) {\r\n      let { headers } = await this.app.request.get(download_url, {\r\n        followRedirect: false,\r\n        responseType: 'text',\r\n        headers: {\r\n          cookie,\r\n          'User-Agent':\r\n            'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',\r\n        },\r\n      })\r\n\r\n      download_url = headers?.location\r\n\r\n      // get oss link\r\n      if (download_url) {\r\n        let { headers } = await this.app.request.get(download_url, {\r\n          followRedirect: false,\r\n          responseType: 'text',\r\n          headers: {\r\n            'User-Agent':\r\n              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36',\r\n          },\r\n        })\r\n\r\n        download_url = headers?.location\r\n      }\r\n\r\n      if (download_url) {\r\n        let expired_at = download_url.match(/Expires=(?<expired_at>\\d+)/i)?.groups.expired_at || 0\r\n        let max_age = 0\r\n        if (expired_at) {\r\n          max_age = +expired_at * 1000 - Date.now()\r\n        }\r\n\r\n        return { url: download_url, max_age }\r\n      }\r\n    }\r\n\r\n    return { error: {} }\r\n  }\r\n\r\n  async mkdir(id, name, { check_name_mode = 'refuse' }) {\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/file/createFolder.action?noCache=${Math.random()}`, {\r\n      method: 'POST',\r\n      headers: {\r\n        cookie,\r\n        accept: 'application/json;charset=UTF-8',\r\n      },\r\n      contentType: 'form',\r\n      data: {\r\n        folderName: name,\r\n        parentFolderId: id,\r\n      },\r\n    })\r\n\r\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      parent_id: id\r\n    }\r\n  }\r\n\r\n  async rm(id) {\r\n    let originData = await this.get(id, true)\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/batch/createBatchTask.action?noCache=${Math.random()}`, {\r\n      method: 'POST',\r\n      headers: {\r\n        cookie,\r\n        accept: 'application/json;charset=UTF-8',\r\n      },\r\n      contentType: 'form',\r\n      data: {\r\n        type: 'DELETE',\r\n        taskInfos: [{ \"fileId\": id, \"fileName\": originData.name, \"isFolder\": originData.type == 'folder' ? 1 : 0 }],\r\n        targetFolderId: ''\r\n      },\r\n    })\r\n\r\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\r\n\r\n    let taskId = data.taskId\r\n\r\n    await this.monitor({ taskId, type: 'DELETE' })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      parent_id: originData.extra.parent_id\r\n    }\r\n  }\r\n\r\n  async mv(id, target_id, { copy, name } = {}) {\r\n    let originData = await this.get(id, true)\r\n\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/batch/createBatchTask.action?noCache=${Math.random()}`, {\r\n      method: 'POST',\r\n      headers: {\r\n        cookie,\r\n        accept: 'application/json;charset=UTF-8',\r\n      },\r\n      contentType: 'form',\r\n      data: {\r\n        type: copy ? 'COPY' : 'MOVE',\r\n        taskInfos: [{ \"fileId\": id, \"fileName\": originData.name, \"isFolder\": originData.type == 'folder' ? 1 : 0 }],\r\n        targetFolderId: target_id\r\n      },\r\n    })\r\n\r\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\r\n\r\n    let taskId = data.taskId\r\n\r\n    let res = await this.monitor({ taskId, type: copy ? 'COPY' : 'MOVE' })\r\n\r\n    if (res) {\r\n      return {\r\n        id: originData.id,\r\n        name: originData.name,\r\n        origin_parent_id: originData.extra.parent_id\r\n      }\r\n    }\r\n    //189cloud 不支持目的地存在相同文件，也不支持复制/移动时，重命名。 \r\n    return this.app.error({ message: '', code: 501 })\r\n  }\r\n\r\n  /**\r\n   * rename file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] new name\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rename(id, name, { check_name_mode = 'refuse' } = {}) {\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n    let { data } = await safeRequest(`${API_ENDPOINT}/api/open/file/renameFolder.action?noCache=${Math.random()}`, {\r\n      method: 'POST',\r\n      headers: {\r\n        cookie,\r\n        accept: 'application/json;charset=UTF-8',\r\n      },\r\n      contentType: 'form',\r\n      data: {\r\n        destFolderName: name,\r\n        folderId: id,\r\n      },\r\n    })\r\n\r\n    if (data.res_code != 0) return this.app.error({ message: data.res_message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      parent_id: data.parentId\r\n    }\r\n  }\r\n\r\n  async generate_rsa_key() {\r\n    if (!this.rsa_key || (this.rsa_key.expire - Date.now() < 5 * 60 * 1000)) {\r\n      let { cookie, safeRequest } = await this.getConfig()\r\n      let { data } = await safeRequest(`${API_ENDPOINT}/api/security/generateRsaKey.action?noCache=${Math.random()}`, {\r\n        headers: {\r\n          cookie,\r\n          accept: 'application/json;charset=UTF-8',\r\n        },\r\n        responseType: 'json'\r\n      })\r\n      console.log('update rsa_key')\r\n      this.rsa_key = data\r\n    }\r\n\r\n    return this.rsa_key\r\n  }\r\n\r\n  async createRequest(url, formData) {\r\n    let { sessionKey } = await this.getConfig()\r\n    let { pkId, pubKey } = await this.generate_rsa_key()\r\n\r\n    let date = Date.now()\r\n    let pkey = uuid(\"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\").slice(0, 16 + 16 * Math.random() | 0)\r\n    let params = aesEncrypt(qs(formData), pkey.substring(0, 16))\r\n    let signature = hmac(`SessionKey=${sessionKey}&Operate=GET&RequestURI=${url}&Date=${date}&params=${params}`, pkey)\r\n    let encryptionText = rsaEncrypt(pkey, pubKey)\r\n\r\n    const headers = {\r\n      signature,\r\n      sessionKey,\r\n      encryptionText,\r\n      pkId,\r\n      'x-request-id': uuid('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'),\r\n      'x-request-date': date,\r\n      'origin': 'https://cloud.189.cn',\r\n      'referer': 'https://cloud.189.cn/'\r\n    }\r\n\r\n    return await this.app.request(`https://upload.cloud.189.cn${url}?params=${params}`, { headers })\r\n  }\r\n\r\n  async singleUpload(id, { size, name, stream, ...rest }) {\r\n    const { app } = this\r\n\r\n    let passStream = app.streamReader(stream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\r\n\r\n    let buffer = await passStream.read(UPLOAD_PART_SIZE)\r\n\r\n    let md5hash = md5(buffer)\r\n\r\n    let { data } = await this.createRequest('/person/initMultiUpload', {\r\n      parentFolderId: id,\r\n      fileName: name,\r\n      fileSize: size,\r\n      sliceSize: UPLOAD_PART_SIZE,\r\n      sliceMd5: md5hash,\r\n      fileMd5: md5hash\r\n    })\r\n\r\n    if (!data?.code == 'SUCCESS') return this.app.error({ message: 'a error occurred before upload.' })\r\n\r\n    let { uploadFileId, fileDataExists } = data.data\r\n\r\n    if (fileDataExists == 0) {\r\n\r\n      // Skip step\r\n      // let { data: d1, status } = await this.createRequest(\"/person/getUploadedPartsInfo\", {\r\n      //   uploadFileId\r\n      // })\r\n\r\n      let chunk_base64 = Buffer.from(md5hash, 'hex').toString('base64')\r\n      let { data: uploadData } = await this.createRequest('/person/getMultiUploadUrls', {\r\n        uploadFileId,\r\n        partInfo: `1-${chunk_base64}`,\r\n      })\r\n\r\n      uploadData = uploadData?.['uploadUrls'][`partNumber_1`]\r\n\r\n      let res = await app.request(uploadData.requestURL, {\r\n        method: 'put',\r\n        data: buffer,\r\n        contentType: 'buffer',\r\n        responseType: 'text',\r\n        headers: {\r\n          ...parseHeaders(uploadData.requestHeader),\r\n          \"referer\": 'https://cloud.189.cn/',\r\n        }\r\n      })\r\n\r\n      if (res.status != 200) app.error({ message: 'a error occurred during upload.' })\r\n    }\r\n    let { data: res } = await this.createRequest('/person/commitMultiUploadFile', {\r\n      uploadFileId,\r\n      fileMd5: md5hash,\r\n      //fileSize<=10MB,fileMD5 should equal sliceMd5,\r\n      sliceMd5: md5hash,\r\n      lazyCheck: 0,\r\n    })\r\n\r\n    return { id: res.file.userFileId }\r\n  }\r\n\r\n  async fastUpload(id, { size, name, md5 }) {\r\n    if (md5) {\r\n\r\n    }\r\n  }\r\n\r\n  async upload(id, stream, { size, name, manual, ...rest }) {\r\n    if (size <= UPLOAD_PART_SIZE) {\r\n      return await this.singleUpload(id, { size, name, stream, ...rest })\r\n    }\r\n\r\n    const { app } = this\r\n\r\n    let { data } = await this.createRequest('/person/initMultiUpload', {\r\n      parentFolderId: id,\r\n      fileName: name,\r\n      fileSize: size,\r\n      sliceSize: UPLOAD_PART_SIZE,\r\n      lazyCheck: 1\r\n    })\r\n    if (!data?.code == 'SUCCESS' || !data?.data) return this.app.error({ message: 'a error occurred before upload.' })\r\n\r\n    let { uploadFileId } = data.data\r\n    let start = 0\r\n    // 此操作疑似无实际效果\r\n    // await this.createRequest('/person/getUploadedPartsInfo', {\r\n    //   uploadFileId,\r\n    // })\r\n\r\n    const done = async (customStream) => {\r\n\r\n      let part = Math.ceil(size / UPLOAD_PART_SIZE)\r\n      let passStream = app.streamReader(customStream || stream, { highWaterMark: 2 * UPLOAD_PART_SIZE })\r\n      let md5chunk = []\r\n      let md5sum = crypto.createHash('md5')\r\n      for (let i = 1; i <= part; i++) {\r\n        let buffer = await passStream.read(UPLOAD_PART_SIZE)\r\n        let chunk_hash = md5(buffer).toUpperCase()\r\n        let chunk_base64 = Buffer.from(chunk_hash, 'hex').toString('base64')\r\n\r\n        md5chunk.push(chunk_hash)\r\n        md5sum.update(buffer)\r\n\r\n        let { data } = await this.createRequest('/person/getMultiUploadUrls', {\r\n          partInfo: `${i}-${chunk_base64}`,\r\n          uploadFileId,\r\n        })\r\n\r\n        let uploadData = data['uploadUrls'][`partNumber_${i}`]\r\n\r\n        let res = await app.request(uploadData.requestURL, {\r\n          method: 'put',\r\n          data: buffer,\r\n          contentType: 'buffer',\r\n          responseType: 'text',\r\n          headers: parseHeaders(uploadData.requestHeader)\r\n        })\r\n\r\n        if (res.status != 200) app.error({ message: 'a error occurred during upload.' })\r\n      }\r\n\r\n      let uniqueIdentifier = md5sum.digest('hex')\r\n\r\n      // commit\r\n      let { data: res } = await this.createRequest('/person/commitMultiUploadFile', {\r\n        uploadFileId,\r\n        fileMd5: uniqueIdentifier,\r\n        //fileSize<=10MB,fileMD5 should equal sliceMd5,\r\n        sliceMd5: md5(md5chunk.join('\\n')),\r\n        lazyCheck: 1,\r\n      })\r\n      return { id: res.file.userFileId }\r\n    }\r\n\r\n    if (manual) {\r\n      return {\r\n        uploadId: uploadFileId, start, done\r\n      }\r\n    } else {\r\n      return await done(stream)\r\n    }\r\n  }\r\n\r\n  async monitor(params, timeout = 5 * 1000) {\r\n    let { cookie, safeRequest } = await this.getConfig()\r\n\r\n    let startTime = Date.now()\r\n\r\n    while (Date.now() - startTime < timeout) {\r\n      let { data } = await safeRequest(`${API_ENDPOINT}/api/open/batch/checkBatchTask.action?noCache=${Math.random()}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          cookie,\r\n          accept: 'application/json;charset=UTF-8',\r\n        },\r\n        contentType: 'form',\r\n        data: params,\r\n      })\r\n      if (data?.taskStatus == 4) {\r\n        return true\r\n      }\r\n\r\n      await sleep(300)\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = { driver: Driver }"},{"hash":"053e379c1031dc99e10b78cb6e341744","name":"FileFilter","namespace":"sharelist.plugin.file-filter","version":"1.0.0","license":"MIT","description":"提供基础目录过滤、加密功能","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-filter/index.js","script":"//===Sharelist===\r\n// @name         FileFilter\r\n// @namespace    sharelist.plugin.file-filter\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  提供基础目录过滤、加密功能\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-filter/index.js\r\n//===/Sharelist==\r\n\r\n\r\nconst ignore = require('ignore')\r\n\r\nconst isIgnorePath = (p = '', config) => {\r\n  p = p.replace(/^\\//, '')\r\n  return p && ignore().add([].concat(config.acl_file, config.ignores)).ignores(p)\r\n}\r\n\r\nconst isForbiddenPath = () => false\r\n\r\nconst authMethods = {\r\n  basic(key, data) {\r\n    return data.some(i => '' + i === key)\r\n  },\r\n  async http(key, data, request) {\r\n    let { data: res } = await request(data.replace('{key}', key), { responseType: 'text' })\r\n    return res === 'success'\r\n  }\r\n}\r\n\r\nconst cache = {}\r\n\r\nmodule.exports = (sharelist) => {\r\n  const { config, driver, utils: { yaml, safeCall } } = sharelist\r\n\r\n  return {\r\n    config() {\r\n      return [\r\n        { code: 'acl_file', label: '加密文件名', type: 'string', default: '.passwd' },\r\n        { code: 'ignores', label: '忽略路径', type: 'array' },\r\n      ]\r\n    },\r\n\r\n    beforeList({ params, path }) {\r\n      //使用路径模式，提前排除\r\n      if (path && isIgnorePath(path, config)) {\r\n        throw { code: 404 }\r\n      }\r\n\r\n      if (path && isForbiddenPath(path, config)) {\r\n        throw { code: 404 }\r\n      }\r\n    },\r\n\r\n    async afterList({ data, params }) {\r\n      if (!config.acl_file) return\r\n      let hit = data?.files.find(i => i.name == config.acl_file)\r\n\r\n      if (hit) {\r\n        let scope = { id: data.id }\r\n\r\n        let auth = params.auth?.[data.id]\r\n\r\n        if (!auth) throw { code: 401, message: 'Invalid password', scope }\r\n\r\n        let content\r\n\r\n        if (cache[hit.id]) {\r\n          content = cache[hit.id]\r\n        } else {\r\n          await safeCall(async () => {\r\n            content = yaml.parse(await driver.getContent(hit.id))\r\n          })\r\n        }\r\n\r\n        if (!content) throw { code: 401, message: 'Invalid password', scope }\r\n\r\n        cache[hit.id] = content\r\n\r\n        if (await authMethods?.[content.type]('' + auth, content.data, sharelist.request) !== true) {\r\n          throw { code: 401, message: 'Invalid password', scope }\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n  }\r\n}"},{"hash":"f91926e7e086f557af8cdcfa9e3a324c","name":"File System","namespace":"sharelist.plugin.file-system","version":"1.0.0","license":"MIT","description":"挂载本地磁盘","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-system/index.js","script":"//===Sharelist===\r\n// @name         File System\r\n// @namespace    sharelist.plugin.file-system\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  挂载本地磁盘\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/file-system/index.js\r\n//===/Sharelist==\r\n\r\nconst { basename, dirname, posix, join } = require('path')\r\nconst fs = require('fs')\r\nconst os = require('os')\r\nconst { pipeline } = require('stream')\r\nconst crypto = require('crypto')\r\n\r\nconst isWinOS = os.platform() == 'win32'\r\n\r\nconst pipe = (...rest) => new Promise((resolve, reject) => pipeline(...rest, (err) => err ? reject({ message: 'The error occurred during pipe stream' }) : resolve()))\r\n\r\nconst md5 = content => crypto.createHash('md5').update(content).digest(\"hex\")\r\n\r\nconst md5file = (filepath, fast) => new Promise((resolve, reject) => {\r\n  const stream = fs.createReadStream(filepath);\r\n  const hash = crypto.createHash('md5');\r\n  stream.on('data', chunk => {\r\n    hash.update(chunk, 'utf8');\r\n  });\r\n  stream.on('end', () => {\r\n    resolve(hash.digest('hex'))\r\n  });\r\n})\r\n\r\nconst md5fileFast = (filepath, size = 256 * 1024) => {\r\n  fs.open(filepath, 'r', (err, fd) => {\r\n    const buff = Buffer.alloc(size);\r\n    fs.read(fd, buff, 0, buff.length, null, (err, bytesRead, chunk) => {\r\n      if (bytesRead) {\r\n        console.log(bytesRead, `md5: ${md5(chunk.slice(0, bytesRead))}`);\r\n      } else {\r\n        start = false;\r\n        console.timeEnd('readtime');\r\n        fs.closeSync(fd);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nconst fileExist = (file) => new Promise((resolve, reject) => {\r\n  fs.access(file, fs.constants.F_OK, (err) => {\r\n    resolve(err ? false : true)\r\n  });\r\n})\r\n/**\r\n * Convert posix style path to windows style\r\n *\r\n * @param {string} [p]\r\n * @return {string}\r\n */\r\nconst winStyle = (p) =>\r\n  p\r\n    .replace(/^\\/([^\\/]+?)/, '$1:\\\\')\r\n    .replace(/\\//g, '\\\\')\r\n    .replace(/(?<!\\:)\\\\+$/, '')\r\n    .replace(/\\\\{2,}/g, '\\\\')\r\n\r\n/**\r\n * Convert windows style path to posix style\r\n *\r\n * @param {string} [p]\r\n * @return {string}\r\n */\r\nconst posixStyle = (p) =>\r\n  p\r\n    .split('\\\\')\r\n    .join('/')\r\n    .replace(/^([a-z])\\:/i, '/$1')\r\n\r\n/**\r\n * normalize path(posix style) and replace current path\r\n *\r\n * @param {string} [p]\r\n * @return {string}\r\n */\r\nconst normalize = (p) => posix.normalize(p.replace(/\\.\\//, slpath(process.cwd()) + '/'))\r\n\r\nconst slpath = (p) => (isWinOS ? posixStyle(p) : p)\r\n\r\n// const this.ospath = (p) => (isWinOS ? winStyle(p) : (p))\r\n\r\nconst parseRelativePath = (p) => p.replace(/\\.\\//, slpath(process.cwd()) + '/')\r\n// let stat = fs.statSync('D:\\CloudMusic\\Falcom Sound Team jdk - 浮游大陆アルジェス -Introduction-.mp3')\r\n// console.log(stat)\r\n\r\nconst ERROR_CODE = {\r\n  'EBUSY': 423,\r\n}\r\n\r\nconst fileStat = (src) => {\r\n  try {\r\n    return fs.statSync(src)\r\n  } catch (e) { }\r\n}\r\n\r\nconst fileRename = (filepath, targetpath) => {\r\n  try {\r\n    fs.renameSync(filepath, targetpath)\r\n  } catch (e) {\r\n  }\r\n}\r\n\r\nconst createError = (e) => {\r\n  console.log(e)\r\n\r\n  let error = { message: e.code }\r\n  if (ERROR_CODE[e.code]) {\r\n    error.code = ERROR_CODE[e.code]\r\n  }\r\n  return { error }\r\n}\r\n\r\nconst ospath = (p, base = '') => {\r\n  p = base + p\r\n  return isWinOS ? winStyle(p) : (p)\r\n}\r\n\r\nconst encode = (filepath) => {\r\n  return slpath(filepath).substring(1)\r\n}\r\n\r\nclass FileSystem {\r\n  static options = {\r\n    globalSearch: false,\r\n    localSearch: true,\r\n    protocol: \"fs\",\r\n    cache: false,\r\n    mountable: true,\r\n    pagination: false,\r\n    guide: [\r\n      { key: 'root_id', label: '目录地址', type: 'string', required: true },\r\n    ],\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.config = config\r\n  }\r\n\r\n  ospath(p) {\r\n    return ospath(p ? `/${p}` : (this.config.root_id))\r\n  }\r\n\r\n  isRoot(p) {\r\n    return p == this.config.root_id.substring(1)\r\n  }\r\n  /**\r\n    * 列出目录\r\n    *\r\n    * @param {string} [id] 文件(目录)id 唯一值\r\n    * \r\n    * @param {object} [options] 参数\r\n    * @param {object} [options.order_by] 排序\r\n    * @param {object} [options.search] 搜索内容\r\n    * @param {object} [options.page] 页码\r\n    * @param {object} [options.per_page] 每页条目数\r\n    * \r\n    * @return {object}\r\n    *\r\n    * @api public {Array<file>}\r\n    * \r\n    * files.id 资源ID\r\n    * files.name 资源名\r\n    * files.size 资源大小\r\n    * files.type 类型 'folder' | 'file'\r\n    * files.ctime 创建时间\r\n    * files.mtime 修改时间\r\n    */\r\n  async list(id, { search, orderBy } = {}) {\r\n    let filepath = this.ospath(id)\r\n    let stat = fs.statSync(filepath)\r\n\r\n\r\n    if (stat.isDirectory()) {\r\n      let files = []\r\n      fs.readdirSync(filepath).forEach((filename) => {\r\n        let dir = join(filepath, filename) //normalize(id + '/' + filename)\r\n        let stat\r\n        try {\r\n          stat = fs.statSync(dir)\r\n        } catch (e) {\r\n          // console.log(e)\r\n        }\r\n\r\n        let rid = encode(dir)\r\n        let obj = {\r\n          id: rid,\r\n          name: filename,\r\n        }\r\n        if (stat) {\r\n          if (stat.isDirectory()) {\r\n            obj.type = 'folder'\r\n          } else if (stat.isFile()) {\r\n            obj.type = 'file'\r\n            obj.size = stat.size\r\n          }\r\n          obj.ctime = stat.ctimeMs\r\n          obj.mtime = stat.mtimeMs\r\n          obj.extra = {\r\n            fid: rid,\r\n            parent_id: id\r\n          }\r\n        }\r\n\r\n        if (!search || filename.includes(search)) {\r\n          files.push(obj)\r\n        }\r\n      })\r\n\r\n      if (orderBy) {\r\n        let [type, isAsc] = orderBy\r\n        let aVal = isAsc ? 1 : -1\r\n        let bVal = isAsc ? -1 : 1\r\n        files.sort((a, b) => a[type] > [b.type] ? aVal : bVal)\r\n      }\r\n      files.sort((a, b) => (a.type == 'folder' && b.type != 'folder') ? -1 : 1)\r\n\r\n      return { id, files }\r\n    }\r\n\r\n    return this.app.error({ message: 'path is not exist' })\r\n  }\r\n\r\n  async get(id) {\r\n    let stat = fileStat(this.ospath(id))\r\n    if (!stat) return this.app.error({ code: 404 })\r\n    let isRoot = this.isRoot(id)\r\n\r\n    if (isRoot) {\r\n      return {\r\n        id,\r\n        name: '@drive_root',\r\n        type: 'folder'\r\n      }\r\n    }\r\n\r\n    let data = {\r\n      id: id,\r\n      name: basename(id),\r\n      size: stat.size,\r\n      type: stat.isDirectory() ? 'folder' : 'file',\r\n      ctime: stat.ctimeMs,\r\n      mtime: stat.mtimeMs,\r\n      extra: {\r\n        fid: id,\r\n        parent_id: id ? dirname(id) : undefined,\r\n      }\r\n    }\r\n    if (data.type == 'file') {\r\n      data.extra.md5 = await md5file(this.ospath(id))\r\n    }\r\n    return data\r\n  }\r\n\r\n  mkdir(id, name) {\r\n    let filepath = this.ospath(id)\r\n    let target = join(filepath, name)\r\n\r\n    if (fs.existsSync(target) == false) {\r\n      fs.mkdirSync(target)\r\n    }\r\n\r\n    return { id: normalize(id + '/' + name), name }\r\n  }\r\n\r\n  rm(id) {\r\n    let filepath = this.ospath(id)\r\n    try {\r\n      fs.rmSync(filepath, { force: false, recursive: true })\r\n    } catch (e) {\r\n      return createError(e)\r\n    }\r\n    return { id }\r\n  }\r\n\r\n  rename(id, name) {\r\n    let filepath = this.ospath(id)\r\n    let dir = dirname(filepath)\r\n    let targetpath = join(dir, name)\r\n    try {\r\n      fs.renameSync(filepath, targetpath)\r\n    } catch (e) {\r\n      console.log(e)\r\n      return createError(e)\r\n    }\r\n\r\n    return { id: `${dir + '/' + name}`, name }\r\n  }\r\n\r\n  /**\r\n   * move\r\n   * @param {*} id file or folder ID\r\n   * @param {string} target folder ID\r\n   * @returns \r\n   */\r\n  async mv(id, target) {\r\n    // console.log('mv', id, target)\r\n    let filepath = this.ospath(id)\r\n    let targetpath = this.ospath(target)\r\n\r\n    let dst = join(targetpath, basename(id))\r\n\r\n    try {\r\n      fs.renameSync(filepath, dst)\r\n    } catch (e) {\r\n      return createError(e)\r\n    }\r\n\r\n    return { id: encode(dst) }\r\n  }\r\n\r\n  async afterUpload() {\r\n    //rename filename.filepart -> filename\r\n  }\r\n\r\n  async beforeUpload(id, name) {\r\n    let filepath = this.ospath(id)\r\n    let tmpfile = join(filepath, name + '.filepart')\r\n\r\n    fs.access(file, fs.constants.F_OK, (err) => { console.log(`${file} ${err ? '不存在' : '存在'}`); });\r\n    fs.closeSync(fs.openSync(tmpfile, 'w'))\r\n\r\n    let uploadId = md5(id + '_' + name)\r\n    return { uploadId }\r\n  }\r\n\r\n  async upload(id, stream, { size, name, manual, uploadId, ...options }) {\r\n    let filepath = this.ospath(id)\r\n    let target = join(filepath, name)\r\n    let currentUploadId = md5(id + '_' + name)\r\n\r\n    if (currentUploadId != uploadId) {\r\n      // 不是同一个上传实例,似乎无关紧要\r\n    }\r\n    let uploadFile = target + '.filepart'\r\n    let filepart = await fileStat(uploadFile)\r\n    let start = 0\r\n    // 创建空文件\r\n    if (!filepart) {\r\n      fs.closeSync(fs.openSync(uploadFile, 'w'))\r\n    } else {\r\n      start = filepart.size\r\n    }\r\n\r\n\r\n    const done = async (customStream) => {\r\n      let writeStream = fs.createWriteStream(uploadFile, { ...options, start, flags: 'a' })\r\n      await pipe(stream || customStream, writeStream)\r\n      //rename\r\n      fileRename(uploadFile, target)\r\n      return { id: encode(target), name }\r\n    }\r\n    if (manual) {\r\n      //这个upload\r\n      return {\r\n        uploadId: currentUploadId, start, done\r\n      }\r\n    } else {\r\n      return await done(stream)\r\n    }\r\n  }\r\n\r\n  async createReadStream(id, options = {}) {\r\n    let filepath = this.ospath(id)\r\n    return fs.createReadStream(filepath, { ...options, highWaterMark: 64 * 1024 })\r\n  }\r\n}\r\n\r\nmodule.exports = { driver: FileSystem }"},{"hash":"52b24cd6ae3fe4f57c393b53e9b8da48","name":"GoogleDrive","namespace":"sharelist.plugin.googledrive","version":"1.0.0","license":"MIT","description":"GoogleDrive","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/googledrive/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODcuMyA3OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxwYXRoIGQ9Im02LjYgNjYuODUgMy44NSA2LjY1Yy44IDEuNCAxLjk1IDIuNSAzLjMgMy4zbDEzLjc1LTIzLjhoLTI3LjVjMCAxLjU1LjQgMy4xIDEuMiA0LjV6IiBmaWxsPSIjMDA2NmRhIi8+Cgk8cGF0aCBkPSJtNDMuNjUgMjUtMTMuNzUtMjMuOGMtMS4zNS44LTIuNSAxLjktMy4zIDMuM2wtMjUuNCA0NGE5LjA2IDkuMDYgMCAwIDAgLTEuMiA0LjVoMjcuNXoiIGZpbGw9IiMwMGFjNDciLz4KCTxwYXRoIGQ9Im03My41NSA3Ni44YzEuMzUtLjggMi41LTEuOSAzLjMtMy4zbDEuNi0yLjc1IDcuNjUtMTMuMjVjLjgtMS40IDEuMi0yLjk1IDEuMi00LjVoLTI3LjUwMmw1Ljg1MiAxMS41eiIgZmlsbD0iI2VhNDMzNSIvPgoJPHBhdGggZD0ibTQzLjY1IDI1IDEzLjc1LTIzLjhjLTEuMzUtLjgtMi45LTEuMi00LjUtMS4yaC0xOC41Yy0xLjYgMC0zLjE1LjQ1LTQuNSAxLjJ6IiBmaWxsPSIjMDA4MzJkIi8+Cgk8cGF0aCBkPSJtNTkuOCA1M2gtMzIuM2wtMTMuNzUgMjMuOGMxLjM1LjggMi45IDEuMiA0LjUgMS4yaDUwLjhjMS42IDAgMy4xNS0uNDUgNC41LTEuMnoiIGZpbGw9IiMyNjg0ZmMiLz4KCTxwYXRoIGQ9Im03My40IDI2LjUtMTIuNy0yMmMtLjgtMS40LTEuOTUtMi41LTMuMy0zLjNsLTEzLjc1IDIzLjggMTYuMTUgMjhoMjcuNDVjMC0xLjU1LS40LTMuMS0xLjItNC41eiIgZmlsbD0iI2ZmYmEwMCIvPgo8L3N2Zz4=","script":"//===Sharelist===\r\n// @name         GoogleDrive\r\n// @namespace    sharelist.plugin.googledrive\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  GoogleDrive\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/googledrive/index.js\r\n// @icon         data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgODcuMyA3OCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KCTxwYXRoIGQ9Im02LjYgNjYuODUgMy44NSA2LjY1Yy44IDEuNCAxLjk1IDIuNSAzLjMgMy4zbDEzLjc1LTIzLjhoLTI3LjVjMCAxLjU1LjQgMy4xIDEuMiA0LjV6IiBmaWxsPSIjMDA2NmRhIi8+Cgk8cGF0aCBkPSJtNDMuNjUgMjUtMTMuNzUtMjMuOGMtMS4zNS44LTIuNSAxLjktMy4zIDMuM2wtMjUuNCA0NGE5LjA2IDkuMDYgMCAwIDAgLTEuMiA0LjVoMjcuNXoiIGZpbGw9IiMwMGFjNDciLz4KCTxwYXRoIGQ9Im03My41NSA3Ni44YzEuMzUtLjggMi41LTEuOSAzLjMtMy4zbDEuNi0yLjc1IDcuNjUtMTMuMjVjLjgtMS40IDEuMi0yLjk1IDEuMi00LjVoLTI3LjUwMmw1Ljg1MiAxMS41eiIgZmlsbD0iI2VhNDMzNSIvPgoJPHBhdGggZD0ibTQzLjY1IDI1IDEzLjc1LTIzLjhjLTEuMzUtLjgtMi45LTEuMi00LjUtMS4yaC0xOC41Yy0xLjYgMC0zLjE1LjQ1LTQuNSAxLjJ6IiBmaWxsPSIjMDA4MzJkIi8+Cgk8cGF0aCBkPSJtNTkuOCA1M2gtMzIuM2wtMTMuNzUgMjMuOGMxLjM1LjggMi45IDEuMiA0LjUgMS4yaDUwLjhjMS42IDAgMy4xNS0uNDUgNC41LTEuMnoiIGZpbGw9IiMyNjg0ZmMiLz4KCTxwYXRoIGQ9Im03My40IDI2LjUtMTIuNy0yMmMtLjgtMS40LTEuOTUtMi41LTMuMy0zLjNsLTEzLjc1IDIzLjggMTYuMTUgMjhoMjcuNDVjMC0xLjU1LS40LTMuMS0xLjItNC41eiIgZmlsbD0iI2ZmYmEwMCIvPgo8L3N2Zz4=\r\n//===/Sharelist==\r\n\r\n/**\r\n * 1. Google Drive allows duplicate names\r\n * 2. The root folder also has a unique ID, it can use the alias root to refer to the root folder anywhere a file ID is provided\r\n */\r\nconst API_ENDPOINT = 'https://www.googleapis.com'\r\n\r\nconst DEFAULT_ROOT_ID = 'root'\r\n\r\nclass Manager {\r\n  static getInstance(app, config) {\r\n    if (!this.instance) {\r\n      this.instance = new Manager(app)\r\n    }\r\n\r\n    return this.instance.createGetter(config)\r\n  }\r\n\r\n  constructor(app) {\r\n    this.app = app\r\n  }\r\n\r\n  createGetter(config) {\r\n    return async () => {\r\n      if (\r\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\r\n      ) {\r\n        await this.refreshAccessToken(config)\r\n      }\r\n      return {\r\n        ...config\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 刷新令牌 / refresh token\r\n   *\r\n   * @param {object} credentials\r\n   * @param {object} { credentials: object } | { error:true, message:string }\r\n   * @api private\r\n   */\r\n  async refreshAccessToken(credentials) {\r\n    let { client_id, client_secret, redirect_uri, refresh_token, ...rest } = credentials\r\n\r\n    if (!(client_id && client_secret && refresh_token)) {\r\n      return { error: { message: 'Invalid parameters: An error occurred during refresh access token' } }\r\n    }\r\n\r\n    let formdata = {\r\n      client_id,\r\n      client_secret,\r\n      // redirect_uri,\r\n      refresh_token,\r\n      grant_type: 'refresh_token',\r\n    }\r\n    let { data } = await this.app.request.post('https://oauth2.googleapis.com/token', {\r\n      data: formdata,\r\n      contentType: 'json',\r\n      proxy: rest.proxy\r\n    })\r\n\r\n    if (data.error) {\r\n      throw { message: data.error_description || data.error }\r\n    }\r\n\r\n    let expires_at = data.expires_in * 1000 + Date.now()\r\n\r\n    credentials.access_token = data.access_token\r\n    credentials.expires_at = expires_at\r\n\r\n  }\r\n}\r\n\r\n\r\nclass Driver {\r\n  static options = {\r\n    protocol: \"googledrive\",\r\n\r\n    //支持全局搜索\r\n    globalSearch: true,\r\n    localSearch: true,\r\n\r\n    key: 'client_id',\r\n    defaultRoot: DEFAULT_ROOT_ID,\r\n\r\n    guide: [\r\n      { key: 'client_id', label: '应用ID / Client ID', type: 'string', required: true },\r\n      { key: 'client_secret', label: '应用机密 / Client Secret', type: 'string', required: true },\r\n      { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\r\n      { key: 'refresh_token', label: '刷新令牌 / Refresh Token', type: 'string', required: true },\r\n      { key: 'root_id', label: '初始文件夹ID / Rood ID', help: '', type: 'string', required: false },\r\n      { key: 'proxy', label: '代理地址 / Proxy Server', help: '', type: 'string', required: false },\r\n    ]\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.getConfig = Manager.getInstance(app, config)\r\n    this.abusiveFilesMap = {}\r\n  }\r\n\r\n  //docs: https://developers.google.com/drive/api/v3/reference/files/list\r\n  //per_page : 1-1000\r\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\r\n\r\n    const {\r\n      request,\r\n      utils: { timestamp },\r\n    } = this.app\r\n\r\n    let usePagination = !!perPage\r\n\r\n    let { access_token, proxy } = await this.getConfig()\r\n    const url = `${API_ENDPOINT}/drive/v3/files`\r\n\r\n    const q = ['trashed = false', `'${id}' in parents`]\r\n\r\n    if (search) {\r\n      q.push(`name contains '${search}'`)\r\n    }\r\n\r\n    const params = {\r\n      includeItemsFromAllDrives: true,\r\n      supportsAllDrives: true,\r\n      pageSize: usePagination ? perPage : 1000,\r\n      fields: `nextPageToken, files(id,name,mimeType,parents,size,fileExtension,thumbnailLink,createdTime,modifiedTime,ownedByMe,md5Checksum)`,\r\n      q: q.join(' and '),\r\n    }\r\n\r\n    // order_by\r\n    // Valid keys are 'createdTime', 'folder', 'modifiedByMeTime', 'modifiedTime', 'name', 'name_natural', 'quotaBytesUsed', 'recency', 'sharedWithMeTime', 'starred', and 'viewedByMeTime'\r\n    if (orderBy) {\r\n      let [sortKey, sortType] = orderBy\r\n      sortKey = sortKey == 'mtime' ? 'modifiedTime' : sortKey == 'size' ? 'quotaBytesUsed' : 'name'\r\n      params.orderBy = 'folder,' + sortKey + ' ' + (sortType ? 'asc' : 'desc')\r\n    } else {\r\n      params.orderBy = 'folder'\r\n    }\r\n\r\n    let pageToken = nextPage, files = []\r\n\r\n    do {\r\n      let { data, error } = await request.get(url, {\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: { ...params, ...(pageToken ? { pageToken } : {}) },\r\n        proxy\r\n      })\r\n      if (data.error) {\r\n        // Exceeded\r\n        if (data.error.code == 403 && data.error.message == 'Rate Limit Exceeded') {\r\n\r\n        }\r\n        return this.app.error({ code: data.error.code, message: data.error.message })\r\n      }\r\n\r\n      pageToken = data.nextPageToken\r\n\r\n      //nextPageToken\r\n      data.files.forEach((i) => {\r\n        let item = {\r\n          id: i.id,\r\n          name: i.name,\r\n          type: i.mimeType.includes('.folder') ? 'folder' : 'file',\r\n          size: parseInt(i.size || 0),\r\n          ctime: new Date(i.createdTime).getTime(),\r\n          mtime: new Date(i.modifiedTime).getTime(),\r\n          thumb: data.thumbnailLink,\r\n          extra: {\r\n            fid: i.id,\r\n            //root also has a id, but it shouldn't be used here\r\n            parent_id: id, // i.parents?.[0],\r\n            md5: i.md5Checksum,\r\n          },\r\n        }\r\n\r\n        if (item.type == 'file') {\r\n          item.extra.mime = i.mimeType\r\n        } else if (i.folder) {\r\n          // item.extra.child_count = i.folder.childCount\r\n        }\r\n\r\n        files.push(item)\r\n\r\n        if (id == DEFAULT_ROOT_ID && !this.realRootId) {\r\n          this.realRootId = i.parents?.[0]\r\n        }\r\n\r\n      })\r\n    } while (!usePagination && pageToken)\r\n\r\n    let result = {\r\n      id, files\r\n    }\r\n\r\n    if (usePagination && pageToken) {\r\n      result.nextPage = pageToken\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  //docs: https://developers.google.com/drive/api/v3/reference/files/get\r\n  /**\r\n   * get file\r\n   *\r\n   * @param {string} [id] path id\r\n   * @param {string} [key] key\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async get(id) {\r\n    let { access_token, proxy } = await this.getConfig()\r\n\r\n    const {\r\n      request,\r\n      utils: { timestamp },\r\n    } = this.app\r\n\r\n    let url = `${API_ENDPOINT}/drive/v3/files/${id}`\r\n    let { data } = await request.get(url, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        // acknowledgeAbuse: true,\r\n        fields: `*`,\r\n      },\r\n      proxy\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      type: data.mimeType.includes('.folder') ? 'folder' : 'file',\r\n      size: data.size,\r\n      ctime: timestamp(data.createdDateTime),\r\n      mtime: timestamp(data.lastModifiedDateTime),\r\n      thumb: data.thumbnailLink,\r\n      extra: {\r\n        fid: data.id,\r\n        //root also has a id, but it shouldn't be used here\r\n        parent_id: this.realRootId == data.parents?.[0] ? DEFAULT_ROOT_ID : data.parents?.[0],\r\n        md5: data.md5Checksum,\r\n        content_link: data.webContentLink,\r\n      },\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * create folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] folder name\r\n   * @param {object} [options] options\r\n   * @param {object} [options.check_name_mode] \r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async mkdir(parent_file_id, name, { check_name_mode = 'refuse' }) {\r\n    let { access_token, proxy } = await this.getConfig()\r\n\r\n    let { data } = await this.app.request.post(`${API_ENDPOINT}/drive/v3/files`, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        'name': name,\r\n        'parents': [parent_file_id],\r\n        'mimeType': 'application/vnd.google-apps.folder',\r\n      },\r\n      contentType: 'json',\r\n      proxy\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      parent_id: parent_file_id\r\n    }\r\n  }\r\n\r\n  /**\r\n   * rename file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] new name\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rename(file_id, name, { check_name_mode = 'refuse' } = {}) {\r\n    let { access_token, proxy } = await this.getConfig()\r\n\r\n    let { data } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${file_id}`, {\r\n      method: 'PATCH',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        name,\r\n      },\r\n      contentType: 'json',\r\n      proxy\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * mv file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [parent_id] folder id\r\n   * @return {string | error}\r\n   *\r\n   * @api public\r\n   */\r\n  async mv(id, targetId, { name, copy } = {}) {\r\n    if (copy) return await this.copy(id, targetId, { name })\r\n\r\n    let { access_token, proxy } = await this.getConfig()\r\n    let filedata = await this.get(id)\r\n    let parentId = filedata?.extra.parent_id\r\n    let params = {}\r\n\r\n    if (name) params.name = name\r\n\r\n    let { data } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${id}?addParents=${targetId}&removeParents=${parentId}`, {\r\n      method: 'PATCH',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      contentType: 'json',\r\n      data: params,\r\n      proxy\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      origin_parent_id: parentId\r\n    }\r\n  }\r\n\r\n  /**\r\n   * copy file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @return {string}\r\n   *\r\n   * @api public\r\n   */\r\n  async copy(id, destId, { name }) {\r\n    let { access_token, proxy } = await this.getConfig()\r\n\r\n    let dest = {\r\n      parents: [destId]\r\n    }\r\n    if (name) dest.name = name\r\n    console.log('copy', id, '-->', destId)\r\n    let { status, data } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${id}/copy`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: dest,\r\n      contentType: 'json',\r\n      proxy\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name\r\n    }\r\n  }\r\n\r\n  /**\r\n   * remove file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @return {string}\r\n   *\r\n   * @api public\r\n   */\r\n  async rm(file_id) {\r\n    let { access_token, proxy } = await this.getConfig()\r\n    let filedata = await this.get(file_id)\r\n\r\n    let { status } = await this.app.request(`${API_ENDPOINT}/drive/v3/files/${file_id}`, {\r\n      method: \"DELETE\",\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      responseType: 'text',\r\n      proxy\r\n    })\r\n\r\n    if (status != 204) {\r\n      return this.app.error({ message: 'An error occurred during delete files' })\r\n    }\r\n\r\n    return {\r\n      id: file_id,\r\n      parent_id: filedata.extra.parent_id\r\n    }\r\n  }\r\n\r\n  async beforeUpload(parent_id, { name }) {\r\n    let { access_token, proxy } = await this.getConfig()\r\n\r\n    let { headers, status, data } = await this.app.request.post(`${API_ENDPOINT}/upload/drive/v3/files?uploadType=resumable`, {\r\n      data: {\r\n        name,\r\n        parents: [parent_id]\r\n      },\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      contentType: 'json',\r\n      responseType: 'text',\r\n      proxy\r\n    })\r\n    return headers?.location\r\n  }\r\n\r\n  /**\r\n   * upload file\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {ReadableStream} [stream] upload file stream\r\n   * @param {object} [options] upload file meta\r\n   * @param {number} [options.size] upload file size\r\n   * @param {string} [options.name] upload file name\r\n   * @param {object} [credentials] credentials\r\n   * @return {string | error}\r\n   *\r\n   * @api public\r\n   */\r\n  async upload(id, stream, { size, name, ...rest }) {\r\n    const { app } = this\r\n    let { proxy } = await this.getConfig()\r\n\r\n    let uploadUrl = await this.beforeUpload(id, { name, size, ...rest })\r\n\r\n    if (!uploadUrl) {\r\n      return app.error('An error occurred during upload, miss upload url')\r\n    }\r\n\r\n    let { data } = await app.request(uploadUrl, {\r\n      method: 'put',\r\n      headers: {\r\n        'Content-Length': size,\r\n        'Content-Range': `bytes ${0}-${size - 1}/${size}`,\r\n      },\r\n      data: stream,\r\n      contentType: 'stream',\r\n      proxy\r\n    })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n      parent_id: id\r\n    }\r\n  }\r\n  /**\r\n   * check if it is a abusive file\r\n   * @param {*} url \r\n   * @param {*} access_token \r\n   * @returns {boolean}\r\n   */\r\n  async isAbusiveFile(url, access_token) {\r\n    let { proxy } = await this.getConfig()\r\n\r\n    if (this.abusiveFilesMap[url]) {\r\n      return this.abusiveFilesMap[url]\r\n    } else {\r\n      const resp = await this.app.request(url, {\r\n        method: 'HEAD',\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        responseType: 'text',\r\n        proxy\r\n      })\r\n\r\n      this.abusiveFilesMap[url] = resp.status == 403\r\n\r\n      return this.abusiveFilesMap[url]\r\n    }\r\n  }\r\n\r\n  async createReadStream(id, options = {}) {\r\n\r\n    let { access_token, proxy } = await this.getConfig()\r\n\r\n    let url = `${API_ENDPOINT}/drive/v3/files/${id}?alt=media`\r\n\r\n    if (await this.isAbusiveFile(url, access_token)) {\r\n      url += '&acknowledgeAbuse=true'\r\n    }\r\n\r\n    let headers = {\r\n      Authorization: `Bearer ${access_token}`,\r\n    }\r\n\r\n    if ('start' in options) {\r\n      headers['range'] = `bytes=${options.start}-${options.end || ''}`\r\n    }\r\n\r\n    let resp = await this.app.request.get(url, {\r\n      headers,\r\n      responseType: 'stream',\r\n      retry: 0,\r\n      proxy\r\n    })\r\n\r\n    return resp.data\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = { driver: Driver } "},{"hash":"43889c709a0a33d0bb43cd0abccd620f","name":"OneDrive","namespace":"sharelist.plugin.onedrive","version":"1.0.0","license":"MIT","description":"OneDrive","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/onedrive/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgNS41IDMyIDIwLjUiPjx0aXRsZT5PZmZpY2VDb3JlMTBfMzJ4XzI0eF8yMHhfMTZ4XzAxLTIyLTIwMTk8L3RpdGxlPjxnIGlkPSJTVFlMRV9DT0xPUiI+PHBhdGggZD0iTTEyLjIwMjQ1LDExLjE5MjkybC4wMDAzMS0uMDAxMSw2LjcxNzY1LDQuMDIzNzksNC4wMDI5My0xLjY4NDUxLjAwMDE4LjAwMDY4QTYuNDc2OCw2LjQ3NjgsMCwwLDEsMjUuNSwxM2MuMTQ3NjQsMCwuMjkzNTguMDA2Ny40Mzg3OC4wMTYzOWExMC4wMDA3NSwxMC4wMDA3NSwwLDAsMC0xOC4wNDEtMy4wMTM4MUM3LjkzMiwxMC4wMDIxNSw3Ljk2NTcsMTAsOCwxMEE3Ljk2MDczLDcuOTYwNzMsMCwwLDEsMTIuMjAyNDUsMTEuMTkyOTJaIiBmaWxsPSIjMDM2NGI4Ii8+PHBhdGggZD0iTTEyLjIwMjc2LDExLjE5MTgybC0uMDAwMzEuMDAxMUE3Ljk2MDczLDcuOTYwNzMsMCwwLDAsOCwxMGMtLjAzNDMsMC0uMDY4MDUuMDAyMTUtLjEwMjIzLjAwMjU4QTcuOTk2NzYsNy45OTY3NiwwLDAsMCwxLjQzNzMyLDIyLjU3Mjc3bDUuOTI0LTIuNDkyOTIsMi42MzM0Mi0xLjEwODE5LDUuODYzNTMtMi40Njc0NiwzLjA2MjEzLTEuMjg4NTlaIiBmaWxsPSIjMDA3OGQ0Ii8+PHBhdGggZD0iTTI1LjkzODc4LDEzLjAxNjM5QzI1Ljc5MzU4LDEzLjAwNjcsMjUuNjQ3NjQsMTMsMjUuNSwxM2E2LjQ3NjgsNi40NzY4LDAsMCwwLTIuNTc2NDguNTMxNzhsLS4wMDAxOC0uMDAwNjgtNC4wMDI5MywxLjY4NDUxLDEuMTYwNzcuNjk1MjhMMjMuODg2MTEsMTguMTlsMS42NjAwOS45OTQzOCw1LjY3NjMzLDMuNDAwMDdhNi41MDAyLDYuNTAwMiwwLDAsMC01LjI4Mzc1LTkuNTY4MDVaIiBmaWxsPSIjMTQ5MGRmIi8+PHBhdGggZD0iTTI1LjU0NjIsMTkuMTg0MzcsMjMuODg2MTEsMTguMTlsLTMuODA0OTMtMi4yNzkxLTEuMTYwNzctLjY5NTI4TDE1Ljg1ODI4LDE2LjUwNDIsOS45OTQ3NSwxOC45NzE2Niw3LjM2MTMzLDIwLjA3OTg1bC01LjkyNCwyLjQ5MjkyQTcuOTg4ODksNy45ODg4OSwwLDAsMCw4LDI2SDI1LjVhNi40OTgzNyw2LjQ5ODM3LDAsMCwwLDUuNzIyNTMtMy40MTU1NloiIGZpbGw9IiMyOGE4ZWEiLz48L2c+PC9zdmc+","script":"//===Sharelist===\r\n// @name         OneDrive\r\n// @namespace    sharelist.plugin.onedrive\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  OneDrive\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/onedrive/index.js\r\n// @icon         data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgNS41IDMyIDIwLjUiPjx0aXRsZT5PZmZpY2VDb3JlMTBfMzJ4XzI0eF8yMHhfMTZ4XzAxLTIyLTIwMTk8L3RpdGxlPjxnIGlkPSJTVFlMRV9DT0xPUiI+PHBhdGggZD0iTTEyLjIwMjQ1LDExLjE5MjkybC4wMDAzMS0uMDAxMSw2LjcxNzY1LDQuMDIzNzksNC4wMDI5My0xLjY4NDUxLjAwMDE4LjAwMDY4QTYuNDc2OCw2LjQ3NjgsMCwwLDEsMjUuNSwxM2MuMTQ3NjQsMCwuMjkzNTguMDA2Ny40Mzg3OC4wMTYzOWExMC4wMDA3NSwxMC4wMDA3NSwwLDAsMC0xOC4wNDEtMy4wMTM4MUM3LjkzMiwxMC4wMDIxNSw3Ljk2NTcsMTAsOCwxMEE3Ljk2MDczLDcuOTYwNzMsMCwwLDEsMTIuMjAyNDUsMTEuMTkyOTJaIiBmaWxsPSIjMDM2NGI4Ii8+PHBhdGggZD0iTTEyLjIwMjc2LDExLjE5MTgybC0uMDAwMzEuMDAxMUE3Ljk2MDczLDcuOTYwNzMsMCwwLDAsOCwxMGMtLjAzNDMsMC0uMDY4MDUuMDAyMTUtLjEwMjIzLjAwMjU4QTcuOTk2NzYsNy45OTY3NiwwLDAsMCwxLjQzNzMyLDIyLjU3Mjc3bDUuOTI0LTIuNDkyOTIsMi42MzM0Mi0xLjEwODE5LDUuODYzNTMtMi40Njc0NiwzLjA2MjEzLTEuMjg4NTlaIiBmaWxsPSIjMDA3OGQ0Ii8+PHBhdGggZD0iTTI1LjkzODc4LDEzLjAxNjM5QzI1Ljc5MzU4LDEzLjAwNjcsMjUuNjQ3NjQsMTMsMjUuNSwxM2E2LjQ3NjgsNi40NzY4LDAsMCwwLTIuNTc2NDguNTMxNzhsLS4wMDAxOC0uMDAwNjgtNC4wMDI5MywxLjY4NDUxLDEuMTYwNzcuNjk1MjhMMjMuODg2MTEsMTguMTlsMS42NjAwOS45OTQzOCw1LjY3NjMzLDMuNDAwMDdhNi41MDAyLDYuNTAwMiwwLDAsMC01LjI4Mzc1LTkuNTY4MDVaIiBmaWxsPSIjMTQ5MGRmIi8+PHBhdGggZD0iTTI1LjU0NjIsMTkuMTg0MzcsMjMuODg2MTEsMTguMTlsLTMuODA0OTMtMi4yNzkxLTEuMTYwNzctLjY5NTI4TDE1Ljg1ODI4LDE2LjUwNDIsOS45OTQ3NSwxOC45NzE2Niw3LjM2MTMzLDIwLjA3OTg1bC01LjkyNCwyLjQ5MjkyQTcuOTg4ODksNy45ODg4OSwwLDAsMCw4LDI2SDI1LjVhNi40OTgzNyw2LjQ5ODM3LDAsMCwwLDUuNzIyNTMtMy40MTU1NloiIGZpbGw9IiMyOGE4ZWEiLz48L2c+PC9zdmc+\r\n//===/Sharelist==\r\n\r\nconst { URL } = require('url')\r\n\r\nconst DEFAULT_ROOT_ID = 'root'\r\n\r\nconst UPLOAD_PART_SIZE = 4 * 1024 * 1024\r\n\r\nconst UPLOAD_PART_SIZE_LARGE = 16 * 1024 * 1024\r\n\r\nconst atob = v => Buffer.from(v, 'base64').toString()\r\n\r\nconst btoa = v => Buffer.from(v).toString('base64')\r\n\r\nconst supportZones = {\r\n  GLOBAL: ['https://login.microsoftonline.com', 'https://graph.microsoft.com', '国际版'],\r\n  CN: ['https://login.chinacloudapi.cn', 'https://microsoftgraph.chinacloudapi.cn', '世纪互联'],\r\n  DE: ['https://login.microsoftonline.de', 'https://graph.microsoft.de', 'Azure Germany'],\r\n  US: ['https://login.microsoftonline.us', 'https://graph.microsoft.us', 'Azure US GOV'],\r\n}\r\n\r\nconst qs = (d) => new URLSearchParams(d).toString()\r\n\r\nconst sleep = time => new Promise((resolve, reject) => setTimeout(resolve, time))\r\n\r\nclass Manager {\r\n  static getInstance(app, config) {\r\n    if (!this.instance) {\r\n      this.instance = new Manager(app)\r\n    }\r\n\r\n    // this.instance.add(config)\r\n    return this.instance.createGetter(config, app)\r\n  }\r\n\r\n  constructor(app) {\r\n    this.app = app\r\n    this.keyMaps = {}\r\n  }\r\n\r\n  createGetter(config) {\r\n    //May be public client_id\r\n    let [basePart] = config.client_id.split('.')\r\n    if (this.keyMaps[config.client_id]) {\r\n      config.client_id = basePart + '.' + ('' + Math.random()).substring(2)\r\n    }\r\n    this.keyMaps[basePart] = 1\r\n    return async () => {\r\n      if (\r\n        !(config.access_token && config.expires_at && config.expires_at - Date.now() > 5 * 60 * 1000)\r\n      ) {\r\n        await this.refreshAccessToken(config)\r\n      }\r\n      return {\r\n        ...config\r\n      }\r\n    }\r\n  }\r\n\r\n  getAuthority(zone = 'GLOBAL', tenant_id) {\r\n    return supportZones[zone][0] + '/' + (tenant_id || 'common')\r\n  }\r\n\r\n  getGraphEndpoint(zone = 'GLOBAL', site_id = false) {\r\n    return supportZones[zone][1] + '/v1.0' + (site_id ? `/sites/${site_id}` : '/me') + '/drive'\r\n  }\r\n\r\n  getGraphEndpointSite(zone = 'GLOBAL', site_name) {\r\n    //sites/' . getConfig('siteid') . '\r\n    return supportZones[zone][1] + '/v1.0/sites/root:/' + site_name\r\n  }\r\n\r\n  /**\r\n   * 从分享链接中解析 credentials\r\n   * access token 有效期 5h\r\n   *\r\n   * @param {object} config\r\n   * @param {object} { credentials }\r\n   * @api private\r\n   */\r\n  async refreshShareAccessToken(config) {\r\n    const {\r\n      request\r\n    } = this.app\r\n\r\n    const url = decodeURIComponent(config.share_url)\r\n\r\n    let { headers } = await request(url, {\r\n      responseType: 'text',\r\n      followRedirect: false,\r\n      headers: {\r\n        'User-Agent':\r\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36',\r\n      },\r\n    })\r\n\r\n    let cookie = headers['set-cookie']\r\n    let obj = new URL(headers['location'])\r\n    let origin = obj.origin\r\n    let rootFolder = obj.searchParams.get('id')\r\n    let account = rootFolder\r\n      .split(' ')[0]\r\n      .replace('/Shared', '')\r\n      .replace(/Documents.*?$/, '')\r\n\r\n    let query = {\r\n      a1: `'${rootFolder.replace(/(?<=Documents).*$/, '')}'`,\r\n      RootFolder: rootFolder,\r\n      TryNewExperienceSingle: 'TRUE',\r\n    }\r\n\r\n    let formdata = {\r\n      parameters: {\r\n        __metadata: { type: 'SP.RenderListDataParameters' },\r\n        RenderOptions: 1216519,\r\n        ViewXml:\r\n          '<View Name=\"{95F0CAAD-9DE2-4864-AE8D-33094C998625}\" DefaultView=\"TRUE\" MobileView=\"TRUE\" MobileDefaultView=\"TRUE\" Type=\"HTML\" ReadOnly=\"TRUE\" DisplayName=\"All\" Url=\"/personal/mengskysama_makedie_onmicrosoft_com/Documents/Forms/All.aspx\" Level=\"1\" BaseViewID=\"51\" ContentTypeID=\"0x\" ImageUrl=\"/_layouts/15/images/dlicon.png?rev=47\"><Query><OrderBy><FieldRef Name=\"FileLeafRef\"/></OrderBy></Query><ViewFields><FieldRef Name=\"DocIcon\"/><FieldRef Name=\"LinkFilename\"/><FieldRef Name=\"Modified\"/><FieldRef Name=\"SharedWith\"/><FieldRef Name=\"Editor\"/></ViewFields><RowLimit Paged=\"TRUE\">70</RowLimit><JSLink>clienttemplates.js</JSLink><XslLink Default=\"TRUE\">main.xsl</XslLink><Toolbar Type=\"Standard\"/></View>',\r\n        AllowMultipleValueFilterForTaxonomyFields: true,\r\n        AddRequiredFields: true,\r\n      },\r\n    }\r\n\r\n    let newurl = `${origin}${account}/_api/web/GetListUsingPath(DecodedUrl=@a1)/RenderListDataAsStream?@${qs(query)}`;\r\n\r\n    let { data } = await request.post(newurl, {\r\n      data: formdata,\r\n      headers: {\r\n        origin,\r\n        cookie,\r\n        accept: 'application/json;odata=verbose',\r\n        'content-type': 'application/json;odata=verbose',\r\n      },\r\n    })\r\n\r\n\r\n    if (data?.error) {\r\n      return this.app.error({ message: data.error.message.value })\r\n    }\r\n\r\n    if (!data?.ListSchema['.driveAccessToken']) {\r\n      return this.app.error({ message: '请将分享文件夹设置[拥有链接的任何人都可编辑] / The shared folder must be given editing permissions' })\r\n    }\r\n\r\n    let access_token = data['ListSchema']['.driveAccessToken'].replace('access_token=', '')\r\n    let graph = data['ListSchema']['.driveUrl']\r\n    let expires_at = parseInt(JSON.parse(atob(access_token.split('.')[1]))['exp']) * 1000\r\n\r\n    config.access_token = access_token\r\n    config.expires_at = expires_at\r\n    config.graph = graph\r\n\r\n    config.key = btoa(decodeURIComponent(url))\r\n  }\r\n\r\n  /**\r\n   * 刷新令牌 / refresh token\r\n   *\r\n   * @param {object} credentials\r\n   * @param {object} { credentials: object } | { error:true, message:string }\r\n   * @api private\r\n   */\r\n  async refreshAccessToken(credentials) {\r\n    let { client_id, client_secret, redirect_uri, refresh_token, zone, tenant_id, type, ...rest } =\r\n      credentials\r\n    if (type == 'sharelink') {\r\n      return await this.refreshShareAccessToken(credentials)\r\n    }\r\n\r\n    if (!(client_id && client_secret && refresh_token)) {\r\n      return { error: { message: 'Invalid parameters: An error occurred during refresh access token' } }\r\n    }\r\n\r\n    let formdata = {\r\n      client_id: client_id.split('.')[0],\r\n      client_secret,\r\n      redirect_uri,\r\n      refresh_token,\r\n      grant_type: 'refresh_token',\r\n    }\r\n    let metadata = this.getAuthority(zone, tenant_id)\r\n    let { data } = await this.app.request.post(`${metadata}/oauth2/v2.0/token`, { data: formdata, contentType: 'form' })\r\n\r\n    if (data.error) {\r\n      return this.app.error({ message: data.error_description || data.error })\r\n    }\r\n\r\n    let expires_at = data.expires_in * 1000 + Date.now()\r\n\r\n    credentials.graph = this.getGraphEndpoint(data.zone, data.site_id)\r\n    credentials.refresh_token = data.refresh_token\r\n    credentials.access_token = data.access_token\r\n    credentials.expires_at = expires_at\r\n  }\r\n\r\n}\r\n\r\nconst mountData = () => {\r\n  let zone = Object.entries(supportZones).map(([key, value]) => {\r\n    return {\r\n      value: key,\r\n      label: value[2],\r\n    }\r\n  })\r\n\r\n  return [\r\n    {\r\n      key: 'type',\r\n      label: 'OneDrive 挂载类型',\r\n      type: 'string',\r\n      required: true,\r\n      options: [\r\n        { value: 'onedrive', label: 'OneDrive' },\r\n        { value: 'sharepoint', label: 'SharePoint' },\r\n        { value: 'sharelink', label: 'Share Link / 分享链接' },\r\n      ],\r\n      fields: [\r\n        [\r\n          { key: 'zone', label: '地域', type: 'string', options: zone, required: true },\r\n          { key: 'client_id', label: '应用ID / Client ID', required: true },\r\n          { key: 'client_secret', label: '应用机密 / App Secret', type: 'string', required: true },\r\n          { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\r\n          { key: 'refresh_token', label: '刷新令牌 / Refresh Token', required: true },\r\n          { key: 'tenant_id', label: '租户ID / Tenant ID' },\r\n          { key: 'root_id', label: '初始目录ID' },\r\n        ],\r\n        [\r\n          { key: 'zone', label: '地域', type: 'string', options: zone, required: true },\r\n          { key: 'client_id', label: '应用ID / Client ID', required: true },\r\n          { key: 'client_secret', label: '应用机密 / App Secret', type: 'string', required: true },\r\n          { key: 'redirect_uri', label: '回调地址 / Redirect URI', required: true },\r\n          { key: 'refresh_token', label: '刷新令牌 / Refresh Token', required: true },\r\n          { key: 'site_id', label: 'SharePoint 站点ID / Site ID', type: 'string' },\r\n          { key: 'tenant_id', label: '租户ID / Tenant ID', type: 'string' },\r\n          { key: 'root_id', label: '初始目录ID', type: 'string' },\r\n        ],\r\n        [\r\n          { key: 'share_url', label: '分享链接URL', type: 'string', required: true },\r\n          { key: 'root_id', label: '初始目录ID', type: 'string' },\r\n        ],\r\n      ],\r\n    },\r\n  ]\r\n}\r\n\r\n\r\nclass Driver {\r\n  static options = {\r\n    protocol: \"onedrive\",\r\n\r\n    //支持全局搜索\r\n    //searchDepth: 1,\r\n    globalSearch: true,\r\n    localSearch: false,\r\n\r\n    key: 'client_id',\r\n    defaultRoot: DEFAULT_ROOT_ID,\r\n    guide: mountData()\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.getConfig = Manager.getInstance(app, config)\r\n  }\r\n\r\n  /**\r\n   * Lists or search files\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {object} [options] list options\r\n   * @param {object} [options.sort] sort methods\r\n   * @param {object} [options.search] search key\r\n   * @return {object | error}\r\n   *\r\n   * @api public\r\n   *\r\n   * docs: https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_list_children?view=odsp-graph-online\r\n   * docs: https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/resources/driveitem\r\n   * \r\n   * TODO: there are two methods for request\r\n   * With a known id:  GET /{drive-id}/items/{item-id}/children\r\n   * With a known path: GET /{drive-id}/root:/{path-relative-to-root}:/children\r\n   * \r\n   * Search Drive Root: GET /root/search(q='{search-text}')\r\n   * Search Dir : GET /items/{item-id}/search(q='text')\r\n   */\r\n  async list(id, { search, orderBy, perPage, nextPage }) {\r\n    let { graph, access_token } = await this.getConfig()\r\n\r\n    const {\r\n      request,\r\n      utils: { timestamp },\r\n    } = this.app\r\n\r\n    let usePagination = !!perPage\r\n\r\n    // https://makedie-my.sharepoint.com/_api/v2.0/drives/b!0JNeDoFvlUSa2fAugQnhNBuZYcN0WQJPrYD8Vq2FUAfsmI8YwdGNQ5zG5mhlt3sY\r\n\r\n    let url = graph + `${id == DEFAULT_ROOT_ID ? '/root/' : `/items/${id}/`}` + `${search ? `search(q='${encodeURIComponent(search)}')` : 'children'}`\r\n\r\n    if (search) console.log('search', url)\r\n    let params = {\r\n      $select:\r\n        'id,name,size,file,folder,parentReference,@microsoft.graph.downloadUrl,thumbnails,createdDateTime,lastModifiedDateTime',\r\n      $expand: 'thumbnails',\r\n    }\r\n\r\n    // TODO: Note that in OneDrive for Business and SharePoint Server 2016, the orderby query string only works with name and url.\r\n    if (orderBy) {\r\n      let [sortKey, sortType] = orderBy\r\n      sortKey = sortKey == 'mtime' ? 'lastModifiedDateTime' : sortKey\r\n      params.$orderby = sortKey + ' ' + (sortType ? 'asc' : 'desc')\r\n    }\r\n\r\n    // set per page\r\n    params.$top = usePagination ? perPage : 1000\r\n\r\n    let skipToken = nextPage, files = []\r\n\r\n    do {\r\n      let { data } = await request.get(url, {\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: { ...params, ...(skipToken ? { '$skipToken': skipToken } : {}) },\r\n      })\r\n\r\n      if (data.error) this.app.error({ message: data.error.message })\r\n\r\n      //extract token from @odata.nextLink\r\n      skipToken = data['@odata.nextLink']?.match(/skiptoken=([a-z0-9A-Z!_]+)/i)?.[1]\r\n      data.value.forEach((i) => {\r\n        let item = {\r\n          id: i.id,\r\n          name: i.name,\r\n          type: i.folder ? 'folder' : 'file',\r\n          size: i.size,\r\n          ctime: timestamp(i.createdDateTime),\r\n          mtime: timestamp(i.lastModifiedDateTime),\r\n          thumb: i.thumbnails.length > 0 ? i.thumbnails[0].medium.url : '',\r\n          extra: {\r\n            fid: i.id,\r\n            parent_id: id //i.parentReference?.id,\r\n          },\r\n        }\r\n        if (i.file) {\r\n          if (i.file.hashes?.sha1Hash) {\r\n            item.extra.sha1 = i.file.hashes.sha1Hash.toLowerCase()\r\n          }\r\n          item.extra.mime = i.file.mimeType\r\n          item.download_url = i['@microsoft.graph.downloadUrl'] || i['@content.downloadUrl']\r\n        } else if (i.folder) {\r\n          item.extra.child_count = i.folder.childCount\r\n        }\r\n        files.push(item)\r\n      })\r\n\r\n    } while (!usePagination && skipToken)\r\n\r\n\r\n    let result = {\r\n      id, files\r\n    }\r\n\r\n    if (usePagination && skipToken) {\r\n      result.nextPage = skipToken\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n\r\n  /**\r\n   * get file\r\n   *\r\n   * @param {string} [id] file id\r\n   * @param {string} [key] key\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async get(id) {\r\n    let { graph, access_token } = await this.getConfig()\r\n\r\n    const {\r\n      request,\r\n      utils: { timestamp },\r\n    } = this.app\r\n    let url = `${graph}/items/${id}`\r\n\r\n    let { data, error } = await request(url, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        $expand: 'thumbnails',\r\n      },\r\n    })\r\n\r\n    if (error) return { error: error }\r\n\r\n    if (data.error) return { error: data.error.message }\r\n    let result = {\r\n      id: data.id,\r\n      name: data.name,\r\n      type: data.folder ? 'folder' : 'file',\r\n      size: data.size,\r\n      ctime: timestamp(data.createdDateTime),\r\n      mtime: timestamp(data.lastModifiedDateTime),\r\n      download_url: data['@microsoft.graph.downloadUrl'] || data['@content.downloadUrl'],\r\n      thumb: data.thumbnails.length > 0 ? data.thumbnails[0].medium.url : '',\r\n      // the download link expires after 3600s\r\n      max_age: 3600 * 1000,\r\n      extra: {\r\n        fid: data.id,\r\n        parent_id: data.parentReference.path ? (data.parentReference.path.endsWith('root:') ? DEFAULT_ROOT_ID : data.parentReference?.id) : DEFAULT_ROOT_ID,\r\n        path: data.parentReference ? data.parentReference.path.split('root:')[1] : '',\r\n      },\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * create folder\r\n   *\r\n   * @param {string} [parent_id] folder id\r\n   * @param {string} [name] folder name\r\n   * @param {object} [options] options\r\n   * @param {object} [options.conflictBehavior] \r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async mkdir(parent_id, name, { conflictBehavior = 'rename' }) {\r\n    let { graph, access_token } = await this.getConfig()\r\n    let url = graph + `${parent_id == DEFAULT_ROOT_ID ? '/root' : `/items/${parent_id}`}` + '/children'\r\n    let { data } = await this.app.request.post(url, {\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        name,\r\n        \"folder\": {},\r\n        \"@microsoft.graph.conflictBehavior\": \"rename\"\r\n      },\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name,\r\n      parent_id\r\n    }\r\n  }\r\n\r\n  /**\r\n   * rename file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [name] folder name\r\n   * @param {object} [options] options\r\n   * @param {object} [options.check_name_mode] \r\n   * @param {string} [key] key\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rename(id, name, { check_name_mode = 'rename' }) {\r\n    let { graph, access_token } = await this.getConfig()\r\n    let url = graph + (id == DEFAULT_ROOT_ID ? '/root' : `/items/${id}`)\r\n\r\n    let { data } = await this.app.request(url, {\r\n      method: 'patch',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: {\r\n        name\r\n      },\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n    return {\r\n      id: data.id,\r\n      name,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * remove file/folder\r\n   *\r\n   * @param {string} [id] id\r\n   * @param {string} [key] key\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async rm(id) {\r\n    let { graph, access_token } = await this.getConfig()\r\n    let filedata = await this.get(id)\r\n    let url = graph + `/items/${id}`\r\n\r\n    let { data, status } = await this.app.request(url, {\r\n      method: 'delete',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      responseType: 'text'\r\n    })\r\n\r\n    if (status == 204) {\r\n      return {\r\n        id,\r\n        parent_id: filedata.extra.parent_id\r\n      }\r\n    } else {\r\n      data = JSON.parse(data)\r\n      return this.app.error({ message: data?.error?.message, code: status })\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * move file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [target_id] dest folder\r\n   * @param {string} [key] key\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async mv(id, target_id, { copy, name } = {}) {\r\n\r\n    if (copy) return await this.copy(id, target_id, { name })\r\n\r\n    let { graph, access_token } = await this.getConfig()\r\n\r\n    let dest = {\r\n      parentReference: {\r\n        id: target_id || DEFAULT_ROOT_ID\r\n      }\r\n    }\r\n    if (name) dest.name = name\r\n\r\n    let { data } = await this.app.request(`${graph}/items/${id}`, {\r\n      method: 'patch',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: dest,\r\n      contentType: 'json',\r\n    })\r\n\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return {\r\n      id: data.id,\r\n      name: data.name,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * copy file/folder\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {string} [target_id] dest folder\r\n   * @param {string} [key] key\r\n   * @return {object}\r\n   *\r\n   * @api public\r\n   */\r\n  async copy(id, target_id, { name } = {}) {\r\n    //POST /users/{userId}/drive/items/{itemId}/copy\r\n    let { graph, access_token } = await this.getConfig()\r\n    let url = graph + `/items/${id}/copy`\r\n\r\n    //TODO: It can NOT use the \"id:root\" when copy items to the root of a OneDrive, use {\"path\": \"/drive/root\"} instead.\r\n    let dest = {\r\n      parentReference: target_id == DEFAULT_ROOT_ID ? { path: '/drive/root' } : { id: target_id }\r\n    }\r\n\r\n    if (name) dest.name = name\r\n\r\n    let { data, headers, status } = await this.app.request(url, {\r\n      method: 'post',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n      },\r\n      data: dest,\r\n      contentType: 'json',\r\n      responseType: 'text'\r\n    })\r\n\r\n\r\n    if (status != 202) {\r\n      return this.app.error(JSON.parse(data)?.error.message)\r\n    }\r\n\r\n    let monitorUrl = headers.location\r\n\r\n    let result = await this.monitor(monitorUrl)\r\n\r\n    if (result?.id) {\r\n      return {\r\n        id: result.id,\r\n        name: data.name,\r\n        parent: target_id,\r\n      }\r\n    } else {\r\n      return this.app.error({ message: 'Task has been accepted, but monitor returned no result.' })\r\n    }\r\n\r\n  }\r\n\r\n  async singleUpload(id, { size, name, stream, ...rest }) {\r\n    let { graph, access_token } = await this.getConfig()\r\n    let url = `${graph}${id == DEFAULT_ROOT_ID ? '/root' : `/items/${id}`}:/${encodeURIComponent(name)}:/content`\r\n    // console.log(url)\r\n    let { data } = await this.app.request(url, {\r\n      method: 'put',\r\n      headers: {\r\n        Authorization: `Bearer ${access_token}`,\r\n        'content-type': 'application/octet-stream'\r\n      },\r\n      data: stream,\r\n      contentType: 'stream',\r\n    })\r\n    if (data.error) return this.app.error({ message: data.error.message })\r\n\r\n    return { id: data.id, name: data.name, parent_id: id }\r\n  }\r\n\r\n  async beforeUpload(uploadId, { id, name, size, conflictBehavior }) {\r\n    let uploadUrl, start = 0\r\n    let { app } = this\r\n    //resume upload\r\n    if (uploadId) {\r\n      uploadUrl = atob(uploadId)\r\n      let { data } = await app.request(uploadUrl)\r\n      if (data.error) app.error({ message: data.error.message })\r\n      //upload session has expired.\r\n      if (data.expirationDateTime && Date.now() - new Date(data.expirationDateTime) > 0) {\r\n        uploadUrl = ''\r\n      } else {\r\n        start = +data.nextExpectedRanges[0].split('-')[0]\r\n      }\r\n    }\r\n\r\n    // create new upload session\r\n    if (!uploadUrl) {\r\n      let { graph, access_token } = await this.getConfig()\r\n      let { data } = await app.request(graph + (id == DEFAULT_ROOT_ID ? '/root' : `/items/${id}`) + `:/${encodeURIComponent(name)}:/` + '/createUploadSession', {\r\n        method: 'post',\r\n        headers: {\r\n          Authorization: `Bearer ${access_token}`,\r\n        },\r\n        data: {\r\n          item: {\r\n            \"@microsoft.graph.conflictBehavior\": \"rename\",\r\n            // name\r\n          }\r\n        },\r\n        contentType: 'json',\r\n      })\r\n      if (data.error) return app.error({ message: data.error.message })\r\n      uploadUrl = data.uploadUrl\r\n      start = 0\r\n    }\r\n\r\n    return {\r\n      uploadUrl, start, uploadId: btoa(uploadUrl)\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * upload file\r\n   * doc: https://docs.microsoft.com/zh-cn/onedrive/developer/rest-api/api/driveitem_createuploadsession?view=odsp-graph-online\r\n   *\r\n   * @param {string} [id] folder id\r\n   * @param {object} [options] upload file meta\r\n   * @param {number} [options.size] upload file size\r\n   * @param {string} [options.name] upload file name\r\n   * @param {ReadableStream} [options.stream] upload file stream\r\n   * @param {object} [credentials] credentials\r\n   * @return {string | error}\r\n   * \r\n   * @api public\r\n   */\r\n  async upload(id, stream, { size, name, manual, conflictBehavior, ...rest }) {\r\n\r\n    const app = this.app\r\n\r\n    let { uploadId, uploadUrl, start } = await this.beforeUpload(rest.uploadId, { id, name, size, conflictBehavior })\r\n\r\n    const done = async (stream) => {\r\n      let retryTimes = 3\r\n\r\n      while (retryTimes-- > 0) {\r\n\r\n        let readStream = (typeof stream == 'function') ? await stream(start, uploadId) : stream\r\n\r\n        if (readStream === undefined) return\r\n        let res = await app.request(uploadUrl, {\r\n          method: 'put',\r\n          data: readStream,\r\n          contentType: 'stream',\r\n          signal: rest.signal,\r\n          // responseType: 'text',\r\n          headers: {\r\n            'Content-Range': `bytes ${start}-${size - 1}/${size}`,\r\n            'Content-Length': size - start,\r\n          }\r\n        })\r\n        console.log(res.status, '--->')\r\n        if (res.status != 201 && res.status != 202) {\r\n          // 500 502 503 504 retry\r\n          if (+res.status >= 500) {\r\n            await sleep(app.utils.retryTime(3 - retryTimes))\r\n            continue\r\n          } else {\r\n            return this.app.error({ message: res.data?.error?.message || ('An error occurred during upload: ' + name) })\r\n          }\r\n        }\r\n\r\n        return {\r\n          id: res.data.id,\r\n          name: res.data.name,\r\n          parent_id: id\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    if (!stream) {\r\n      return { uploadId, start, done }\r\n    } else {\r\n      return await done(stream)\r\n    }\r\n\r\n  }\r\n\r\n\r\n  async monitor(url, timeout = 8 * 1000) {\r\n    console.log('[monitor]', url)\r\n    let startTime = Date.now()\r\n\r\n    while (Date.now() - startTime < timeout) {\r\n      let { data } = await this.app.request.get(url, { responseType: 'json' })\r\n\r\n      if (data?.status == 'completed') {\r\n        return { id: data.resourceId }\r\n      }\r\n\r\n      await sleep(200)\r\n    }\r\n\r\n  }\r\n}\r\n\r\nmodule.exports = { driver: Driver }\r\n"},{"hash":"7549a969650a7b4f8d3b9c73b372e5df","name":"VirtualDrive","namespace":"sharelist.plugin.vdrive","version":"1.0.0","license":"MIT","description":"sharelist 内置的虚拟网盘，使用yaml/json进行描述。","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/vdrive/index.js","script":"//===Sharelist===\r\n// @name         VirtualDrive\r\n// @namespace    sharelist.plugin.vdrive\r\n// @version      1.0.0\r\n// @license      MIT\r\n// @description  sharelist 内置的虚拟网盘，使用yaml/json进行描述。\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/vdrive/index.js\r\n//===/Sharelist==\r\nconst yaml = require('yaml')\r\n\r\nconst { URL } = require('url')\r\n\r\nconst crypto = require('crypto')\r\n\r\nconst fs = require('fs')\r\n\r\nconst os = require('os')\r\n\r\nconst md5 = (v) => {\r\n  return crypto.createHash('md5').update(v).digest('hex')\r\n}\r\nconst decode = v => decodeURIComponent(Buffer.from(v, 'base64').toString())\r\n\r\nconst encode = v => Buffer.from(encodeURIComponent(v)).toString('base64')\r\n\r\nconst isWinOS = os.platform() == 'win32'\r\n\r\nconst winStyle = (p) =>\r\n  p\r\n    .replace(/^\\/([^\\/]+?)/, '$1:\\\\')\r\n    .replace(/\\//g, '\\\\')\r\n    .replace(/(?<!\\:)\\\\+$/, '')\r\n    .replace(/\\\\{2,}/g, '\\\\')\r\n\r\nconst ospath = (p, base = '') => {\r\n  p = base + p\r\n  return isWinOS ? winStyle(p) : (p)\r\n}\r\n\r\nconst diskMap = {}\r\nconst parse = (id) => {\r\n  let data = new URL(id)\r\n\r\n  let rootId = data.hostname\r\n  let path = data.pathname.replace(/^\\/+/, '').split('/')\r\n  return {\r\n    disk: diskMap[rootId],\r\n    path,\r\n  }\r\n}\r\nclass Driver {\r\n  static options = {\r\n    globalSearch: false,\r\n    localSearch: true,\r\n    protocol: \"vdrive\",\r\n    cache: false,\r\n    pagination: false,\r\n    guide: [\r\n      { key: 'src', label: '目录地址', type: 'string', help: '可指定远程地址(HTTP/HTTPS协议) 或者 本地文件(posix风格)', required: true },\r\n    ],\r\n  }\r\n\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.config = config\r\n  }\r\n\r\n  async getRoot() {\r\n    if (!this.key) {\r\n      let rootId = this.config.src\r\n      let key = md5(rootId)\r\n      this.key = key\r\n      diskMap[key] = {\r\n        id: rootId\r\n      }\r\n\r\n      if (/^https?/i.test(rootId)) {\r\n        let res = await this.app.request(rootId, {\r\n          responseType: 'text'\r\n        })\r\n        let json = yaml.parse(res)\r\n        diskMap[key].data = json\r\n      } else {\r\n        try {\r\n          let res = fs.readFileSync(ospath(rootId), { encoding: 'utf-8' })\r\n          let json = yaml.parse(res)\r\n          diskMap[key].data = json\r\n        } catch (e) {\r\n          console.log(e)\r\n          throw { message: 'can not read rootId' }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { children: diskMap[this.key].data }\r\n  }\r\n\r\n  async list(id, { search, orderBy } = {}) {\r\n    let disk = await this.getRoot()\r\n\r\n    id = id || 'root'\r\n\r\n    let path = id == 'root' ? [] : id.split('/').filter(Boolean).map(decode)\r\n    if (disk) {\r\n      for (let i = 0; i < path.length && disk; i++) {\r\n        if (!disk.children) {\r\n          throw { code: 404 }\r\n        }\r\n        disk = disk.children.find((j) => j.name == decodeURIComponent(path[i])) //[ parseInt(path[i]) ]\r\n      }\r\n      let isDir = (disk.children && !disk.url)\r\n\r\n      if (isDir) {\r\n        return {\r\n          id,\r\n          files: disk.children.map(i => ({\r\n            id: [...path, i.name].map(encode).join('/'),\r\n            name: i.name,\r\n            type: (i.children && !i.url) ? 'folder' : 'file',\r\n            size: i.size || 0,\r\n          }))\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    throw { code: 404 }\r\n\r\n  }\r\n\r\n  async get(id) {\r\n    if (!id) {\r\n      return {\r\n        id: '@drive_root',\r\n        name: '@drive_root'\r\n      }\r\n    }\r\n\r\n    let disk = await this.getRoot()\r\n\r\n    let path = id.split('/').filter(Boolean).map(decode)\r\n    if (disk) {\r\n      for (let i = 0; i < path.length && disk; i++) {\r\n        disk = disk.children.find((j) => j.name == path[i]) //[ parseInt(path[i]) ]\r\n      }\r\n\r\n      return {\r\n        id,\r\n        name: disk.name,\r\n        size: disk.size,\r\n        type: (disk.children && !disk.url) ? 'folder' : 'file',\r\n        ctime: Date.now(),\r\n        mtime: Date.now(),\r\n        download_url: disk.url,\r\n        extra: {\r\n          parent_id: path.slice(0, -1).filter(Boolean).map(encode).join('/')\r\n        }\r\n      }\r\n    }\r\n\r\n    throw { code: 404 }\r\n  }\r\n}\r\n\r\nmodule.exports = { driver: Driver }\r\n"},{"hash":"b17e3ac08dd6facf88ed4198da1b124c","name":"⚡️XV⚡️","namespace":"sharelist.plugin.xv","version":"0.1.0","license":"MIT","description":"sharelist 演示插件，用于挂载全球访问量排名前10的某网站","author":"reruin@gmail.com","supportURL":"https://github.com/reruin/sharelist","updateURL":"https://raw.githubusercontent.com/linkdrive/plugins/master/packages/xv/index.js","icon":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMjUiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDU4NCAxNDkiPgogIDxwYXRoIHN0cm9rZS13aWR0aD0iLjA0NCIgZD0iTS40MzQuNzAzaDk5LjIwN3YyMy44MjRILjQzNHoiLz4KICA8cGF0aCBkPSJNMTEuMDY3IDkuODkzbDIuNjY2LTUuNDU3aDQuMzRsLTQuNjM1IDguMDE1IDQuOTkyIDguMTU0aC00LjU1N2wtMi43Ni01LjU2NS0yLjc2IDUuNTY1aC00LjM0bDQuNzYtOC4xNTQtNC42MzYtOC4wMTVoNC4yOTR6IiBmaWxsPSIjZGUyNjAwIi8+CiAgPHBhdGggZD0iTTc0LjMgNC4xODhjLTIuMDQ2IDAtMy43MDQuNjM3LTQuOTc2IDEuOTM5LTEuMjcxIDEuMzAyLTEuOTA2IDIuOTQzLTEuOTA2IDQuOTI4djIuOTE2YzAgMiAuNjM1IDMuNjQzIDEuOTA2IDQuOTMgMS4yNzIgMS4yODYgMi45NDYgMS45MzcgNC45OTIgMS45MzcgMi4wMzEgMCAzLjY5LS42NTEgNC45NDYtMS45MzggMS4yNTYtMS4zMDIgMS44OS0yLjkzIDEuODktNC45M2guMDE2di0yLjkxNWMwLTItLjYzNS0zLjYyNi0xLjkwNi00LjkyOC0xLjI4Ny0xLjI4Ny0yLjkzLTEuOTQtNC45NjEtMS45NHptMTUuMDA3LjAxNWMtMS43OTggMC0zLjI4Ny40Mi00LjQ2NSAxLjI1Ni0xLjE3OC44MzctMS43NjggMS45MzktMS43NjggMy4yODcgMCAxLjM5NS40ODEgMi40NSAxLjQ3MyAzLjE5My45NzcuNzQ1IDIuNDk3IDEuNDI3IDQuNTQzIDIuMDc5Ljk3Ny4zNTYgMS42NTkuNjgyIDIuMDMxLjk5Mi4zODcuMzEuNTc0Ljc0My41NzQgMS4zMTYgMCAuNDk3LS4yMDIuOS0uNTU4IDEuMjI1LS4zNzIuMzEtLjk2Mi40NjUtMS43MzcuNDY1LTEuMDIzIDAtMS43OTgtLjItMi4yOTUtLjYwNC0uNTExLS40MDMtLjc2LTEuMDctLjc2LTJoLTMuNjU3bC0uMDE2LjA2M2MtLjA0NyAxLjczNi42MiAzLjA3IDEuOTUzIDMuOTg0IDEuMzMzLjkxNSAyLjkxNSAxLjM3OSA0Ljc2IDEuMzc5IDEuODMgMCAzLjMwMS0uNDAyIDQuNDAyLTEuMjEgMS4xLS43OSAxLjY1OC0xLjkwNyAxLjY1OC0zLjMzMyAwLTEuMzk2LS40NjQtMi40OTYtMS4zOTQtMy4zMDMtLjkzLS43OS0yLjMxLTEuNDctNC4xNTUtMi4wMTMtMS4xOTQtLjQzNS0xLjk5OS0uNzkyLTIuNDMzLTEuMDctLjQzNC0uMjgtLjY1Mi0uNjUyLS42NTItMS4xMzIgMC0uNDk2LjIxOC0uOTE1LjY1Mi0xLjI0LjQzNC0uMzI2IDEuMDIyLS40OTYgMS43ODEtLjQ5Ni43NzUgMCAxLjM4LjIgMS44MTUuNjA0LjQzNC40MDMuNjUyLjkxNS42NTIgMS41NjZoMy42NDNsLjAxNS0uMDYzYy4wNDctMS40NTctLjUxMy0yLjY1LTEuNjYtMy41NjQtMS4xNDctLjkxNS0yLjYwNC0xLjM4LTQuNDAyLTEuMzh6bS0zNC4yNDQuMjMzdjE2LjE3SDY2LjN2LTIuODgzaC03LjQ3VjEzLjY5aDYuMzM5di0yLjloLTYuMzQydi0zLjQ3aDcuNTA0VjQuNDM1aC0xMS4yN3ptLTM2Ljc3Mi4wMDJsNS4yMjUgMTYuMTgzaDQuMDZsNS4yNC0xNi4xODNIMjguODhsLTMuMjEgMTEuODI2LS4xMDguNTQzSDI1LjVsLS4xMS0uNTg4TDIyLjIzIDQuNDM4SDE4LjI5em0xNS44MTMgMHYxNi4xNjdoMy43NTFWNC40MzhoLTMuNzUxem02LjMwOCAwdjE2LjE4MWg1Ljg0NmMxLjkwNiAwIDMuNDg2LS42MiA0Ljc3My0xLjg2IDEuMjg4LTEuMjM5IDEuOTI0LTIuODIgMS45MjQtNC43NzNWMTEuMDdjMC0xLjkzNy0uNjM3LTMuNTMzLTEuOTI0LTQuNzczLTEuMjcxLTEuMjQtMi44NjctMS44Ni00Ljc3My0xLjg2aC01Ljg0NnptMzMuODU4IDIuNjVjLjk5MiAwIDEuNzY3LjM3IDIuMzEgMS4xMTUuNTQzLjcyOS44MiAxLjY3NS44MiAyLjgzOGwuMDAyIDIuOTNjMCAxLjE3OC0uMjY0IDIuMTIyLS44MDYgMi44NjctLjU0My43NDQtMS4zMDMgMS4xMTctMi4yOTUgMS4xMTctMS4wMjMgMC0xLjgtLjM3My0yLjM0Mi0xLjExN3MtLjgyLTEuNzA1LS44Mi0yLjg2N3YtMi45M2MwLTEuMTYzLjI2My0yLjEwOS44MDYtMi44NTMuNTI3LS43MyAxLjMxNy0xLjEgMi4zMjUtMS4xem0tMzAuMDkuMjQ2aDEuODNjLjk5MiAwIDEuNzgxLjM0MSAyLjM0IDEuMDIzLjU1OC42ODMuODM4IDEuNTgxLjgzOCAyLjY5OHYyLjkzMWMwIDEuMTE2LS4yOCAyLjAzMS0uODM4IDIuNzEzLS41NTkuNjgyLTEuMzMzIDEuMDIyLTIuMzQgMS4wMjJoLTEuODNWNy4zMzR6IiBmaWxsPSIjZmZmIiBzdHJva2Utd2lkdGg9Ii4yMTkiLz4KPC9zdmc+Cg==","script":"//===Sharelist===\r\n// @name         ⚡️XV⚡️\r\n// @namespace    sharelist.plugin.xv\r\n// @version      0.1.0\r\n// @license      MIT\r\n// @description  sharelist 演示插件，用于挂载全球访问量排名前10的某网站\r\n// @author       reruin@gmail.com\r\n// @supportURL   https://github.com/reruin/sharelist\r\n// @updateURL    https://raw.githubusercontent.com/linkdrive/plugins/master/packages/xv/index.js\r\n// @icon         data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMjUiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDU4NCAxNDkiPgogIDxwYXRoIHN0cm9rZS13aWR0aD0iLjA0NCIgZD0iTS40MzQuNzAzaDk5LjIwN3YyMy44MjRILjQzNHoiLz4KICA8cGF0aCBkPSJNMTEuMDY3IDkuODkzbDIuNjY2LTUuNDU3aDQuMzRsLTQuNjM1IDguMDE1IDQuOTkyIDguMTU0aC00LjU1N2wtMi43Ni01LjU2NS0yLjc2IDUuNTY1aC00LjM0bDQuNzYtOC4xNTQtNC42MzYtOC4wMTVoNC4yOTR6IiBmaWxsPSIjZGUyNjAwIi8+CiAgPHBhdGggZD0iTTc0LjMgNC4xODhjLTIuMDQ2IDAtMy43MDQuNjM3LTQuOTc2IDEuOTM5LTEuMjcxIDEuMzAyLTEuOTA2IDIuOTQzLTEuOTA2IDQuOTI4djIuOTE2YzAgMiAuNjM1IDMuNjQzIDEuOTA2IDQuOTMgMS4yNzIgMS4yODYgMi45NDYgMS45MzcgNC45OTIgMS45MzcgMi4wMzEgMCAzLjY5LS42NTEgNC45NDYtMS45MzggMS4yNTYtMS4zMDIgMS44OS0yLjkzIDEuODktNC45M2guMDE2di0yLjkxNWMwLTItLjYzNS0zLjYyNi0xLjkwNi00LjkyOC0xLjI4Ny0xLjI4Ny0yLjkzLTEuOTQtNC45NjEtMS45NHptMTUuMDA3LjAxNWMtMS43OTggMC0zLjI4Ny40Mi00LjQ2NSAxLjI1Ni0xLjE3OC44MzctMS43NjggMS45MzktMS43NjggMy4yODcgMCAxLjM5NS40ODEgMi40NSAxLjQ3MyAzLjE5My45NzcuNzQ1IDIuNDk3IDEuNDI3IDQuNTQzIDIuMDc5Ljk3Ny4zNTYgMS42NTkuNjgyIDIuMDMxLjk5Mi4zODcuMzEuNTc0Ljc0My41NzQgMS4zMTYgMCAuNDk3LS4yMDIuOS0uNTU4IDEuMjI1LS4zNzIuMzEtLjk2Mi40NjUtMS43MzcuNDY1LTEuMDIzIDAtMS43OTgtLjItMi4yOTUtLjYwNC0uNTExLS40MDMtLjc2LTEuMDctLjc2LTJoLTMuNjU3bC0uMDE2LjA2M2MtLjA0NyAxLjczNi42MiAzLjA3IDEuOTUzIDMuOTg0IDEuMzMzLjkxNSAyLjkxNSAxLjM3OSA0Ljc2IDEuMzc5IDEuODMgMCAzLjMwMS0uNDAyIDQuNDAyLTEuMjEgMS4xLS43OSAxLjY1OC0xLjkwNyAxLjY1OC0zLjMzMyAwLTEuMzk2LS40NjQtMi40OTYtMS4zOTQtMy4zMDMtLjkzLS43OS0yLjMxLTEuNDctNC4xNTUtMi4wMTMtMS4xOTQtLjQzNS0xLjk5OS0uNzkyLTIuNDMzLTEuMDctLjQzNC0uMjgtLjY1Mi0uNjUyLS42NTItMS4xMzIgMC0uNDk2LjIxOC0uOTE1LjY1Mi0xLjI0LjQzNC0uMzI2IDEuMDIyLS40OTYgMS43ODEtLjQ5Ni43NzUgMCAxLjM4LjIgMS44MTUuNjA0LjQzNC40MDMuNjUyLjkxNS42NTIgMS41NjZoMy42NDNsLjAxNS0uMDYzYy4wNDctMS40NTctLjUxMy0yLjY1LTEuNjYtMy41NjQtMS4xNDctLjkxNS0yLjYwNC0xLjM4LTQuNDAyLTEuMzh6bS0zNC4yNDQuMjMzdjE2LjE3SDY2LjN2LTIuODgzaC03LjQ3VjEzLjY5aDYuMzM5di0yLjloLTYuMzQydi0zLjQ3aDcuNTA0VjQuNDM1aC0xMS4yN3ptLTM2Ljc3Mi4wMDJsNS4yMjUgMTYuMTgzaDQuMDZsNS4yNC0xNi4xODNIMjguODhsLTMuMjEgMTEuODI2LS4xMDguNTQzSDI1LjVsLS4xMS0uNTg4TDIyLjIzIDQuNDM4SDE4LjI5em0xNS44MTMgMHYxNi4xNjdoMy43NTFWNC40MzhoLTMuNzUxem02LjMwOCAwdjE2LjE4MWg1Ljg0NmMxLjkwNiAwIDMuNDg2LS42MiA0Ljc3My0xLjg2IDEuMjg4LTEuMjM5IDEuOTI0LTIuODIgMS45MjQtNC43NzNWMTEuMDdjMC0xLjkzNy0uNjM3LTMuNTMzLTEuOTI0LTQuNzczLTEuMjcxLTEuMjQtMi44NjctMS44Ni00Ljc3My0xLjg2aC01Ljg0NnptMzMuODU4IDIuNjVjLjk5MiAwIDEuNzY3LjM3IDIuMzEgMS4xMTUuNTQzLjcyOS44MiAxLjY3NS44MiAyLjgzOGwuMDAyIDIuOTNjMCAxLjE3OC0uMjY0IDIuMTIyLS44MDYgMi44NjctLjU0My43NDQtMS4zMDMgMS4xMTctMi4yOTUgMS4xMTctMS4wMjMgMC0xLjgtLjM3My0yLjM0Mi0xLjExN3MtLjgyLTEuNzA1LS44Mi0yLjg2N3YtMi45M2MwLTEuMTYzLjI2My0yLjEwOS44MDYtMi44NTMuNTI3LS43MyAxLjMxNy0xLjEgMi4zMjUtMS4xem0tMzAuMDkuMjQ2aDEuODNjLjk5MiAwIDEuNzgxLjM0MSAyLjM0IDEuMDIzLjU1OC42ODMuODM4IDEuNTgxLjgzOCAyLjY5OHYyLjkzMWMwIDEuMTE2LS4yOCAyLjAzMS0uODM4IDIuNzEzLS41NTkuNjgyLTEuMzMzIDEuMDIyLTIuMzQgMS4wMjJoLTEuODNWNy4zMzR6IiBmaWxsPSIjZmZmIiBzdHJva2Utd2lkdGg9Ii4yMTkiLz4KPC9zdmc+Cg==\r\n//===/Sharelist==\r\n\r\nconst HOST = Buffer.from('aHR0cHM6Ly93d3cueHZpZGVvcy5jb20=', 'base64').toString();\r\n\r\nconst decode = v => Buffer.from(v, 'base64').toString()\r\n\r\nconst encode = v => Buffer.from(v).toString('base64')\r\n\r\nconst re = v => v.split('').reverse().join('')\r\n\r\nconst UA = `Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36`\r\n\r\nconst getListUrl = (id, sk, page = 1) => {\r\n  let tag = id != '@' ? decode(id) : ''\r\n  let key\r\n  if (sk) {\r\n    key = `/?k=${sk}&p=${page}`\r\n  }\r\n  else if (tag.startsWith('/' + re('nrop')) || tag.startsWith('/lang')) {\r\n    key = tag + '/' + page\r\n  }\r\n  else if (/^\\/c\\//.test(tag)) {\r\n    key = tag.replace('c/', 'c/' + page + '/')\r\n  }\r\n  else if (/^\\/\\?k=/.test(tag)) {\r\n    key = tag + '&p=' + page\r\n  }\r\n  else {\r\n    key = '/new/' + page\r\n  }\r\n  return HOST + key\r\n}\r\n\r\nclass Driver {\r\n\r\n  static options = {\r\n    globalSearch: true,\r\n    localSearch: false,\r\n    protocol: \"xv\",\r\n    cache: false,\r\n    guide: [\r\n      { key: 'zone', label: '地区 / Zone', help: '不同国家对应不同推荐内容，填写 cn/en/jp 等', type: 'string', required: false },\r\n      { key: 'group', label: '页码分组', type: 'boolean', help: '', required: false },\r\n      { key: 'proxy', label: '代理地址', help: '设置后该挂载盘的所有请求均使用此代理。支持HTTP/HTTPS', type: 'string', required: false },\r\n    ]\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {*} app \r\n   * @param {*} config 默认配置(响应式)\r\n   */\r\n  constructor(app, config) {\r\n    this.app = app\r\n    this.config = config\r\n\r\n    // this.getConfig = Manager.getInstance(app, config)\r\n  }\r\n\r\n  /**\r\n   * 列出目录\r\n   *\r\n   * @param {string} [id] 文件(目录)id 唯一值\r\n   * \r\n   * @param {object} [options] 参数\r\n   * @param {object} [options.order_by] 排序\r\n   * @param {object} [options.page] 页码\r\n   * @param {object} [options.per_page] 每页条目数\r\n   * @param {object} [options.search] 搜索内容\r\n   * \r\n   * @return {object}\r\n   *\r\n   * @api public {Array<file>}\r\n   * \r\n   * files.id 资源ID\r\n   * files.name 资源名\r\n   * files.size 资源大小\r\n   * files.type 类型 'folder' | 'file'\r\n   * files.ctime 创建时间\r\n   * files.mtime 修改时间\r\n   */\r\n  async list(id, { search, orderBy, perPage, nextPage } = {}) {\r\n    let usePagination = !!perPage\r\n\r\n    //使用自然分页\r\n    nextPage = nextPage || 1\r\n\r\n    if (!id) {\r\n      if (nextPage > 1) return { files: [] }\r\n      else return {\r\n        files: await this.getCats()\r\n      }\r\n    }\r\n    if (!id.startsWith('@')) {\r\n      return { files: [] }\r\n    }\r\n\r\n\r\n    let url = getListUrl(id.substring(1), search, nextPage)\r\n\r\n    let res = await this.app.request.get(url, {\r\n      proxy: this.config.proxy,\r\n      responseType: 'text',\r\n      'user-agent': UA\r\n    })\r\n    let files = []\r\n    const htmlEntity = this.app.utils.htmlEntity\r\n    res.data?.replace(/<img[\\w\\W]+?data-src=\"([^\"]+?)\"[\\w\\W]+?<a href=\"([^\"]+?)\"\\s+title=\"([^\"]+?)\"/g, ($0, $1, $2, $3) => {\r\n      files.push({\r\n        id: encode($2),\r\n        name: htmlEntity.decode($3) + '.mp4', //$3 is title\r\n        type: 'file',\r\n        size: 0,\r\n        mime: 'video/mp4',\r\n        ctime: Date.now(),\r\n        mtime: Date.now(),\r\n        extra: {\r\n          sources: [\r\n            { size: 480, quality: 'LD' },\r\n            { size: 720, quality: 'HD' }\r\n          ]\r\n        },\r\n        thumb: $1,\r\n      })\r\n    })\r\n\r\n    return { id, files, nextPage: nextPage++ }\r\n  }\r\n\r\n\r\n  //获取分类\r\n  async getCats() {\r\n    const ua = `Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36`\r\n    if (!this.cats) {\r\n      let zone = this.config.zone || 'cn'\r\n      let proxy = this.config.proxy\r\n\r\n      let { data, headers } = await this.app.request.get(`${HOST}/change-country/${zone}`, {\r\n        // followRedirect: false,\r\n        responseType: 'text',\r\n        headers: {\r\n          'User-Agent': ua,\r\n        },\r\n        proxy\r\n      })\r\n      const cats = [{\r\n        id: '@',\r\n        name: '所有',\r\n        type: 'folder',\r\n        size: 0,\r\n        ctime: Date.now(),\r\n        mtime: Date.now(),\r\n      }]\r\n\r\n      data.replace(/<span[^>]+><\\/span>/g, '').replace(/<li class=\"dyn[^>]+?><a[\\w\\W]+?href=\"([^\"]+?)\"[^>]*?>([^<]+?)<\\/a><\\/li>/g, ($0, $1, $2) => {\r\n        cats.push({\r\n          id: '@' + encode($1),\r\n          name: $2.replace(/^\\s*/, ''),\r\n          type: 'folder',\r\n          size: 0,\r\n          ctime: Date.now(),\r\n          mtime: Date.now(),\r\n        })\r\n        return ''\r\n      })\r\n\r\n      this.cats = cats\r\n    }\r\n    return this.cats.map(i => ({ ...i }))\r\n  }\r\n\r\n  /**\r\n   * 获取文件详情\r\n   * @param {*} id 文件(目录)id 唯一值\r\n   * @param {*} key \r\n   */\r\n  async get(id) {\r\n    if (id == 'root') {\r\n      return {\r\n        id: 'root',\r\n        name: '@root',\r\n        type: 'folder'\r\n      }\r\n    }\r\n    const pathname = decode(id)\r\n\r\n    let { data } = await this.app.request.get(HOST + pathname, {\r\n      responseType: 'text',\r\n      'user-agent': UA,\r\n      proxy: this.config.proxy\r\n\r\n    })\r\n\r\n    let url_low = (data.match(/setVideoUrlLow\\('([^'\"]+?)'/) || ['', ''])[1]\r\n\r\n    let url_high = (data.match(/setVideoUrlHigh\\('([^'\"]+?)'/) || ['', ''])[1]\r\n\r\n    let url_hls = (data.match(/setVideoHLS\\('([^'\"]+?)'/) || ['', ''])[1]\r\n\r\n    let thumb = (data.match(/setThumbUrl169\\('([^'\"]+?)'/) || ['', ''])[1]\r\n\r\n    let name = (data.match(/setVideoTitle\\('([^'\"]+?)'/) || ['', ''])[1]\r\n\r\n    let result = {\r\n      id: id,\r\n      name: `${name}.mp4`,\r\n      size: 0,\r\n      type: 'file',\r\n      ctime: Date.now(),\r\n      mtime: Date.now(),\r\n      thumb,\r\n      download_url: url_low,\r\n      extra: {\r\n        parent_id: 'root',\r\n        category: 'video',\r\n        sources: [\r\n          { name: 'LD', src: url_low },\r\n          { name: 'HD', src: url_high },\r\n        ]\r\n      }\r\n    }\r\n\r\n    if (this.config.proxy) {\r\n      result.extra.proxy = {\r\n        proxy_server: this.config.proxy,\r\n        headers: {\r\n          'user-agent': UA,\r\n          'referer': HOST\r\n        },\r\n      }\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = { driver: Driver }"}]